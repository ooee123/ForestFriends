
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000078  00800100  00002e90  00002f24  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e90  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000b06  00800178  00800178  00002f9c  2**0
                  ALLOC
  3 .stab         0000c8dc  00000000  00000000  00002f9c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000dac9  00000000  00000000  0000f878  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0001d341  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__ctors_end>
       4:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
       8:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
       c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      10:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      14:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      18:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      1c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      20:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      24:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      28:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      2c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      30:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      34:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      38:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      3c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      40:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      44:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      48:	0c 94 5f 07 	jmp	0xebe	; 0xebe <__vector_18>
      4c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      50:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      54:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      58:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      5c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      60:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      64:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      68:	0c 94 bf 09 	jmp	0x137e	; 0x137e <__vector_26>
      6c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      70:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      74:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      78:	0c 94 b1 07 	jmp	0xf62	; 0xf62 <__vector_30>
      7c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      80:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      84:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      88:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      8c:	3c 05       	cpc	r19, r12
      8e:	45 05       	cpc	r20, r5
      90:	48 05       	cpc	r20, r8
      92:	4b 05       	cpc	r20, r11
      94:	4e 05       	cpc	r20, r14
      96:	51 05       	cpc	r21, r1
      98:	53 05       	cpc	r21, r3
      9a:	63 05       	cpc	r22, r3
      9c:	6a 05       	cpc	r22, r10
      9e:	3e 05       	cpc	r19, r14
      a0:	42 05       	cpc	r20, r2

000000a2 <_ZZN8frt_task15emergency_resetEvE3__c>:
      a2:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

000000b1 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
      b1:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000000bb <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_2>:
      bb:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
      cb:	61 73 6b 20 00                                      ask .

000000d0 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c>:
      d0:	54 61 73 6b 20 00                                   Task .

000000d6 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_0>:
      d6:	20 63 72 65 61 74 65 64 00                           created.

000000df <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_1>:
      df:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000000ed <_ZZ15print_task_listP8emstreamE3__c_7>:
      ed:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000000f8 <_ZZ15print_task_listP8emstreamE3__c_8>:
      f8:	2f 00                                               /.

000000fa <_ZZ15print_task_listP8emstreamE3__c_9>:
      fa:	09 09 00                                            ...

000000fd <_ZZ15print_task_listP8emstreamE3__c_4>:
      fd:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

0000010e <_ZZ15print_task_listP8emstreamE3__c_5>:
     10e:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

0000011a <_ZZ15print_task_listP8emstreamE3__c_6>:
     11a:	09 2d 2d 2d 2d 00                                   .----.

00000120 <_ZZ15print_task_listP8emstreamE3__c_1>:
     120:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000131 <_ZZ15print_task_listP8emstreamE3__c_2>:
     131:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000013d <_ZZ15print_task_listP8emstreamE3__c_3>:
     13d:	09 52 75 6e 73 00                                   .Runs.

00000143 <_ZZ15print_task_listP8emstreamE3__c>:
     143:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000014e <_ZZ15print_task_listP8emstreamE3__c_0>:
     14e:	09 53 74 61 63 6b 00                                .Stack.

00000155 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     155:	09 00                                               ..

00000157 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     157:	09 00                                               ..

00000159 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     159:	2f 00                                               /.

0000015b <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     15b:	09 00                                               ..

0000015d <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     15d:	09 00 00                                            ...

00000160 <__ctors_start>:
     160:	22 16       	cp	r2, r18

00000162 <__ctors_end>:
     162:	11 24       	eor	r1, r1
     164:	1f be       	out	0x3f, r1	; 63
     166:	cf ef       	ldi	r28, 0xFF	; 255
     168:	d0 e1       	ldi	r29, 0x10	; 16
     16a:	de bf       	out	0x3e, r29	; 62
     16c:	cd bf       	out	0x3d, r28	; 61

0000016e <__do_copy_data>:
     16e:	11 e0       	ldi	r17, 0x01	; 1
     170:	a0 e0       	ldi	r26, 0x00	; 0
     172:	b1 e0       	ldi	r27, 0x01	; 1
     174:	e0 e9       	ldi	r30, 0x90	; 144
     176:	fe e2       	ldi	r31, 0x2E	; 46
     178:	00 e0       	ldi	r16, 0x00	; 0
     17a:	0b bf       	out	0x3b, r16	; 59
     17c:	02 c0       	rjmp	.+4      	; 0x182 <__do_copy_data+0x14>
     17e:	07 90       	elpm	r0, Z+
     180:	0d 92       	st	X+, r0
     182:	a8 37       	cpi	r26, 0x78	; 120
     184:	b1 07       	cpc	r27, r17
     186:	d9 f7       	brne	.-10     	; 0x17e <__do_copy_data+0x10>

00000188 <__do_clear_bss>:
     188:	1c e0       	ldi	r17, 0x0C	; 12
     18a:	a8 e7       	ldi	r26, 0x78	; 120
     18c:	b1 e0       	ldi	r27, 0x01	; 1
     18e:	01 c0       	rjmp	.+2      	; 0x192 <.do_clear_bss_start>

00000190 <.do_clear_bss_loop>:
     190:	1d 92       	st	X+, r1

00000192 <.do_clear_bss_start>:
     192:	ae 37       	cpi	r26, 0x7E	; 126
     194:	b1 07       	cpc	r27, r17
     196:	e1 f7       	brne	.-8      	; 0x190 <.do_clear_bss_loop>

00000198 <__do_global_ctors>:
     198:	11 e0       	ldi	r17, 0x01	; 1
     19a:	c2 e6       	ldi	r28, 0x62	; 98
     19c:	d1 e0       	ldi	r29, 0x01	; 1
     19e:	00 e0       	ldi	r16, 0x00	; 0
     1a0:	06 c0       	rjmp	.+12     	; 0x1ae <__do_global_ctors+0x16>
     1a2:	22 97       	sbiw	r28, 0x02	; 2
     1a4:	01 09       	sbc	r16, r1
     1a6:	fe 01       	movw	r30, r28
     1a8:	0b bf       	out	0x3b, r16	; 59
     1aa:	0e 94 c4 16 	call	0x2d88	; 0x2d88 <__tablejump_elpm__>
     1ae:	c0 36       	cpi	r28, 0x60	; 96
     1b0:	d1 07       	cpc	r29, r17
     1b2:	80 e0       	ldi	r24, 0x00	; 0
     1b4:	08 07       	cpc	r16, r24
     1b6:	a9 f7       	brne	.-22     	; 0x1a2 <__do_global_ctors+0xa>
     1b8:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <main>
     1bc:	0c 94 46 17 	jmp	0x2e8c	; 0x2e8c <_exit>

000001c0 <__bad_interrupt>:
     1c0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001c4 <_ZN10motor_task3runEv>:
     1c4:	cf 93       	push	r28
     1c6:	df 93       	push	r29
     1c8:	00 d0       	rcall	.+0      	; 0x1ca <_ZN10motor_task3runEv+0x6>
     1ca:	00 d0       	rcall	.+0      	; 0x1cc <_ZN10motor_task3runEv+0x8>
     1cc:	cd b7       	in	r28, 0x3d	; 61
     1ce:	de b7       	in	r29, 0x3e	; 62
     1d0:	3c 01       	movw	r6, r24
     1d2:	0e 94 65 0f 	call	0x1eca	; 0x1eca <xTaskGetTickCount>
     1d6:	69 83       	std	Y+1, r22	; 0x01
     1d8:	7a 83       	std	Y+2, r23	; 0x02
     1da:	8b 83       	std	Y+3, r24	; 0x03
     1dc:	9c 83       	std	Y+4, r25	; 0x04
     1de:	84 e1       	ldi	r24, 0x14	; 20
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	0e 94 be 04 	call	0x97c	; 0x97c <_Znwj>
     1e6:	2c 01       	movw	r4, r24
     1e8:	f3 01       	movw	r30, r6
     1ea:	66 81       	ldd	r22, Z+6	; 0x06
     1ec:	77 81       	ldd	r23, Z+7	; 0x07
     1ee:	1f 92       	push	r1
     1f0:	8a e4       	ldi	r24, 0x4A	; 74
     1f2:	8f 93       	push	r24
     1f4:	87 e0       	ldi	r24, 0x07	; 7
     1f6:	8f 93       	push	r24
     1f8:	85 e0       	ldi	r24, 0x05	; 5
     1fa:	8f 93       	push	r24
     1fc:	82 e0       	ldi	r24, 0x02	; 2
     1fe:	8f 93       	push	r24
     200:	83 e0       	ldi	r24, 0x03	; 3
     202:	88 2e       	mov	r8, r24
     204:	97 e0       	ldi	r25, 0x07	; 7
     206:	a9 2e       	mov	r10, r25
     208:	25 e3       	ldi	r18, 0x35	; 53
     20a:	c2 2e       	mov	r12, r18
     20c:	d1 2c       	mov	r13, r1
     20e:	32 e3       	ldi	r19, 0x32	; 50
     210:	e3 2e       	mov	r14, r19
     212:	f1 2c       	mov	r15, r1
     214:	07 e3       	ldi	r16, 0x37	; 55
     216:	10 e0       	ldi	r17, 0x00	; 0
     218:	24 e3       	ldi	r18, 0x34	; 52
     21a:	30 e0       	ldi	r19, 0x00	; 0
     21c:	41 e3       	ldi	r20, 0x31	; 49
     21e:	50 e0       	ldi	r21, 0x00	; 0
     220:	c2 01       	movw	r24, r4
     222:	0e 94 40 01 	call	0x280	; 0x280 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj>
     226:	0f 90       	pop	r0
     228:	0f 90       	pop	r0
     22a:	0f 90       	pop	r0
     22c:	0f 90       	pop	r0
     22e:	0f 90       	pop	r0
     230:	c2 01       	movw	r24, r4
     232:	0e 94 cc 01 	call	0x398	; 0x398 <_ZN12motor_driver5brakeEv>
     236:	f3 01       	movw	r30, r6
     238:	86 85       	ldd	r24, Z+14	; 0x0e
     23a:	97 85       	ldd	r25, Z+15	; 0x0f
     23c:	a0 89       	ldd	r26, Z+16	; 0x10
     23e:	b1 89       	ldd	r27, Z+17	; 0x11
     240:	01 96       	adiw	r24, 0x01	; 1
     242:	a1 1d       	adc	r26, r1
     244:	b1 1d       	adc	r27, r1
     246:	86 87       	std	Z+14, r24	; 0x0e
     248:	97 87       	std	Z+15, r25	; 0x0f
     24a:	a0 8b       	std	Z+16, r26	; 0x10
     24c:	b1 8b       	std	Z+17, r27	; 0x11
     24e:	4a e0       	ldi	r20, 0x0A	; 10
     250:	50 e0       	ldi	r21, 0x00	; 0
     252:	60 e0       	ldi	r22, 0x00	; 0
     254:	70 e0       	ldi	r23, 0x00	; 0
     256:	ce 01       	movw	r24, r28
     258:	01 96       	adiw	r24, 0x01	; 1
     25a:	0e 94 10 11 	call	0x2220	; 0x2220 <vTaskDelayUntil>
     25e:	e8 cf       	rjmp	.-48     	; 0x230 <_ZN10motor_task3runEv+0x6c>

00000260 <_ZN10motor_taskC1EPKchjP8emstream>:
     260:	0f 93       	push	r16
     262:	1f 93       	push	r17
     264:	cf 93       	push	r28
     266:	df 93       	push	r29
     268:	ec 01       	movw	r28, r24
     26a:	0e 94 47 02 	call	0x48e	; 0x48e <_ZN8frt_taskC1EPKchjP8emstream>
     26e:	87 e3       	ldi	r24, 0x37	; 55
     270:	91 e0       	ldi	r25, 0x01	; 1
     272:	99 83       	std	Y+1, r25	; 0x01
     274:	88 83       	st	Y, r24
     276:	df 91       	pop	r29
     278:	cf 91       	pop	r28
     27a:	1f 91       	pop	r17
     27c:	0f 91       	pop	r16
     27e:	08 95       	ret

00000280 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj>:
 *  @param EN output enable and diagnostics
 *  @param OCR the pwm control register 
 */
	//motor_driver* p_motor_1 = new my_motor_driver (p_serial, &DDRD, &DDRC, &DDRB, &PORTD, &PORTC, PD7, PC3, PC2, PB5, COM1B1, &OCR1B);
//Initialize my_motor_driver
motor_driver::motor_driver (emstream* p_serial_port, volatile uint8_t* DDR_en, volatile uint8_t* DDR_dir, volatile uint8_t* DDR_pwm, volatile uint8_t* PORT_en, volatile uint8_t* PORT_dir, uint8_t ENbit, uint8_t INAbit, uint8_t INBbit, uint8_t PWMbit, uint8_t COMtimer, volatile uint16_t* OCRtimer)
     280:	8f 92       	push	r8
     282:	af 92       	push	r10
     284:	bf 92       	push	r11
     286:	cf 92       	push	r12
     288:	df 92       	push	r13
     28a:	ef 92       	push	r14
     28c:	ff 92       	push	r15
     28e:	0f 93       	push	r16
     290:	1f 93       	push	r17
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	cd b7       	in	r28, 0x3d	; 61
     298:	de b7       	in	r29, 0x3e	; 62
     29a:	fc 01       	movw	r30, r24
{
	ptr_to_serial = p_serial_port;
     29c:	71 83       	std	Z+1, r23	; 0x01
     29e:	60 83       	st	Z, r22
	
	DDR_DIR = DDR_dir;
     2a0:	33 83       	std	Z+3, r19	; 0x03
     2a2:	22 83       	std	Z+2, r18	; 0x02
	DDR_EN = DDR_en;
     2a4:	55 83       	std	Z+5, r21	; 0x05
     2a6:	44 83       	std	Z+4, r20	; 0x04
	DDR_PWM = DDR_pwm;
     2a8:	17 83       	std	Z+7, r17	; 0x07
     2aa:	06 83       	std	Z+6, r16	; 0x06
	
	PORT_EN = PORT_en;
     2ac:	f1 86       	std	Z+9, r15	; 0x09
     2ae:	e0 86       	std	Z+8, r14	; 0x08
	PORT_DIR = PORT_dir;
     2b0:	d3 86       	std	Z+11, r13	; 0x0b
     2b2:	c2 86       	std	Z+10, r12	; 0x0a
	
	COMTIMER = COMtimer;
     2b4:	88 89       	ldd	r24, Y+16	; 0x10
     2b6:	84 87       	std	Z+12, r24	; 0x0c
	
	INA = INAbit; 
     2b8:	85 86       	std	Z+13, r8	; 0x0d
	INB = INBbit; 
     2ba:	8e 85       	ldd	r24, Y+14	; 0x0e
     2bc:	86 87       	std	Z+14, r24	; 0x0e
	EN = ENbit;
     2be:	a7 86       	std	Z+15, r10	; 0x0f
	OCR = OCRtimer;
     2c0:	89 89       	ldd	r24, Y+17	; 0x11
     2c2:	9a 89       	ldd	r25, Y+18	; 0x12
     2c4:	91 8b       	std	Z+17, r25	; 0x11
     2c6:	80 8b       	std	Z+16, r24	; 0x10
	PWM = PWMbit;
     2c8:	8f 85       	ldd	r24, Y+15	; 0x0f
     2ca:	82 8b       	std	Z+18, r24	; 0x12
	
	*DDR_EN |= (1 << EN); // Output enable motors 1 and 2
     2cc:	da 01       	movw	r26, r20
     2ce:	2c 91       	ld	r18, X
     2d0:	81 e0       	ldi	r24, 0x01	; 1
     2d2:	90 e0       	ldi	r25, 0x00	; 0
     2d4:	bc 01       	movw	r22, r24
     2d6:	02 c0       	rjmp	.+4      	; 0x2dc <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x5c>
     2d8:	66 0f       	add	r22, r22
     2da:	77 1f       	adc	r23, r23
     2dc:	aa 94       	dec	r10
     2de:	e2 f7       	brpl	.-8      	; 0x2d8 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x58>
     2e0:	26 2b       	or	r18, r22
     2e2:	2c 93       	st	X, r18
	*DDR_DIR |= (1 << INA) | (1 << INB); // Output enable motors 1 and 2
     2e4:	a2 81       	ldd	r26, Z+2	; 0x02
     2e6:	b3 81       	ldd	r27, Z+3	; 0x03
     2e8:	6c 91       	ld	r22, X
     2ea:	ac 01       	movw	r20, r24
     2ec:	05 84       	ldd	r0, Z+13	; 0x0d
     2ee:	02 c0       	rjmp	.+4      	; 0x2f4 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x74>
     2f0:	44 0f       	add	r20, r20
     2f2:	55 1f       	adc	r21, r21
     2f4:	0a 94       	dec	r0
     2f6:	e2 f7       	brpl	.-8      	; 0x2f0 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x70>
     2f8:	9c 01       	movw	r18, r24
     2fa:	06 84       	ldd	r0, Z+14	; 0x0e
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x82>
     2fe:	22 0f       	add	r18, r18
     300:	33 1f       	adc	r19, r19
     302:	0a 94       	dec	r0
     304:	e2 f7       	brpl	.-8      	; 0x2fe <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x7e>
     306:	24 2b       	or	r18, r20
     308:	26 2b       	or	r18, r22
     30a:	2c 93       	st	X, r18
	*DDR_PWM |= (1 << PWM); // Turn on PWM for motors 1 and 2 as outputs
     30c:	a6 81       	ldd	r26, Z+6	; 0x06
     30e:	b7 81       	ldd	r27, Z+7	; 0x07
     310:	4c 91       	ld	r20, X
     312:	9c 01       	movw	r18, r24
     314:	02 88       	ldd	r0, Z+18	; 0x12
     316:	02 c0       	rjmp	.+4      	; 0x31c <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x9c>
     318:	22 0f       	add	r18, r18
     31a:	33 1f       	adc	r19, r19
     31c:	0a 94       	dec	r0
     31e:	e2 f7       	brpl	.-8      	; 0x318 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x98>
     320:	42 2b       	or	r20, r18
     322:	4c 93       	st	X, r20

	*PORT_EN |= (1 << EN); // Initialize mode for motor
     324:	a0 85       	ldd	r26, Z+8	; 0x08
     326:	b1 85       	ldd	r27, Z+9	; 0x09
     328:	4c 91       	ld	r20, X
     32a:	9c 01       	movw	r18, r24
     32c:	07 84       	ldd	r0, Z+15	; 0x0f
     32e:	02 c0       	rjmp	.+4      	; 0x334 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xb4>
     330:	22 0f       	add	r18, r18
     332:	33 1f       	adc	r19, r19
     334:	0a 94       	dec	r0
     336:	e2 f7       	brpl	.-8      	; 0x330 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xb0>
     338:	42 2b       	or	r20, r18
     33a:	4c 93       	st	X, r20
	*PORT_DIR |= (1 << INA) | (1 << INB);
     33c:	a2 85       	ldd	r26, Z+10	; 0x0a
     33e:	b3 85       	ldd	r27, Z+11	; 0x0b
     340:	6c 91       	ld	r22, X
     342:	ac 01       	movw	r20, r24
     344:	05 84       	ldd	r0, Z+13	; 0x0d
     346:	02 c0       	rjmp	.+4      	; 0x34c <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xcc>
     348:	44 0f       	add	r20, r20
     34a:	55 1f       	adc	r21, r21
     34c:	0a 94       	dec	r0
     34e:	e2 f7       	brpl	.-8      	; 0x348 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xc8>
     350:	9c 01       	movw	r18, r24
     352:	06 84       	ldd	r0, Z+14	; 0x0e
     354:	02 c0       	rjmp	.+4      	; 0x35a <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xda>
     356:	22 0f       	add	r18, r18
     358:	33 1f       	adc	r19, r19
     35a:	0a 94       	dec	r0
     35c:	e2 f7       	brpl	.-8      	; 0x356 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xd6>
     35e:	24 2b       	or	r18, r20
     360:	26 2b       	or	r18, r22
     362:	2c 93       	st	X, r18
	// To set 10-bit fast PWM mode we must set bits WGM30 and WGM32, which are in two
	// different registers (ugh). We use COM3B1 and Com3B0 to set up the PWM so that
	// the pin output will have inverted sense, that is, a 0 is on and a 1 is off; 
	// this is needed because the LED connects from Vcc to the pin. 
	
	TCCR1A |= (1 << WGM10) | (1 << WGM11) | (1 << COMTIMER);
     364:	2f b5       	in	r18, 0x2f	; 47
     366:	23 60       	ori	r18, 0x03	; 3
     368:	04 84       	ldd	r0, Z+12	; 0x0c
     36a:	02 c0       	rjmp	.+4      	; 0x370 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xf0>
     36c:	88 0f       	add	r24, r24
     36e:	99 1f       	adc	r25, r25
     370:	0a 94       	dec	r0
     372:	e2 f7       	brpl	.-8      	; 0x36c <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xec>
     374:	28 2b       	or	r18, r24
     376:	2f bd       	out	0x2f, r18	; 47
	
	// The CS11 bit sets the prescaler for this timer/counter to run the
	// timer at F_CPU / 8
	
	TCCR1B |= (1 << WGM12) | (1 << CS11); // 10-bit PWM and prescale to 8	
     378:	8e b5       	in	r24, 0x2e	; 46
     37a:	8a 60       	ori	r24, 0x0A	; 10
     37c:	8e bd       	out	0x2e, r24	; 46
}
     37e:	df 91       	pop	r29
     380:	cf 91       	pop	r28
     382:	1f 91       	pop	r17
     384:	0f 91       	pop	r16
     386:	ff 90       	pop	r15
     388:	ef 90       	pop	r14
     38a:	df 90       	pop	r13
     38c:	cf 90       	pop	r12
     38e:	bf 90       	pop	r11
     390:	af 90       	pop	r10
     392:	8f 90       	pop	r8
     394:	08 95       	ret

00000396 <_ZN12motor_driver9set_powerEd>:
 *   a pwm signal or duty cycle.
 *  @param  power dictates the value of the PWM
 */

void motor_driver::set_power (double power)
{	
     396:	08 95       	ret

00000398 <_ZN12motor_driver5brakeEv>:
/** \brief This function stops the motor.
 *  \details The brake function sets the mode select bits A & B to the same value.    
 */

void motor_driver::brake (void)
{
     398:	fc 01       	movw	r30, r24
   *PORT_DIR |= (1 << INA) | (1 << INB);
     39a:	a2 85       	ldd	r26, Z+10	; 0x0a
     39c:	b3 85       	ldd	r27, Z+11	; 0x0b
     39e:	6c 91       	ld	r22, X
     3a0:	81 e0       	ldi	r24, 0x01	; 1
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	ac 01       	movw	r20, r24
     3a6:	05 84       	ldd	r0, Z+13	; 0x0d
     3a8:	02 c0       	rjmp	.+4      	; 0x3ae <_ZN12motor_driver5brakeEv+0x16>
     3aa:	44 0f       	add	r20, r20
     3ac:	55 1f       	adc	r21, r21
     3ae:	0a 94       	dec	r0
     3b0:	e2 f7       	brpl	.-8      	; 0x3aa <_ZN12motor_driver5brakeEv+0x12>
     3b2:	9c 01       	movw	r18, r24
     3b4:	06 84       	ldd	r0, Z+14	; 0x0e
     3b6:	02 c0       	rjmp	.+4      	; 0x3bc <_ZN12motor_driver5brakeEv+0x24>
     3b8:	22 0f       	add	r18, r18
     3ba:	33 1f       	adc	r19, r19
     3bc:	0a 94       	dec	r0
     3be:	e2 f7       	brpl	.-8      	; 0x3b8 <_ZN12motor_driver5brakeEv+0x20>
     3c0:	24 2b       	or	r18, r20
     3c2:	26 2b       	or	r18, r22
     3c4:	2c 93       	st	X, r18
   *PORT_EN |= (1 << EN); // Initialize mode for motor
     3c6:	a0 85       	ldd	r26, Z+8	; 0x08
     3c8:	b1 85       	ldd	r27, Z+9	; 0x09
     3ca:	2c 91       	ld	r18, X
     3cc:	07 84       	ldd	r0, Z+15	; 0x0f
     3ce:	02 c0       	rjmp	.+4      	; 0x3d4 <_ZN12motor_driver5brakeEv+0x3c>
     3d0:	88 0f       	add	r24, r24
     3d2:	99 1f       	adc	r25, r25
     3d4:	0a 94       	dec	r0
     3d6:	e2 f7       	brpl	.-8      	; 0x3d0 <_ZN12motor_driver5brakeEv+0x38>
     3d8:	28 2b       	or	r18, r24
     3da:	2c 93       	st	X, r18
     3dc:	08 95       	ret

000003de <_ZN12motor_driver7move_cwEv>:
//-------------------------------------------------------------------------------------
/** \brief This function sets the position of the motor.
 *  \details The brake function sets the mode select bits A & B to the same value.    
 */
void motor_driver::move_cw (void)
{
     3de:	fc 01       	movw	r30, r24
    //*OCR = 10000;
    *PORT_EN |= (1 << EN); // Initialize mode for motor
     3e0:	a0 85       	ldd	r26, Z+8	; 0x08
     3e2:	b1 85       	ldd	r27, Z+9	; 0x09
     3e4:	4c 91       	ld	r20, X
     3e6:	81 e0       	ldi	r24, 0x01	; 1
     3e8:	90 e0       	ldi	r25, 0x00	; 0
     3ea:	9c 01       	movw	r18, r24
     3ec:	07 84       	ldd	r0, Z+15	; 0x0f
     3ee:	02 c0       	rjmp	.+4      	; 0x3f4 <_ZN12motor_driver7move_cwEv+0x16>
     3f0:	22 0f       	add	r18, r18
     3f2:	33 1f       	adc	r19, r19
     3f4:	0a 94       	dec	r0
     3f6:	e2 f7       	brpl	.-8      	; 0x3f0 <_ZN12motor_driver7move_cwEv+0x12>
     3f8:	42 2b       	or	r20, r18
     3fa:	4c 93       	st	X, r20
    if(motor_trans)
     3fc:	23 89       	ldd	r18, Z+19	; 0x13
    {
     *PORT_DIR |= (1 << INA);
     3fe:	a2 85       	ldd	r26, Z+10	; 0x0a
     400:	b3 85       	ldd	r27, Z+11	; 0x0b
     402:	4c 91       	ld	r20, X
 */
void motor_driver::move_cw (void)
{
    //*OCR = 10000;
    *PORT_EN |= (1 << EN); // Initialize mode for motor
    if(motor_trans)
     404:	21 11       	cpse	r18, r1
     406:	18 c0       	rjmp	.+48     	; 0x438 <_ZN12motor_driver7move_cwEv+0x5a>
     *PORT_DIR |= (1 << INA);
     *PORT_DIR &= ~(1 << INB);
     motor_trans = false;
    }
    else{
     *PORT_DIR |= (1 << INB);
     408:	9c 01       	movw	r18, r24
     40a:	06 84       	ldd	r0, Z+14	; 0x0e
     40c:	02 c0       	rjmp	.+4      	; 0x412 <_ZN12motor_driver7move_cwEv+0x34>
     40e:	22 0f       	add	r18, r18
     410:	33 1f       	adc	r19, r19
     412:	0a 94       	dec	r0
     414:	e2 f7       	brpl	.-8      	; 0x40e <_ZN12motor_driver7move_cwEv+0x30>
     416:	42 2b       	or	r20, r18
     418:	4c 93       	st	X, r20
     *PORT_DIR &= ~(1 << INA);
     41a:	a2 85       	ldd	r26, Z+10	; 0x0a
     41c:	b3 85       	ldd	r27, Z+11	; 0x0b
     41e:	2c 91       	ld	r18, X
     420:	05 84       	ldd	r0, Z+13	; 0x0d
     422:	02 c0       	rjmp	.+4      	; 0x428 <_ZN12motor_driver7move_cwEv+0x4a>
     424:	88 0f       	add	r24, r24
     426:	99 1f       	adc	r25, r25
     428:	0a 94       	dec	r0
     42a:	e2 f7       	brpl	.-8      	; 0x424 <_ZN12motor_driver7move_cwEv+0x46>
     42c:	80 95       	com	r24
     42e:	82 23       	and	r24, r18
     430:	8c 93       	st	X, r24
     motor_trans = true;
     432:	81 e0       	ldi	r24, 0x01	; 1
     434:	83 8b       	std	Z+19, r24	; 0x13
     436:	08 95       	ret
{
    //*OCR = 10000;
    *PORT_EN |= (1 << EN); // Initialize mode for motor
    if(motor_trans)
    {
     *PORT_DIR |= (1 << INA);
     438:	9c 01       	movw	r18, r24
     43a:	05 84       	ldd	r0, Z+13	; 0x0d
     43c:	02 c0       	rjmp	.+4      	; 0x442 <_ZN12motor_driver7move_cwEv+0x64>
     43e:	22 0f       	add	r18, r18
     440:	33 1f       	adc	r19, r19
     442:	0a 94       	dec	r0
     444:	e2 f7       	brpl	.-8      	; 0x43e <_ZN12motor_driver7move_cwEv+0x60>
     446:	42 2b       	or	r20, r18
     448:	4c 93       	st	X, r20
     *PORT_DIR &= ~(1 << INB);
     44a:	a2 85       	ldd	r26, Z+10	; 0x0a
     44c:	b3 85       	ldd	r27, Z+11	; 0x0b
     44e:	2c 91       	ld	r18, X
     450:	06 84       	ldd	r0, Z+14	; 0x0e
     452:	02 c0       	rjmp	.+4      	; 0x458 <_ZN12motor_driver7move_cwEv+0x7a>
     454:	88 0f       	add	r24, r24
     456:	99 1f       	adc	r25, r25
     458:	0a 94       	dec	r0
     45a:	e2 f7       	brpl	.-8      	; 0x454 <_ZN12motor_driver7move_cwEv+0x76>
     45c:	80 95       	com	r24
     45e:	82 23       	and	r24, r18
     460:	8c 93       	st	X, r24
     motor_trans = false;
     462:	13 8a       	std	Z+19, r1	; 0x13
     464:	08 95       	ret

00000466 <_ZN12motor_driver2PIEv>:
	position_error.put(encoder_desired.get() - encoder_position.get());
	
}*/

void motor_driver::PI(void)
{
     466:	08 95       	ret

00000468 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
     468:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
     46a:	e8 81       	ld	r30, Y
     46c:	f9 81       	ldd	r31, Y+1	; 0x01
     46e:	01 90       	ld	r0, Z+
     470:	f0 81       	ld	r31, Z
     472:	e0 2d       	mov	r30, r0
     474:	09 95       	icall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
     476:	1b 82       	std	Y+3, r1	; 0x03
     478:	1a 82       	std	Y+2, r1	; 0x02

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
     47a:	6f ef       	ldi	r22, 0xFF	; 255
     47c:	7f ef       	ldi	r23, 0xFF	; 255
     47e:	cb 01       	movw	r24, r22
     480:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vTaskDelay>
     484:	fa cf       	rjmp	.-12     	; 0x47a <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00000486 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
     486:	fc 01       	movw	r30, r24
     488:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
     48a:	65 87       	std	Z+13, r22	; 0x0d
     48c:	08 95       	ret

0000048e <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     48e:	2f 92       	push	r2
     490:	3f 92       	push	r3
     492:	4f 92       	push	r4
     494:	5f 92       	push	r5
     496:	6f 92       	push	r6
     498:	7f 92       	push	r7
     49a:	8f 92       	push	r8
     49c:	9f 92       	push	r9
     49e:	af 92       	push	r10
     4a0:	bf 92       	push	r11
     4a2:	cf 92       	push	r12
     4a4:	df 92       	push	r13
     4a6:	ef 92       	push	r14
     4a8:	ff 92       	push	r15
     4aa:	0f 93       	push	r16
     4ac:	1f 93       	push	r17
     4ae:	cf 93       	push	r28
     4b0:	df 93       	push	r29
     4b2:	cd b7       	in	r28, 0x3d	; 61
     4b4:	de b7       	in	r29, 0x3e	; 62
     4b6:	2a 97       	sbiw	r28, 0x0a	; 10
     4b8:	0f b6       	in	r0, 0x3f	; 63
     4ba:	f8 94       	cli
     4bc:	de bf       	out	0x3e, r29	; 62
     4be:	0f be       	out	0x3f, r0	; 63
     4c0:	cd bf       	out	0x3d, r28	; 61
     4c2:	4c 01       	movw	r8, r24
     4c4:	19 01       	movw	r2, r18
     4c6:	28 01       	movw	r4, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
     4c8:	8f e3       	ldi	r24, 0x3F	; 63
     4ca:	91 e0       	ldi	r25, 0x01	; 1
     4cc:	f4 01       	movw	r30, r8
     4ce:	91 83       	std	Z+1, r25	; 0x01
     4d0:	80 83       	st	Z, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     4d2:	fb 01       	movw	r30, r22
     4d4:	80 81       	ld	r24, Z
     4d6:	88 23       	and	r24, r24
     4d8:	09 f4       	brne	.+2      	; 0x4dc <_ZN8frt_taskC1EPKchjP8emstream+0x4e>
     4da:	a5 c0       	rjmp	.+330    	; 0x626 <_ZN8frt_taskC1EPKchjP8emstream+0x198>
     4dc:	9e 01       	movw	r18, r28
     4de:	2f 5f       	subi	r18, 0xFF	; 255
     4e0:	3f 4f       	sbci	r19, 0xFF	; 255
     4e2:	39 01       	movw	r6, r18
     4e4:	d9 01       	movw	r26, r18
     4e6:	31 96       	adiw	r30, 0x01	; 1
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
     4e8:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
     4ea:	9f 5f       	subi	r25, 0xFF	; 255
     4ec:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     4ee:	81 91       	ld	r24, Z+
     4f0:	88 23       	and	r24, r24
     4f2:	09 f4       	brne	.+2      	; 0x4f6 <_ZN8frt_taskC1EPKchjP8emstream+0x68>
     4f4:	69 c0       	rjmp	.+210    	; 0x5c8 <_ZN8frt_taskC1EPKchjP8emstream+0x13a>
     4f6:	99 30       	cpi	r25, 0x09	; 9
     4f8:	c1 f7       	brne	.-16     	; 0x4ea <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
     4fa:	e9 e0       	ldi	r30, 0x09	; 9
     4fc:	f0 e0       	ldi	r31, 0x00	; 0
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
     4fe:	e6 0d       	add	r30, r6
     500:	f7 1d       	adc	r31, r7
     502:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
     504:	74 01       	movw	r14, r8
     506:	92 e0       	ldi	r25, 0x02	; 2
     508:	e9 0e       	add	r14, r25
     50a:	f1 1c       	adc	r15, r1
     50c:	a1 2c       	mov	r10, r1
     50e:	b1 2c       	mov	r11, r1
     510:	c1 2c       	mov	r12, r1
     512:	d1 2c       	mov	r13, r1
     514:	04 2f       	mov	r16, r20
     516:	94 01       	movw	r18, r8
     518:	a1 01       	movw	r20, r2
     51a:	b3 01       	movw	r22, r6
     51c:	81 e5       	ldi	r24, 0x51	; 81
     51e:	96 e1       	ldi	r25, 0x16	; 22
     520:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
     524:	f4 01       	movw	r30, r8
     526:	57 82       	std	Z+7, r5	; 0x07
     528:	46 82       	std	Z+6, r4	; 0x06
	total_stack = a_stack_size;
     52a:	31 86       	std	Z+9, r3	; 0x09
     52c:	20 86       	std	Z+8, r2	; 0x08

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
     52e:	20 91 92 01 	lds	r18, 0x0192
     532:	30 91 93 01 	lds	r19, 0x0193
     536:	35 83       	std	Z+5, r19	; 0x05
     538:	24 83       	std	Z+4, r18	; 0x04
	last_created_task_pointer = this;
     53a:	90 92 93 01 	sts	0x0193, r9
     53e:	80 92 92 01 	sts	0x0192, r8

	// Initialize the finite state machine and its transition logger
	state = 0;
     542:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
     544:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
     546:	20 90 7c 0c 	lds	r2, 0x0C7C
     54a:	30 90 7d 0c 	lds	r3, 0x0C7D
     54e:	ff ef       	ldi	r31, 0xFF	; 255
     550:	2f 1a       	sub	r2, r31
     552:	3f 0a       	sbc	r3, r31
     554:	30 92 7d 0c 	sts	0x0C7D, r3
     558:	20 92 7c 0c 	sts	0x0C7C, r2
     55c:	f4 01       	movw	r30, r8
     55e:	33 86       	std	Z+11, r3	; 0x0b
     560:	22 86       	std	Z+10, r2	; 0x0a

	// Initialize the run counter
	runs = 0;
     562:	16 86       	std	Z+14, r1	; 0x0e
     564:	17 86       	std	Z+15, r1	; 0x0f
     566:	10 8a       	std	Z+16, r1	; 0x10
     568:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
     56a:	41 14       	cp	r4, r1
     56c:	51 04       	cpc	r5, r1
     56e:	99 f0       	breq	.+38     	; 0x596 <_ZN8frt_taskC1EPKchjP8emstream+0x108>
	{
		if (task_status == pdPASS)
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
     570:	6a e0       	ldi	r22, 0x0A	; 10

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
	{
		if (task_status == pdPASS)
     572:	81 30       	cpi	r24, 0x01	; 1
     574:	61 f1       	breq	.+88     	; 0x5ce <_ZN8frt_taskC1EPKchjP8emstream+0x140>
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
     576:	c2 01       	movw	r24, r4
     578:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     57c:	4c 01       	movw	r8, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     57e:	6b eb       	ldi	r22, 0xBB	; 187
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     586:	b3 01       	movw	r22, r6
     588:	c4 01       	movw	r24, r8
     58a:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     58e:	66 e0       	ldi	r22, 0x06	; 6
     590:	c4 01       	movw	r24, r8
     592:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
     596:	2a 96       	adiw	r28, 0x0a	; 10
     598:	0f b6       	in	r0, 0x3f	; 63
     59a:	f8 94       	cli
     59c:	de bf       	out	0x3e, r29	; 62
     59e:	0f be       	out	0x3f, r0	; 63
     5a0:	cd bf       	out	0x3d, r28	; 61
     5a2:	df 91       	pop	r29
     5a4:	cf 91       	pop	r28
     5a6:	1f 91       	pop	r17
     5a8:	0f 91       	pop	r16
     5aa:	ff 90       	pop	r15
     5ac:	ef 90       	pop	r14
     5ae:	df 90       	pop	r13
     5b0:	cf 90       	pop	r12
     5b2:	bf 90       	pop	r11
     5b4:	af 90       	pop	r10
     5b6:	9f 90       	pop	r9
     5b8:	8f 90       	pop	r8
     5ba:	7f 90       	pop	r7
     5bc:	6f 90       	pop	r6
     5be:	5f 90       	pop	r5
     5c0:	4f 90       	pop	r4
     5c2:	3f 90       	pop	r3
     5c4:	2f 90       	pop	r2
     5c6:	08 95       	ret
     5c8:	e9 2f       	mov	r30, r25
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	98 cf       	rjmp	.-208    	; 0x4fe <_ZN8frt_taskC1EPKchjP8emstream+0x70>
	// successfully
	if (p_serial != NULL)
	{
		if (task_status == pdPASS)
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
     5ce:	c2 01       	movw	r24, r4
     5d0:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     5d4:	7c 01       	movw	r14, r24
     5d6:	60 ed       	ldi	r22, 0xD0	; 208
     5d8:	70 e0       	ldi	r23, 0x00	; 0
     5da:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     5de:	b3 01       	movw	r22, r6
     5e0:	c7 01       	movw	r24, r14
     5e2:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     5e6:	6a e0       	ldi	r22, 0x0A	; 10
     5e8:	c7 01       	movw	r24, r14
     5ea:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     5ee:	7c 01       	movw	r14, r24
     5f0:	66 ed       	ldi	r22, 0xD6	; 214
     5f2:	70 e0       	ldi	r23, 0x00	; 0
     5f4:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
     5f8:	6a e0       	ldi	r22, 0x0A	; 10
     5fa:	c7 01       	movw	r24, r14
     5fc:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     600:	7c 01       	movw	r14, r24
     602:	6f ed       	ldi	r22, 0xDF	; 223
     604:	70 e0       	ldi	r23, 0x00	; 0
     606:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     60a:	63 e0       	ldi	r22, 0x03	; 3
     60c:	c7 01       	movw	r24, r14
     60e:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     612:	b1 01       	movw	r22, r2
     614:	0e 94 71 05 	call	0xae2	; 0xae2 <_ZN8emstreamlsEj>
     618:	62 e0       	ldi	r22, 0x02	; 2
     61a:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     61e:	66 e0       	ldi	r22, 0x06	; 6
     620:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     624:	b8 cf       	rjmp	.-144    	; 0x596 <_ZN8frt_taskC1EPKchjP8emstream+0x108>
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     626:	e0 e0       	ldi	r30, 0x00	; 0
     628:	f0 e0       	ldi	r31, 0x00	; 0
     62a:	ce 01       	movw	r24, r28
     62c:	01 96       	adiw	r24, 0x01	; 1
     62e:	3c 01       	movw	r6, r24
     630:	66 cf       	rjmp	.-308    	; 0x4fe <_ZN8frt_taskC1EPKchjP8emstream+0x70>

00000632 <_ZN8frt_task15emergency_resetEv>:
/** This method prints an error message and resets the processor. It should only be 
 *  used in cases of things going seriously to heck.
 */

void frt_task::emergency_reset (void)
{
     632:	ec 01       	movw	r28, r24
		*  terminated character array belonging to the task. 
		*  @return A pointer to the task's name
		*/
		const char* get_name (void)
		{
			return ((const char*)(pcTaskGetTaskName (handle)));
     634:	8a 81       	ldd	r24, Y+2	; 0x02
     636:	9b 81       	ldd	r25, Y+3	; 0x03
     638:	0e 94 7f 0f 	call	0x1efe	; 0x1efe <pcTaskGetTaskName>
     63c:	8c 01       	movw	r16, r24
	*p_serial << PMS ("ERROR in task ") << get_name () << PMS ("Resetting") << endl;
     63e:	6a e0       	ldi	r22, 0x0A	; 10
     640:	8e 81       	ldd	r24, Y+6	; 0x06
     642:	9f 81       	ldd	r25, Y+7	; 0x07
     644:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     648:	ec 01       	movw	r28, r24
     64a:	62 ea       	ldi	r22, 0xA2	; 162
     64c:	70 e0       	ldi	r23, 0x00	; 0
     64e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     652:	b8 01       	movw	r22, r16
     654:	ce 01       	movw	r24, r28
     656:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     65a:	6a e0       	ldi	r22, 0x0A	; 10
     65c:	ce 01       	movw	r24, r28
     65e:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     662:	ec 01       	movw	r28, r24
     664:	61 eb       	ldi	r22, 0xB1	; 177
     666:	70 e0       	ldi	r23, 0x00	; 0
     668:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     66c:	66 e0       	ldi	r22, 0x06	; 6
     66e:	ce 01       	movw	r24, r28
     670:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
	wdt_enable (WDTO_120MS);
     674:	2b e0       	ldi	r18, 0x0B	; 11
     676:	88 e1       	ldi	r24, 0x18	; 24
     678:	90 e0       	ldi	r25, 0x00	; 0
     67a:	0f b6       	in	r0, 0x3f	; 63
     67c:	f8 94       	cli
     67e:	a8 95       	wdr
     680:	81 bd       	out	0x21, r24	; 33
     682:	0f be       	out	0x3f, r0	; 63
     684:	21 bd       	out	0x21, r18	; 33
     686:	ff cf       	rjmp	.-2      	; 0x686 <_ZN8frt_task15emergency_resetEv+0x54>

00000688 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
     688:	8f 92       	push	r8
     68a:	9f 92       	push	r9
     68c:	af 92       	push	r10
     68e:	bf 92       	push	r11
     690:	cf 92       	push	r12
     692:	df 92       	push	r13
     694:	ef 92       	push	r14
     696:	ff 92       	push	r15
     698:	0f 93       	push	r16
     69a:	1f 93       	push	r17
     69c:	cf 93       	push	r28
     69e:	df 93       	push	r29
     6a0:	ec 01       	movw	r28, r24
     6a2:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
     6a4:	8a 81       	ldd	r24, Y+2	; 0x02
     6a6:	9b 81       	ldd	r25, Y+3	; 0x03
     6a8:	0e 94 7f 0f 	call	0x1efe	; 0x1efe <pcTaskGetTaskName>
     6ac:	bc 01       	movw	r22, r24
     6ae:	c8 01       	movw	r24, r16
     6b0:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
     6b4:	d8 01       	movw	r26, r16
     6b6:	ed 91       	ld	r30, X+
     6b8:	fc 91       	ld	r31, X
     6ba:	02 80       	ldd	r0, Z+2	; 0x02
     6bc:	f3 81       	ldd	r31, Z+3	; 0x03
     6be:	e0 2d       	mov	r30, r0
     6c0:	69 e0       	ldi	r22, 0x09	; 9
     6c2:	c8 01       	movw	r24, r16
     6c4:	09 95       	icall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
     6c6:	8a 81       	ldd	r24, Y+2	; 0x02
     6c8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ca:	0e 94 7f 0f 	call	0x1efe	; 0x1efe <pcTaskGetTaskName>
     6ce:	fc 01       	movw	r30, r24
     6d0:	01 90       	ld	r0, Z+
     6d2:	00 20       	and	r0, r0
     6d4:	e9 f7       	brne	.-6      	; 0x6d0 <_ZN8frt_task12print_statusER8emstream+0x48>
     6d6:	31 97       	sbiw	r30, 0x01	; 1
     6d8:	e8 1b       	sub	r30, r24
     6da:	f9 0b       	sbc	r31, r25
     6dc:	38 97       	sbiw	r30, 0x08	; 8
     6de:	48 f4       	brcc	.+18     	; 0x6f2 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
     6e0:	d8 01       	movw	r26, r16
     6e2:	ed 91       	ld	r30, X+
     6e4:	fc 91       	ld	r31, X
     6e6:	02 80       	ldd	r0, Z+2	; 0x02
     6e8:	f3 81       	ldd	r31, Z+3	; 0x03
     6ea:	e0 2d       	mov	r30, r0
     6ec:	69 e0       	ldi	r22, 0x09	; 9
     6ee:	c8 01       	movw	r24, r16
     6f0:	09 95       	icall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
     6f2:	ce 84       	ldd	r12, Y+14	; 0x0e
     6f4:	df 84       	ldd	r13, Y+15	; 0x0f
     6f6:	e8 88       	ldd	r14, Y+16	; 0x10
     6f8:	f9 88       	ldd	r15, Y+17	; 0x11
 *  declared virtual so that descendents can override it to print additional 
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
     6fa:	a8 84       	ldd	r10, Y+8	; 0x08
     6fc:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
     6fe:	8a 81       	ldd	r24, Y+2	; 0x02
     700:	9b 81       	ldd	r25, Y+3	; 0x03
     702:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <uxTaskGetStackHighWaterMark>
     706:	98 2e       	mov	r9, r24
 *  declared virtual so that descendents can override it to print additional 
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
     708:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
     70a:	8a 81       	ldd	r24, Y+2	; 0x02
     70c:	9b 81       	ldd	r25, Y+3	; 0x03
     70e:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <uxTaskPriorityGet>
     712:	68 2f       	mov	r22, r24
     714:	c8 01       	movw	r24, r16
     716:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN8emstreamlsEh>
     71a:	6a e0       	ldi	r22, 0x0A	; 10
     71c:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     720:	ec 01       	movw	r28, r24
     722:	65 e5       	ldi	r22, 0x55	; 85
     724:	71 e0       	ldi	r23, 0x01	; 1
     726:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
			<< get_state ()
     72a:	68 2d       	mov	r22, r8
     72c:	ce 01       	movw	r24, r28
     72e:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
     732:	6a e0       	ldi	r22, 0x0A	; 10
     734:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     738:	ec 01       	movw	r28, r24
     73a:	67 e5       	ldi	r22, 0x57	; 87
     73c:	71 e0       	ldi	r23, 0x01	; 1
     73e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     742:	69 2d       	mov	r22, r9
     744:	ce 01       	movw	r24, r28
     746:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN8emstreamlsEh>
     74a:	6a e0       	ldi	r22, 0x0A	; 10
     74c:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     750:	ec 01       	movw	r28, r24
     752:	69 e5       	ldi	r22, 0x59	; 89
     754:	71 e0       	ldi	r23, 0x01	; 1
     756:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
     75a:	b5 01       	movw	r22, r10
     75c:	ce 01       	movw	r24, r28
     75e:	0e 94 71 05 	call	0xae2	; 0xae2 <_ZN8emstreamlsEj>
     762:	6a e0       	ldi	r22, 0x0A	; 10
     764:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     768:	ec 01       	movw	r28, r24
     76a:	6b e5       	ldi	r22, 0x5B	; 91
     76c:	71 e0       	ldi	r23, 0x01	; 1
     76e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
     772:	6a e0       	ldi	r22, 0x0A	; 10
     774:	ce 01       	movw	r24, r28
     776:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     77a:	ec 01       	movw	r28, r24
     77c:	6d e5       	ldi	r22, 0x5D	; 93
     77e:	71 e0       	ldi	r23, 0x01	; 1
     780:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     784:	b7 01       	movw	r22, r14
     786:	a6 01       	movw	r20, r12
     788:	ce 01       	movw	r24, r28
}
     78a:	df 91       	pop	r29
     78c:	cf 91       	pop	r28
     78e:	1f 91       	pop	r17
     790:	0f 91       	pop	r16
     792:	ff 90       	pop	r15
     794:	ef 90       	pop	r14
     796:	df 90       	pop	r13
     798:	cf 90       	pop	r12
     79a:	bf 90       	pop	r11
     79c:	af 90       	pop	r10
     79e:	9f 90       	pop	r9
     7a0:	8f 90       	pop	r8
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
     7a2:	0c 94 ab 05 	jmp	0xb56	; 0xb56 <_ZN8emstreamlsEm>

000007a6 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
     7a6:	0f 93       	push	r16
     7a8:	1f 93       	push	r17
     7aa:	cf 93       	push	r28
     7ac:	df 93       	push	r29
     7ae:	ec 01       	movw	r28, r24
     7b0:	8b 01       	movw	r16, r22
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
	a_task.print_status (ser_dev);
     7b2:	e8 81       	ld	r30, Y
     7b4:	f9 81       	ldd	r31, Y+1	; 0x01
     7b6:	02 80       	ldd	r0, Z+2	; 0x02
     7b8:	f3 81       	ldd	r31, Z+3	; 0x03
     7ba:	e0 2d       	mov	r30, r0
     7bc:	b8 01       	movw	r22, r16
     7be:	ce 01       	movw	r24, r28
     7c0:	09 95       	icall
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
	*ser_device << *this << endl;
     7c2:	66 e0       	ldi	r22, 0x06	; 6
     7c4:	c8 01       	movw	r24, r16
     7c6:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
     7ca:	0c 80       	ldd	r0, Y+4	; 0x04
     7cc:	dd 81       	ldd	r29, Y+5	; 0x05
     7ce:	c0 2d       	mov	r28, r0
     7d0:	20 97       	sbiw	r28, 0x00	; 0
     7d2:	79 f7       	brne	.-34     	; 0x7b2 <_ZN8frt_task20print_status_in_listEP8emstream+0xc>
	{
		prev_task_pointer->print_status_in_list (ser_device);
	}
}
     7d4:	df 91       	pop	r29
     7d6:	cf 91       	pop	r28
     7d8:	1f 91       	pop	r17
     7da:	0f 91       	pop	r16
     7dc:	08 95       	ret

000007de <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
     7de:	cf 93       	push	r28
     7e0:	df 93       	push	r29
     7e2:	ec 01       	movw	r28, r24
     7e4:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
     7e6:	db 01       	movw	r26, r22
     7e8:	ed 91       	ld	r30, X+
     7ea:	fc 91       	ld	r31, X
     7ec:	02 80       	ldd	r0, Z+2	; 0x02
     7ee:	f3 81       	ldd	r31, Z+3	; 0x03
     7f0:	e0 2d       	mov	r30, r0
     7f2:	be 01       	movw	r22, r28
     7f4:	09 95       	icall
	return (ser_dev);
}
     7f6:	ce 01       	movw	r24, r28
     7f8:	df 91       	pop	r29
     7fa:	cf 91       	pop	r28
     7fc:	08 95       	ret

000007fe <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
     7fe:	0f 93       	push	r16
     800:	1f 93       	push	r17
     802:	cf 93       	push	r28
     804:	df 93       	push	r29
     806:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
     808:	6a e0       	ldi	r22, 0x0A	; 10
     80a:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     80e:	8c 01       	movw	r16, r24
     810:	63 e4       	ldi	r22, 0x43	; 67
     812:	71 e0       	ldi	r23, 0x01	; 1
     814:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
     818:	6a e0       	ldi	r22, 0x0A	; 10
     81a:	c8 01       	movw	r24, r16
     81c:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     820:	8c 01       	movw	r16, r24
     822:	6e e4       	ldi	r22, 0x4E	; 78
     824:	71 e0       	ldi	r23, 0x01	; 1
     826:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
     82a:	66 e0       	ldi	r22, 0x06	; 6
     82c:	c8 01       	movw	r24, r16
     82e:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
     832:	6a e0       	ldi	r22, 0x0A	; 10
     834:	ce 01       	movw	r24, r28
     836:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     83a:	8c 01       	movw	r16, r24
     83c:	60 e2       	ldi	r22, 0x20	; 32
     83e:	71 e0       	ldi	r23, 0x01	; 1
     840:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
     844:	6a e0       	ldi	r22, 0x0A	; 10
     846:	c8 01       	movw	r24, r16
     848:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     84c:	8c 01       	movw	r16, r24
     84e:	61 e3       	ldi	r22, 0x31	; 49
     850:	71 e0       	ldi	r23, 0x01	; 1
     852:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
     856:	6a e0       	ldi	r22, 0x0A	; 10
     858:	c8 01       	movw	r24, r16
     85a:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     85e:	8c 01       	movw	r16, r24
     860:	6d e3       	ldi	r22, 0x3D	; 61
     862:	71 e0       	ldi	r23, 0x01	; 1
     864:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     868:	66 e0       	ldi	r22, 0x06	; 6
     86a:	c8 01       	movw	r24, r16
     86c:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
     870:	6a e0       	ldi	r22, 0x0A	; 10
     872:	ce 01       	movw	r24, r28
     874:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     878:	8c 01       	movw	r16, r24
     87a:	6d ef       	ldi	r22, 0xFD	; 253
     87c:	70 e0       	ldi	r23, 0x00	; 0
     87e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
     882:	6a e0       	ldi	r22, 0x0A	; 10
     884:	c8 01       	movw	r24, r16
     886:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     88a:	8c 01       	movw	r16, r24
     88c:	6e e0       	ldi	r22, 0x0E	; 14
     88e:	71 e0       	ldi	r23, 0x01	; 1
     890:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
     894:	6a e0       	ldi	r22, 0x0A	; 10
     896:	c8 01       	movw	r24, r16
     898:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     89c:	8c 01       	movw	r16, r24
     89e:	6a e1       	ldi	r22, 0x1A	; 26
     8a0:	71 e0       	ldi	r23, 0x01	; 1
     8a2:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     8a6:	66 e0       	ldi	r22, 0x06	; 6
     8a8:	c8 01       	movw	r24, r16
     8aa:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
     8ae:	80 91 92 01 	lds	r24, 0x0192
     8b2:	90 91 93 01 	lds	r25, 0x0193
     8b6:	00 97       	sbiw	r24, 0x00	; 0
     8b8:	19 f0       	breq	.+6      	; 0x8c0 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
     8ba:	be 01       	movw	r22, r28
     8bc:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
     8c0:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <xTaskGetIdleTaskHandle>
     8c4:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <uxTaskGetStackHighWaterMark>
     8c8:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
     8ca:	6a e0       	ldi	r22, 0x0A	; 10
     8cc:	ce 01       	movw	r24, r28
     8ce:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     8d2:	ec 01       	movw	r28, r24
     8d4:	6d ee       	ldi	r22, 0xED	; 237
     8d6:	70 e0       	ldi	r23, 0x00	; 0
     8d8:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
     8dc:	61 2f       	mov	r22, r17
     8de:	ce 01       	movw	r24, r28
     8e0:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
     8e4:	6a e0       	ldi	r22, 0x0A	; 10
     8e6:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     8ea:	ec 01       	movw	r28, r24
     8ec:	68 ef       	ldi	r22, 0xF8	; 248
     8ee:	70 e0       	ldi	r23, 0x00	; 0
     8f0:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     8f4:	64 e6       	ldi	r22, 0x64	; 100
     8f6:	70 e0       	ldi	r23, 0x00	; 0
     8f8:	ce 01       	movw	r24, r28
     8fa:	0e 94 71 05 	call	0xae2	; 0xae2 <_ZN8emstreamlsEj>
     8fe:	6a e0       	ldi	r22, 0x0A	; 10
     900:	0e 94 2f 05 	call	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>
     904:	ec 01       	movw	r28, r24
     906:	6a ef       	ldi	r22, 0xFA	; 250
     908:	70 e0       	ldi	r23, 0x00	; 0
     90a:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
     90e:	66 e0       	ldi	r22, 0x06	; 6
     910:	ce 01       	movw	r24, r28
}
     912:	df 91       	pop	r29
     914:	cf 91       	pop	r28
     916:	1f 91       	pop	r17
     918:	0f 91       	pop	r16
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
     91a:	0c 94 2f 05 	jmp	0xa5e	; 0xa5e <_ZN8emstreamlsE15ser_manipulator>

0000091e <_ZN14frt_text_queueC1EjP8emstreamm>:
     91e:	9f 92       	push	r9
     920:	af 92       	push	r10
     922:	bf 92       	push	r11
     924:	cf 92       	push	r12
     926:	df 92       	push	r13
     928:	ef 92       	push	r14
     92a:	ff 92       	push	r15
     92c:	0f 93       	push	r16
     92e:	1f 93       	push	r17
     930:	cf 93       	push	r28
     932:	df 93       	push	r29
     934:	ec 01       	movw	r28, r24
     936:	96 2e       	mov	r9, r22
     938:	5a 01       	movw	r10, r20
     93a:	68 01       	movw	r12, r16
     93c:	79 01       	movw	r14, r18
     93e:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <_ZN8emstreamC1Ev>
     942:	27 e4       	ldi	r18, 0x47	; 71
     944:	31 e0       	ldi	r19, 0x01	; 1
     946:	39 83       	std	Y+1, r19	; 0x01
     948:	28 83       	st	Y, r18
     94a:	bf 86       	std	Y+15, r11	; 0x0f
     94c:	ae 86       	std	Y+14, r10	; 0x0e
     94e:	40 e0       	ldi	r20, 0x00	; 0
     950:	61 e0       	ldi	r22, 0x01	; 1
     952:	89 2d       	mov	r24, r9
     954:	0e 94 bb 0a 	call	0x1576	; 0x1576 <xQueueGenericCreate>
     958:	99 87       	std	Y+9, r25	; 0x09
     95a:	88 87       	std	Y+8, r24	; 0x08
     95c:	ca 86       	std	Y+10, r12	; 0x0a
     95e:	db 86       	std	Y+11, r13	; 0x0b
     960:	ec 86       	std	Y+12, r14	; 0x0c
     962:	fd 86       	std	Y+13, r15	; 0x0d
     964:	df 91       	pop	r29
     966:	cf 91       	pop	r28
     968:	1f 91       	pop	r17
     96a:	0f 91       	pop	r16
     96c:	ff 90       	pop	r15
     96e:	ef 90       	pop	r14
     970:	df 90       	pop	r13
     972:	cf 90       	pop	r12
     974:	bf 90       	pop	r11
     976:	af 90       	pop	r10
     978:	9f 90       	pop	r9
     97a:	08 95       	ret

0000097c <_Znwj>:
     97c:	0c 94 04 08 	jmp	0x1008	; 0x1008 <pvPortMalloc>

00000980 <_ZdlPv>:
     980:	00 97       	sbiw	r24, 0x00	; 0
     982:	11 f0       	breq	.+4      	; 0x988 <_ZdlPv+0x8>
     984:	0c 94 2c 08 	jmp	0x1058	; 0x1058 <vPortFree>
     988:	08 95       	ret

0000098a <_Znaj>:
     98a:	0c 94 04 08 	jmp	0x1008	; 0x1008 <pvPortMalloc>

0000098e <_ZdaPv>:
     98e:	00 97       	sbiw	r24, 0x00	; 0
     990:	11 f0       	breq	.+4      	; 0x996 <_ZdaPv+0x8>
     992:	0c 94 2c 08 	jmp	0x1058	; 0x1058 <vPortFree>
     996:	08 95       	ret

00000998 <__cxa_guard_acquire>:
     998:	fc 01       	movw	r30, r24
     99a:	81 e0       	ldi	r24, 0x01	; 1
     99c:	90 e0       	ldi	r25, 0x00	; 0
     99e:	20 81       	ld	r18, Z
     9a0:	22 23       	and	r18, r18
     9a2:	11 f0       	breq	.+4      	; 0x9a8 <__cxa_guard_acquire+0x10>
     9a4:	80 e0       	ldi	r24, 0x00	; 0
     9a6:	90 e0       	ldi	r25, 0x00	; 0
     9a8:	08 95       	ret

000009aa <__cxa_guard_release>:
     9aa:	21 e0       	ldi	r18, 0x01	; 1
     9ac:	fc 01       	movw	r30, r24
     9ae:	20 83       	st	Z, r18
     9b0:	08 95       	ret

000009b2 <__cxa_guard_abort>:
     9b2:	08 95       	ret

000009b4 <__cxa_pure_virtual>:
     9b4:	08 95       	ret

000009b6 <_ZN8emstream13ready_to_sendEv>:
 */

bool emstream::ready_to_send (void)
{
	return (true);                          // By default the port's always ready
}
     9b6:	81 e0       	ldi	r24, 0x01	; 1
     9b8:	08 95       	ret

000009ba <_ZN8emstream7getcharEv>:
 */

int16_t emstream::getchar (void)
{
	return ('\0');                          // Nothing to return, really
}
     9ba:	80 e0       	ldi	r24, 0x00	; 0
     9bc:	90 e0       	ldi	r25, 0x00	; 0
     9be:	08 95       	ret

000009c0 <_ZN8emstream14check_for_charEv>:
 */

bool emstream::check_for_char (void)
{
	return (false);
}
     9c0:	80 e0       	ldi	r24, 0x00	; 0
     9c2:	08 95       	ret

000009c4 <_ZN8emstream12transmit_nowEv>:
 *  classes which have no buffers, send everything immediately by default, and don't 
 *  need to respond to calls for immediate transmission. 
 */

void emstream::transmit_now (void)
{
     9c4:	08 95       	ret

000009c6 <_ZN8emstream12clear_screenEv>:
 *  when the format modifier 'clrscr' is inserted in an output line. Descendant
 *  classes which send things to displays should respond by clearing themselves.
 */

void emstream::clear_screen (void)
{
     9c6:	08 95       	ret

000009c8 <_ZN8emstreamC1Ev>:
//-------------------------------------------------------------------------------------
/** This constructor sets up the base serial port object. It sets the default base for
 *  the conversion of numbers to text and the default format for converting chars. 
 */

emstream::emstream (void)
     9c8:	fc 01       	movw	r30, r24
     9ca:	87 e5       	ldi	r24, 0x57	; 87
     9cc:	91 e0       	ldi	r25, 0x01	; 1
     9ce:	91 83       	std	Z+1, r25	; 0x01
     9d0:	80 83       	st	Z, r24
{
	base = 10;                              // Numbers are shown as decimal by default
     9d2:	8a e0       	ldi	r24, 0x0A	; 10
     9d4:	82 83       	std	Z+2, r24	; 0x02
	print_ascii = false;                    // Print 8-bit chars as numbers by default
     9d6:	13 82       	std	Z+3, r1	; 0x03
	precision = 3;                          // Print 3 digits after a decimal point
     9d8:	83 e0       	ldi	r24, 0x03	; 3
     9da:	85 83       	std	Z+5, r24	; 0x05
	pgm_string = false;                     // Print strings from SRAM by default
     9dc:	14 82       	std	Z+4, r1	; 0x04
	p_hex_receiver = NULL;                  // No hex packet receiver has been set up
     9de:	17 82       	std	Z+7, r1	; 0x07
     9e0:	16 82       	std	Z+6, r1	; 0x06
     9e2:	08 95       	ret

000009e4 <_ZN8emstream4putsEPKc>:
 *  reached.
 *  @param p_string A pointer to the string which is to be printed
 */

void emstream::puts (const char* p_string)
{
     9e4:	0f 93       	push	r16
     9e6:	1f 93       	push	r17
     9e8:	cf 93       	push	r28
     9ea:	df 93       	push	r29
     9ec:	ec 01       	movw	r28, r24
     9ee:	fb 01       	movw	r30, r22
	char ch;                                // Temporary storage for a character

	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
     9f0:	8c 81       	ldd	r24, Y+4	; 0x04
     9f2:	81 11       	cpse	r24, r1
     9f4:	17 c0       	rjmp	.+46     	; 0xa24 <_ZN8emstream4putsEPKc+0x40>
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*p_string)
     9f6:	60 81       	ld	r22, Z
     9f8:	66 23       	and	r22, r22
     9fa:	79 f0       	breq	.+30     	; 0xa1a <_ZN8emstream4putsEPKc+0x36>
     9fc:	8f 01       	movw	r16, r30
     9fe:	0f 5f       	subi	r16, 0xFF	; 255
     a00:	1f 4f       	sbci	r17, 0xFF	; 255
		{
			putchar (*p_string++);
     a02:	e8 81       	ld	r30, Y
     a04:	f9 81       	ldd	r31, Y+1	; 0x01
     a06:	02 80       	ldd	r0, Z+2	; 0x02
     a08:	f3 81       	ldd	r31, Z+3	; 0x03
     a0a:	e0 2d       	mov	r30, r0
     a0c:	ce 01       	movw	r24, r28
     a0e:	09 95       	icall
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*p_string)
     a10:	f8 01       	movw	r30, r16
     a12:	61 91       	ld	r22, Z+
     a14:	8f 01       	movw	r16, r30
     a16:	61 11       	cpse	r22, r1
     a18:	f4 cf       	rjmp	.-24     	; 0xa02 <_ZN8emstream4putsEPKc+0x1e>
		{
			putchar (*p_string++);
		}
	}
}
     a1a:	df 91       	pop	r29
     a1c:	cf 91       	pop	r28
     a1e:	1f 91       	pop	r17
     a20:	0f 91       	pop	r16
     a22:	08 95       	ret

	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
     a24:	1c 82       	std	Y+4, r1	; 0x04
		while ((ch = pgm_read_byte_near (p_string++)))
     a26:	8b 01       	movw	r16, r22
     a28:	0f 5f       	subi	r16, 0xFF	; 255
     a2a:	1f 4f       	sbci	r17, 0xFF	; 255
     a2c:	64 91       	lpm	r22, Z
     a2e:	66 23       	and	r22, r22
     a30:	a1 f3       	breq	.-24     	; 0xa1a <_ZN8emstream4putsEPKc+0x36>
		{
			putchar (ch);
     a32:	a8 81       	ld	r26, Y
     a34:	b9 81       	ldd	r27, Y+1	; 0x01
     a36:	12 96       	adiw	r26, 0x02	; 2
     a38:	ed 91       	ld	r30, X+
     a3a:	fc 91       	ld	r31, X
     a3c:	13 97       	sbiw	r26, 0x03	; 3
     a3e:	ce 01       	movw	r24, r28
     a40:	09 95       	icall
	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
		while ((ch = pgm_read_byte_near (p_string++)))
     a42:	f8 01       	movw	r30, r16
     a44:	64 91       	lpm	r22, Z
     a46:	0f 5f       	subi	r16, 0xFF	; 255
     a48:	1f 4f       	sbci	r17, 0xFF	; 255
     a4a:	61 11       	cpse	r22, r1
     a4c:	f2 cf       	rjmp	.-28     	; 0xa32 <_ZN8emstream4putsEPKc+0x4e>
     a4e:	e5 cf       	rjmp	.-54     	; 0xa1a <_ZN8emstream4putsEPKc+0x36>

00000a50 <_Z12setprecisionh>:
 *		a maximum of 7 digits are allowed
 *  @return The serial manipulator called "manip_set_precision"
 */

ser_manipulator setprecision (uint8_t digits)
{
     a50:	88 30       	cpi	r24, 0x08	; 8
     a52:	08 f0       	brcs	.+2      	; 0xa56 <_Z12setprecisionh+0x6>
     a54:	87 e0       	ldi	r24, 0x07	; 7
	if (digits > 7)
	{
		digits = 7;
	}
	bts_glob_prec = digits;
     a56:	80 93 00 01 	sts	0x0100, r24

	return (manip_set_precision);
}
     a5a:	89 e0       	ldi	r24, 0x09	; 9
     a5c:	08 95       	ret

00000a5e <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
     a5e:	cf 93       	push	r28
     a60:	df 93       	push	r29
     a62:	ec 01       	movw	r28, r24
	switch (new_manip)
     a64:	46 2f       	mov	r20, r22
     a66:	50 e0       	ldi	r21, 0x00	; 0
     a68:	4b 30       	cpi	r20, 0x0B	; 11
     a6a:	51 05       	cpc	r21, r1
     a6c:	38 f4       	brcc	.+14     	; 0xa7c <_ZN8emstreamlsE15ser_manipulator+0x1e>
     a6e:	fa 01       	movw	r30, r20
     a70:	ea 5b       	subi	r30, 0xBA	; 186
     a72:	ff 4f       	sbci	r31, 0xFF	; 255
     a74:	0c 94 be 16 	jmp	0x2d7c	; 0x2d7c <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
     a78:	82 e0       	ldi	r24, 0x02	; 2
     a7a:	8a 83       	std	Y+2, r24	; 0x02
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
     a7c:	ce 01       	movw	r24, r28
     a7e:	df 91       	pop	r29
     a80:	cf 91       	pop	r28
     a82:	08 95       	ret
			break;
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
			break;
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	8c 83       	std	Y+4, r24	; 0x04
			break;
     a88:	f9 cf       	rjmp	.-14     	; 0xa7c <_ZN8emstreamlsE15ser_manipulator+0x1e>
	{
		case (bin):                         // Print integers in binary
			base = 2;
			break;
		case (oct):                         // Print integers in octal
			base = 8;
     a8a:	88 e0       	ldi	r24, 0x08	; 8
     a8c:	8a 83       	std	Y+2, r24	; 0x02
			break;
     a8e:	f6 cf       	rjmp	.-20     	; 0xa7c <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (dec):                         // Print integers in decimal
			base = 10;
     a90:	8a e0       	ldi	r24, 0x0A	; 10
     a92:	8a 83       	std	Y+2, r24	; 0x02
			break;
     a94:	f3 cf       	rjmp	.-26     	; 0xa7c <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
     a96:	80 e1       	ldi	r24, 0x10	; 16
     a98:	8a 83       	std	Y+2, r24	; 0x02
			break;
     a9a:	f0 cf       	rjmp	.-32     	; 0xa7c <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
     a9c:	81 e0       	ldi	r24, 0x01	; 1
     a9e:	8b 83       	std	Y+3, r24	; 0x03
			break;
     aa0:	ed cf       	rjmp	.-38     	; 0xa7c <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
     aa2:	1b 82       	std	Y+3, r1	; 0x03
			break;
     aa4:	eb cf       	rjmp	.-42     	; 0xa7c <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
     aa6:	e8 81       	ld	r30, Y
     aa8:	f9 81       	ldd	r31, Y+1	; 0x01
     aaa:	02 80       	ldd	r0, Z+2	; 0x02
     aac:	f3 81       	ldd	r31, Z+3	; 0x03
     aae:	e0 2d       	mov	r30, r0
     ab0:	6d e0       	ldi	r22, 0x0D	; 13
     ab2:	09 95       	icall
     ab4:	e8 81       	ld	r30, Y
     ab6:	f9 81       	ldd	r31, Y+1	; 0x01
     ab8:	02 80       	ldd	r0, Z+2	; 0x02
     aba:	f3 81       	ldd	r31, Z+3	; 0x03
     abc:	e0 2d       	mov	r30, r0
     abe:	6a e0       	ldi	r22, 0x0A	; 10
     ac0:	ce 01       	movw	r24, r28
     ac2:	09 95       	icall
			break;
     ac4:	db cf       	rjmp	.-74     	; 0xa7c <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
     ac6:	e8 81       	ld	r30, Y
     ac8:	f9 81       	ldd	r31, Y+1	; 0x01
     aca:	02 84       	ldd	r0, Z+10	; 0x0a
     acc:	f3 85       	ldd	r31, Z+11	; 0x0b
     ace:	e0 2d       	mov	r30, r0
     ad0:	09 95       	icall
			break;
     ad2:	d4 cf       	rjmp	.-88     	; 0xa7c <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
     ad4:	e8 81       	ld	r30, Y
     ad6:	f9 81       	ldd	r31, Y+1	; 0x01
     ad8:	00 84       	ldd	r0, Z+8	; 0x08
     ada:	f1 85       	ldd	r31, Z+9	; 0x09
     adc:	e0 2d       	mov	r30, r0
     ade:	09 95       	icall
			break;
     ae0:	cd cf       	rjmp	.-102    	; 0xa7c <_ZN8emstreamlsE15ser_manipulator+0x1e>

00000ae2 <_ZN8emstreamlsEj>:
     ae2:	ff 92       	push	r15
     ae4:	0f 93       	push	r16
     ae6:	1f 93       	push	r17
     ae8:	cf 93       	push	r28
     aea:	df 93       	push	r29
     aec:	cd b7       	in	r28, 0x3d	; 61
     aee:	de b7       	in	r29, 0x3e	; 62
     af0:	61 97       	sbiw	r28, 0x11	; 17
     af2:	0f b6       	in	r0, 0x3f	; 63
     af4:	f8 94       	cli
     af6:	de bf       	out	0x3e, r29	; 62
     af8:	0f be       	out	0x3f, r0	; 63
     afa:	cd bf       	out	0x3d, r28	; 61
     afc:	8c 01       	movw	r16, r24
     afe:	f6 2e       	mov	r15, r22
     b00:	97 2f       	mov	r25, r23
     b02:	f8 01       	movw	r30, r16
     b04:	42 81       	ldd	r20, Z+2	; 0x02
     b06:	40 31       	cpi	r20, 0x10	; 16
     b08:	91 f0       	breq	.+36     	; 0xb2e <_ZN8emstreamlsEj+0x4c>
     b0a:	48 30       	cpi	r20, 0x08	; 8
     b0c:	81 f0       	breq	.+32     	; 0xb2e <_ZN8emstreamlsEj+0x4c>
     b0e:	42 30       	cpi	r20, 0x02	; 2
     b10:	71 f0       	breq	.+28     	; 0xb2e <_ZN8emstreamlsEj+0x4c>
     b12:	50 e0       	ldi	r21, 0x00	; 0
     b14:	be 01       	movw	r22, r28
     b16:	6f 5f       	subi	r22, 0xFF	; 255
     b18:	7f 4f       	sbci	r23, 0xFF	; 255
     b1a:	8f 2d       	mov	r24, r15
     b1c:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <utoa>
     b20:	be 01       	movw	r22, r28
     b22:	6f 5f       	subi	r22, 0xFF	; 255
     b24:	7f 4f       	sbci	r23, 0xFF	; 255
     b26:	c8 01       	movw	r24, r16
     b28:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     b2c:	07 c0       	rjmp	.+14     	; 0xb3c <_ZN8emstreamlsEj+0x5a>
     b2e:	69 2f       	mov	r22, r25
     b30:	c8 01       	movw	r24, r16
     b32:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN8emstreamlsEh>
     b36:	6f 2d       	mov	r22, r15
     b38:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN8emstreamlsEh>
     b3c:	c8 01       	movw	r24, r16
     b3e:	61 96       	adiw	r28, 0x11	; 17
     b40:	0f b6       	in	r0, 0x3f	; 63
     b42:	f8 94       	cli
     b44:	de bf       	out	0x3e, r29	; 62
     b46:	0f be       	out	0x3f, r0	; 63
     b48:	cd bf       	out	0x3d, r28	; 61
     b4a:	df 91       	pop	r29
     b4c:	cf 91       	pop	r28
     b4e:	1f 91       	pop	r17
     b50:	0f 91       	pop	r16
     b52:	ff 90       	pop	r15
     b54:	08 95       	ret

00000b56 <_ZN8emstreamlsEm>:
     b56:	df 92       	push	r13
     b58:	ef 92       	push	r14
     b5a:	ff 92       	push	r15
     b5c:	0f 93       	push	r16
     b5e:	1f 93       	push	r17
     b60:	cf 93       	push	r28
     b62:	df 93       	push	r29
     b64:	cd b7       	in	r28, 0x3d	; 61
     b66:	de b7       	in	r29, 0x3e	; 62
     b68:	a1 97       	sbiw	r28, 0x21	; 33
     b6a:	0f b6       	in	r0, 0x3f	; 63
     b6c:	f8 94       	cli
     b6e:	de bf       	out	0x3e, r29	; 62
     b70:	0f be       	out	0x3f, r0	; 63
     b72:	cd bf       	out	0x3d, r28	; 61
     b74:	8c 01       	movw	r16, r24
     b76:	d4 2e       	mov	r13, r20
     b78:	e5 2e       	mov	r14, r21
     b7a:	f6 2e       	mov	r15, r22
     b7c:	97 2f       	mov	r25, r23
     b7e:	f8 01       	movw	r30, r16
     b80:	22 81       	ldd	r18, Z+2	; 0x02
     b82:	20 31       	cpi	r18, 0x10	; 16
     b84:	a1 f0       	breq	.+40     	; 0xbae <_ZN8emstreamlsEm+0x58>
     b86:	28 30       	cpi	r18, 0x08	; 8
     b88:	91 f0       	breq	.+36     	; 0xbae <_ZN8emstreamlsEm+0x58>
     b8a:	22 30       	cpi	r18, 0x02	; 2
     b8c:	81 f0       	breq	.+32     	; 0xbae <_ZN8emstreamlsEm+0x58>
     b8e:	30 e0       	ldi	r19, 0x00	; 0
     b90:	ae 01       	movw	r20, r28
     b92:	4f 5f       	subi	r20, 0xFF	; 255
     b94:	5f 4f       	sbci	r21, 0xFF	; 255
     b96:	6d 2d       	mov	r22, r13
     b98:	7e 2d       	mov	r23, r14
     b9a:	8f 2d       	mov	r24, r15
     b9c:	0e 94 e7 16 	call	0x2dce	; 0x2dce <ultoa>
     ba0:	be 01       	movw	r22, r28
     ba2:	6f 5f       	subi	r22, 0xFF	; 255
     ba4:	7f 4f       	sbci	r23, 0xFF	; 255
     ba6:	c8 01       	movw	r24, r16
     ba8:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     bac:	0d c0       	rjmp	.+26     	; 0xbc8 <_ZN8emstreamlsEm+0x72>
     bae:	69 2f       	mov	r22, r25
     bb0:	c8 01       	movw	r24, r16
     bb2:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN8emstreamlsEh>
     bb6:	6f 2d       	mov	r22, r15
     bb8:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN8emstreamlsEh>
     bbc:	6e 2d       	mov	r22, r14
     bbe:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN8emstreamlsEh>
     bc2:	6d 2d       	mov	r22, r13
     bc4:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN8emstreamlsEh>
     bc8:	c8 01       	movw	r24, r16
     bca:	a1 96       	adiw	r28, 0x21	; 33
     bcc:	0f b6       	in	r0, 0x3f	; 63
     bce:	f8 94       	cli
     bd0:	de bf       	out	0x3e, r29	; 62
     bd2:	0f be       	out	0x3f, r0	; 63
     bd4:	cd bf       	out	0x3d, r28	; 61
     bd6:	df 91       	pop	r29
     bd8:	cf 91       	pop	r28
     bda:	1f 91       	pop	r17
     bdc:	0f 91       	pop	r16
     bde:	ff 90       	pop	r15
     be0:	ef 90       	pop	r14
     be2:	df 90       	pop	r13
     be4:	08 95       	ret

00000be6 <_ZN8emstreamlsEh>:
     be6:	cf 92       	push	r12
     be8:	df 92       	push	r13
     bea:	ef 92       	push	r14
     bec:	ff 92       	push	r15
     bee:	0f 93       	push	r16
     bf0:	1f 93       	push	r17
     bf2:	cf 93       	push	r28
     bf4:	df 93       	push	r29
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	29 97       	sbiw	r28, 0x09	; 9
     bfc:	0f b6       	in	r0, 0x3f	; 63
     bfe:	f8 94       	cli
     c00:	de bf       	out	0x3e, r29	; 62
     c02:	0f be       	out	0x3f, r0	; 63
     c04:	cd bf       	out	0x3d, r28	; 61
     c06:	8c 01       	movw	r16, r24
     c08:	d6 2e       	mov	r13, r22
     c0a:	dc 01       	movw	r26, r24
     c0c:	13 96       	adiw	r26, 0x03	; 3
     c0e:	8c 91       	ld	r24, X
     c10:	13 97       	sbiw	r26, 0x03	; 3
     c12:	81 11       	cpse	r24, r1
     c14:	5d c0       	rjmp	.+186    	; 0xcd0 <_ZN8emstreamlsEh+0xea>
     c16:	f8 01       	movw	r30, r16
     c18:	42 81       	ldd	r20, Z+2	; 0x02
     c1a:	42 30       	cpi	r20, 0x02	; 2
     c1c:	d9 f1       	breq	.+118    	; 0xc94 <_ZN8emstreamlsEh+0xae>
     c1e:	40 31       	cpi	r20, 0x10	; 16
     c20:	f1 f0       	breq	.+60     	; 0xc5e <_ZN8emstreamlsEh+0x78>
     c22:	50 e0       	ldi	r21, 0x00	; 0
     c24:	be 01       	movw	r22, r28
     c26:	6f 5f       	subi	r22, 0xFF	; 255
     c28:	7f 4f       	sbci	r23, 0xFF	; 255
     c2a:	8d 2d       	mov	r24, r13
     c2c:	90 e0       	ldi	r25, 0x00	; 0
     c2e:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <utoa>
     c32:	be 01       	movw	r22, r28
     c34:	6f 5f       	subi	r22, 0xFF	; 255
     c36:	7f 4f       	sbci	r23, 0xFF	; 255
     c38:	c8 01       	movw	r24, r16
     c3a:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstream4putsEPKc>
     c3e:	c8 01       	movw	r24, r16
     c40:	29 96       	adiw	r28, 0x09	; 9
     c42:	0f b6       	in	r0, 0x3f	; 63
     c44:	f8 94       	cli
     c46:	de bf       	out	0x3e, r29	; 62
     c48:	0f be       	out	0x3f, r0	; 63
     c4a:	cd bf       	out	0x3d, r28	; 61
     c4c:	df 91       	pop	r29
     c4e:	cf 91       	pop	r28
     c50:	1f 91       	pop	r17
     c52:	0f 91       	pop	r16
     c54:	ff 90       	pop	r15
     c56:	ef 90       	pop	r14
     c58:	df 90       	pop	r13
     c5a:	cf 90       	pop	r12
     c5c:	08 95       	ret
     c5e:	62 95       	swap	r22
     c60:	6f 70       	andi	r22, 0x0F	; 15
     c62:	01 90       	ld	r0, Z+
     c64:	f0 81       	ld	r31, Z
     c66:	e0 2d       	mov	r30, r0
     c68:	02 80       	ldd	r0, Z+2	; 0x02
     c6a:	f3 81       	ldd	r31, Z+3	; 0x03
     c6c:	e0 2d       	mov	r30, r0
     c6e:	6a 30       	cpi	r22, 0x0A	; 10
     c70:	b8 f5       	brcc	.+110    	; 0xce0 <_ZN8emstreamlsEh+0xfa>
     c72:	60 5d       	subi	r22, 0xD0	; 208
     c74:	c8 01       	movw	r24, r16
     c76:	09 95       	icall
     c78:	6d 2d       	mov	r22, r13
     c7a:	6f 70       	andi	r22, 0x0F	; 15
     c7c:	d8 01       	movw	r26, r16
     c7e:	ed 91       	ld	r30, X+
     c80:	fc 91       	ld	r31, X
     c82:	02 80       	ldd	r0, Z+2	; 0x02
     c84:	f3 81       	ldd	r31, Z+3	; 0x03
     c86:	e0 2d       	mov	r30, r0
     c88:	6a 30       	cpi	r22, 0x0A	; 10
     c8a:	60 f1       	brcs	.+88     	; 0xce4 <_ZN8emstreamlsEh+0xfe>
     c8c:	69 5c       	subi	r22, 0xC9	; 201
     c8e:	c8 01       	movw	r24, r16
     c90:	09 95       	icall
     c92:	d5 cf       	rjmp	.-86     	; 0xc3e <_ZN8emstreamlsEh+0x58>
     c94:	88 e0       	ldi	r24, 0x08	; 8
     c96:	e8 2e       	mov	r14, r24
     c98:	f1 2c       	mov	r15, r1
     c9a:	90 e8       	ldi	r25, 0x80	; 128
     c9c:	c9 2e       	mov	r12, r25
     c9e:	0a c0       	rjmp	.+20     	; 0xcb4 <_ZN8emstreamlsEh+0xce>
     ca0:	61 e3       	ldi	r22, 0x31	; 49
     ca2:	c8 01       	movw	r24, r16
     ca4:	09 95       	icall
     ca6:	c6 94       	lsr	r12
     ca8:	b1 e0       	ldi	r27, 0x01	; 1
     caa:	eb 1a       	sub	r14, r27
     cac:	f1 08       	sbc	r15, r1
     cae:	e1 14       	cp	r14, r1
     cb0:	f1 04       	cpc	r15, r1
     cb2:	29 f2       	breq	.-118    	; 0xc3e <_ZN8emstreamlsEh+0x58>
     cb4:	8c 2d       	mov	r24, r12
     cb6:	8d 21       	and	r24, r13
     cb8:	d8 01       	movw	r26, r16
     cba:	ed 91       	ld	r30, X+
     cbc:	fc 91       	ld	r31, X
     cbe:	02 80       	ldd	r0, Z+2	; 0x02
     cc0:	f3 81       	ldd	r31, Z+3	; 0x03
     cc2:	e0 2d       	mov	r30, r0
     cc4:	81 11       	cpse	r24, r1
     cc6:	ec cf       	rjmp	.-40     	; 0xca0 <_ZN8emstreamlsEh+0xba>
     cc8:	60 e3       	ldi	r22, 0x30	; 48
     cca:	c8 01       	movw	r24, r16
     ccc:	09 95       	icall
     cce:	eb cf       	rjmp	.-42     	; 0xca6 <_ZN8emstreamlsEh+0xc0>
     cd0:	ed 91       	ld	r30, X+
     cd2:	fc 91       	ld	r31, X
     cd4:	02 80       	ldd	r0, Z+2	; 0x02
     cd6:	f3 81       	ldd	r31, Z+3	; 0x03
     cd8:	e0 2d       	mov	r30, r0
     cda:	c8 01       	movw	r24, r16
     cdc:	09 95       	icall
     cde:	af cf       	rjmp	.-162    	; 0xc3e <_ZN8emstreamlsEh+0x58>
     ce0:	69 5c       	subi	r22, 0xC9	; 201
     ce2:	c8 cf       	rjmp	.-112    	; 0xc74 <_ZN8emstreamlsEh+0x8e>
     ce4:	60 5d       	subi	r22, 0xD0	; 208
     ce6:	d3 cf       	rjmp	.-90     	; 0xc8e <_ZN8emstreamlsEh+0xa8>

00000ce8 <_ZN5rs2327putcharEc>:
     ce8:	dc 01       	movw	r26, r24
     cea:	1a 96       	adiw	r26, 0x0a	; 10
     cec:	ed 91       	ld	r30, X+
     cee:	fc 91       	ld	r31, X
     cf0:	1b 97       	sbiw	r26, 0x0b	; 11
     cf2:	80 81       	ld	r24, Z
     cf4:	1e 96       	adiw	r26, 0x0e	; 14
     cf6:	9c 91       	ld	r25, X
     cf8:	1e 97       	sbiw	r26, 0x0e	; 14
     cfa:	89 23       	and	r24, r25
     cfc:	59 f4       	brne	.+22     	; 0xd14 <_ZN5rs2327putcharEc+0x2c>
     cfe:	21 e2       	ldi	r18, 0x21	; 33
     d00:	3e e4       	ldi	r19, 0x4E	; 78
     d02:	05 c0       	rjmp	.+10     	; 0xd0e <_ZN5rs2327putcharEc+0x26>
     d04:	21 50       	subi	r18, 0x01	; 1
     d06:	31 09       	sbc	r19, r1
     d08:	21 15       	cp	r18, r1
     d0a:	31 05       	cpc	r19, r1
     d0c:	81 f0       	breq	.+32     	; 0xd2e <_ZN5rs2327putcharEc+0x46>
     d0e:	80 81       	ld	r24, Z
     d10:	89 23       	and	r24, r25
     d12:	c1 f3       	breq	.-16     	; 0xd04 <_ZN5rs2327putcharEc+0x1c>
     d14:	80 81       	ld	r24, Z
     d16:	50 96       	adiw	r26, 0x10	; 16
     d18:	9c 91       	ld	r25, X
     d1a:	50 97       	sbiw	r26, 0x10	; 16
     d1c:	89 2b       	or	r24, r25
     d1e:	80 83       	st	Z, r24
     d20:	18 96       	adiw	r26, 0x08	; 8
     d22:	ed 91       	ld	r30, X+
     d24:	fc 91       	ld	r31, X
     d26:	19 97       	sbiw	r26, 0x09	; 9
     d28:	60 83       	st	Z, r22
     d2a:	81 e0       	ldi	r24, 0x01	; 1
     d2c:	08 95       	ret
     d2e:	80 e0       	ldi	r24, 0x00	; 0
     d30:	08 95       	ret

00000d32 <_ZN5rs2327getcharEv>:
     d32:	fc 01       	movw	r30, r24
     d34:	81 89       	ldd	r24, Z+17	; 0x11
     d36:	81 11       	cpse	r24, r1
     d38:	1e c0       	rjmp	.+60     	; 0xd76 <_ZN5rs2327getcharEv+0x44>
     d3a:	20 91 9c 01 	lds	r18, 0x019C
     d3e:	30 91 9d 01 	lds	r19, 0x019D
     d42:	80 91 9a 01 	lds	r24, 0x019A
     d46:	90 91 9b 01 	lds	r25, 0x019B
     d4a:	28 17       	cp	r18, r24
     d4c:	39 07       	cpc	r19, r25
     d4e:	91 f0       	breq	.+36     	; 0xd74 <_ZN5rs2327getcharEv+0x42>
     d50:	e0 91 9e 01 	lds	r30, 0x019E
     d54:	f0 91 9f 01 	lds	r31, 0x019F
     d58:	e2 0f       	add	r30, r18
     d5a:	f3 1f       	adc	r31, r19
     d5c:	80 81       	ld	r24, Z
     d5e:	2f 5f       	subi	r18, 0xFF	; 255
     d60:	3f 4f       	sbci	r19, 0xFF	; 255
     d62:	20 32       	cpi	r18, 0x20	; 32
     d64:	31 05       	cpc	r19, r1
     d66:	28 f1       	brcs	.+74     	; 0xdb2 <_ZN5rs2327getcharEv+0x80>
     d68:	10 92 9d 01 	sts	0x019D, r1
     d6c:	10 92 9c 01 	sts	0x019C, r1
     d70:	90 e0       	ldi	r25, 0x00	; 0
     d72:	08 95       	ret
     d74:	ff cf       	rjmp	.-2      	; 0xd74 <_ZN5rs2327getcharEv+0x42>
     d76:	20 91 96 01 	lds	r18, 0x0196
     d7a:	30 91 97 01 	lds	r19, 0x0197
     d7e:	80 91 94 01 	lds	r24, 0x0194
     d82:	90 91 95 01 	lds	r25, 0x0195
     d86:	28 17       	cp	r18, r24
     d88:	39 07       	cpc	r19, r25
     d8a:	91 f0       	breq	.+36     	; 0xdb0 <_ZN5rs2327getcharEv+0x7e>
     d8c:	e0 91 98 01 	lds	r30, 0x0198
     d90:	f0 91 99 01 	lds	r31, 0x0199
     d94:	e2 0f       	add	r30, r18
     d96:	f3 1f       	adc	r31, r19
     d98:	80 81       	ld	r24, Z
     d9a:	2f 5f       	subi	r18, 0xFF	; 255
     d9c:	3f 4f       	sbci	r19, 0xFF	; 255
     d9e:	20 32       	cpi	r18, 0x20	; 32
     da0:	31 05       	cpc	r19, r1
     da2:	68 f0       	brcs	.+26     	; 0xdbe <_ZN5rs2327getcharEv+0x8c>
     da4:	10 92 97 01 	sts	0x0197, r1
     da8:	10 92 96 01 	sts	0x0196, r1
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	08 95       	ret
     db0:	ff cf       	rjmp	.-2      	; 0xdb0 <_ZN5rs2327getcharEv+0x7e>
     db2:	30 93 9d 01 	sts	0x019D, r19
     db6:	20 93 9c 01 	sts	0x019C, r18
     dba:	90 e0       	ldi	r25, 0x00	; 0
     dbc:	08 95       	ret
     dbe:	30 93 97 01 	sts	0x0197, r19
     dc2:	20 93 96 01 	sts	0x0196, r18
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	08 95       	ret

00000dca <_ZN5rs23212clear_screenEv>:
     dca:	dc 01       	movw	r26, r24
     dcc:	ed 91       	ld	r30, X+
     dce:	fc 91       	ld	r31, X
     dd0:	02 80       	ldd	r0, Z+2	; 0x02
     dd2:	f3 81       	ldd	r31, Z+3	; 0x03
     dd4:	e0 2d       	mov	r30, r0
     dd6:	6c e0       	ldi	r22, 0x0C	; 12
     dd8:	09 94       	ijmp

00000dda <_ZN5rs23214check_for_charEv>:
     dda:	fc 01       	movw	r30, r24
     ddc:	81 89       	ldd	r24, Z+17	; 0x11
     dde:	88 23       	and	r24, r24
     de0:	69 f0       	breq	.+26     	; 0xdfc <_ZN5rs23214check_for_charEv+0x22>
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	40 91 96 01 	lds	r20, 0x0196
     de8:	50 91 97 01 	lds	r21, 0x0197
     dec:	20 91 94 01 	lds	r18, 0x0194
     df0:	30 91 95 01 	lds	r19, 0x0195
     df4:	42 17       	cp	r20, r18
     df6:	53 07       	cpc	r21, r19
     df8:	69 f0       	breq	.+26     	; 0xe14 <_ZN5rs23214check_for_charEv+0x3a>
     dfa:	08 95       	ret
     dfc:	81 e0       	ldi	r24, 0x01	; 1
     dfe:	40 91 9c 01 	lds	r20, 0x019C
     e02:	50 91 9d 01 	lds	r21, 0x019D
     e06:	20 91 9a 01 	lds	r18, 0x019A
     e0a:	30 91 9b 01 	lds	r19, 0x019B
     e0e:	42 17       	cp	r20, r18
     e10:	53 07       	cpc	r21, r19
     e12:	99 f7       	brne	.-26     	; 0xdfa <_ZN5rs23214check_for_charEv+0x20>
     e14:	80 e0       	ldi	r24, 0x00	; 0
     e16:	08 95       	ret

00000e18 <_ZN5rs232C1Ejh>:
     e18:	ef 92       	push	r14
     e1a:	ff 92       	push	r15
     e1c:	1f 93       	push	r17
     e1e:	cf 93       	push	r28
     e20:	df 93       	push	r29
     e22:	00 d0       	rcall	.+0      	; 0xe24 <_ZN5rs232C1Ejh+0xc>
     e24:	cd b7       	in	r28, 0x3d	; 61
     e26:	de b7       	in	r29, 0x3e	; 62
     e28:	7c 01       	movw	r14, r24
     e2a:	14 2f       	mov	r17, r20
     e2c:	69 83       	std	Y+1, r22	; 0x01
     e2e:	7a 83       	std	Y+2, r23	; 0x02
     e30:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <_ZN8emstreamC1Ev>
     e34:	41 2f       	mov	r20, r17
     e36:	69 81       	ldd	r22, Y+1	; 0x01
     e38:	7a 81       	ldd	r23, Y+2	; 0x02
     e3a:	c7 01       	movw	r24, r14
     e3c:	08 96       	adiw	r24, 0x08	; 8
     e3e:	0e 94 90 13 	call	0x2720	; 0x2720 <_ZN7base232C1Ejh>
     e42:	87 e6       	ldi	r24, 0x67	; 103
     e44:	91 e0       	ldi	r25, 0x01	; 1
     e46:	f7 01       	movw	r30, r14
     e48:	91 83       	std	Z+1, r25	; 0x01
     e4a:	80 83       	st	Z, r24
     e4c:	11 8b       	std	Z+17, r17	; 0x11
     e4e:	11 23       	and	r17, r17
     e50:	e9 f0       	breq	.+58     	; 0xe8c <_ZN5rs232C1Ejh+0x74>
     e52:	80 91 9a 00 	lds	r24, 0x009A
     e56:	80 68       	ori	r24, 0x80	; 128
     e58:	80 93 9a 00 	sts	0x009A, r24
     e5c:	80 e2       	ldi	r24, 0x20	; 32
     e5e:	90 e0       	ldi	r25, 0x00	; 0
     e60:	0e 94 c5 04 	call	0x98a	; 0x98a <_Znaj>
     e64:	90 93 99 01 	sts	0x0199, r25
     e68:	80 93 98 01 	sts	0x0198, r24
     e6c:	10 92 97 01 	sts	0x0197, r1
     e70:	10 92 96 01 	sts	0x0196, r1
     e74:	10 92 95 01 	sts	0x0195, r1
     e78:	10 92 94 01 	sts	0x0194, r1
     e7c:	0f 90       	pop	r0
     e7e:	0f 90       	pop	r0
     e80:	df 91       	pop	r29
     e82:	cf 91       	pop	r28
     e84:	1f 91       	pop	r17
     e86:	ff 90       	pop	r15
     e88:	ef 90       	pop	r14
     e8a:	08 95       	ret
     e8c:	57 9a       	sbi	0x0a, 7	; 10
     e8e:	80 e2       	ldi	r24, 0x20	; 32
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	0e 94 c5 04 	call	0x98a	; 0x98a <_Znaj>
     e96:	90 93 9f 01 	sts	0x019F, r25
     e9a:	80 93 9e 01 	sts	0x019E, r24
     e9e:	10 92 9d 01 	sts	0x019D, r1
     ea2:	10 92 9c 01 	sts	0x019C, r1
     ea6:	10 92 9b 01 	sts	0x019B, r1
     eaa:	10 92 9a 01 	sts	0x019A, r1
     eae:	0f 90       	pop	r0
     eb0:	0f 90       	pop	r0
     eb2:	df 91       	pop	r29
     eb4:	cf 91       	pop	r28
     eb6:	1f 91       	pop	r17
     eb8:	ff 90       	pop	r15
     eba:	ef 90       	pop	r14
     ebc:	08 95       	ret

00000ebe <__vector_18>:
     ebe:	1f 92       	push	r1
     ec0:	0f 92       	push	r0
     ec2:	0f b6       	in	r0, 0x3f	; 63
     ec4:	0f 92       	push	r0
     ec6:	11 24       	eor	r1, r1
     ec8:	0b b6       	in	r0, 0x3b	; 59
     eca:	0f 92       	push	r0
     ecc:	2f 93       	push	r18
     ece:	3f 93       	push	r19
     ed0:	8f 93       	push	r24
     ed2:	9f 93       	push	r25
     ed4:	ef 93       	push	r30
     ed6:	ff 93       	push	r31
     ed8:	2c b1       	in	r18, 0x0c	; 12
     eda:	e0 91 9e 01 	lds	r30, 0x019E
     ede:	f0 91 9f 01 	lds	r31, 0x019F
     ee2:	80 91 9a 01 	lds	r24, 0x019A
     ee6:	90 91 9b 01 	lds	r25, 0x019B
     eea:	e8 0f       	add	r30, r24
     eec:	f9 1f       	adc	r31, r25
     eee:	20 83       	st	Z, r18
     ef0:	80 91 9a 01 	lds	r24, 0x019A
     ef4:	90 91 9b 01 	lds	r25, 0x019B
     ef8:	01 96       	adiw	r24, 0x01	; 1
     efa:	80 32       	cpi	r24, 0x20	; 32
     efc:	91 05       	cpc	r25, r1
     efe:	c0 f4       	brcc	.+48     	; 0xf30 <__vector_18+0x72>
     f00:	90 93 9b 01 	sts	0x019B, r25
     f04:	80 93 9a 01 	sts	0x019A, r24
     f08:	20 91 9c 01 	lds	r18, 0x019C
     f0c:	30 91 9d 01 	lds	r19, 0x019D
     f10:	28 17       	cp	r18, r24
     f12:	39 07       	cpc	r19, r25
     f14:	d1 f0       	breq	.+52     	; 0xf4a <__vector_18+0x8c>
     f16:	ff 91       	pop	r31
     f18:	ef 91       	pop	r30
     f1a:	9f 91       	pop	r25
     f1c:	8f 91       	pop	r24
     f1e:	3f 91       	pop	r19
     f20:	2f 91       	pop	r18
     f22:	0f 90       	pop	r0
     f24:	0b be       	out	0x3b, r0	; 59
     f26:	0f 90       	pop	r0
     f28:	0f be       	out	0x3f, r0	; 63
     f2a:	0f 90       	pop	r0
     f2c:	1f 90       	pop	r1
     f2e:	18 95       	reti
     f30:	10 92 9b 01 	sts	0x019B, r1
     f34:	10 92 9a 01 	sts	0x019A, r1
     f38:	80 e0       	ldi	r24, 0x00	; 0
     f3a:	90 e0       	ldi	r25, 0x00	; 0
     f3c:	20 91 9c 01 	lds	r18, 0x019C
     f40:	30 91 9d 01 	lds	r19, 0x019D
     f44:	28 17       	cp	r18, r24
     f46:	39 07       	cpc	r19, r25
     f48:	31 f7       	brne	.-52     	; 0xf16 <__vector_18+0x58>
     f4a:	01 96       	adiw	r24, 0x01	; 1
     f4c:	90 93 9d 01 	sts	0x019D, r25
     f50:	80 93 9c 01 	sts	0x019C, r24
     f54:	80 97       	sbiw	r24, 0x20	; 32
     f56:	f8 f2       	brcs	.-66     	; 0xf16 <__vector_18+0x58>
     f58:	10 92 9d 01 	sts	0x019D, r1
     f5c:	10 92 9c 01 	sts	0x019C, r1
     f60:	da cf       	rjmp	.-76     	; 0xf16 <__vector_18+0x58>

00000f62 <__vector_30>:
     f62:	1f 92       	push	r1
     f64:	0f 92       	push	r0
     f66:	0f b6       	in	r0, 0x3f	; 63
     f68:	0f 92       	push	r0
     f6a:	11 24       	eor	r1, r1
     f6c:	0b b6       	in	r0, 0x3b	; 59
     f6e:	0f 92       	push	r0
     f70:	2f 93       	push	r18
     f72:	3f 93       	push	r19
     f74:	8f 93       	push	r24
     f76:	9f 93       	push	r25
     f78:	ef 93       	push	r30
     f7a:	ff 93       	push	r31
     f7c:	20 91 9c 00 	lds	r18, 0x009C
     f80:	e0 91 98 01 	lds	r30, 0x0198
     f84:	f0 91 99 01 	lds	r31, 0x0199
     f88:	80 91 94 01 	lds	r24, 0x0194
     f8c:	90 91 95 01 	lds	r25, 0x0195
     f90:	e8 0f       	add	r30, r24
     f92:	f9 1f       	adc	r31, r25
     f94:	20 83       	st	Z, r18
     f96:	80 91 94 01 	lds	r24, 0x0194
     f9a:	90 91 95 01 	lds	r25, 0x0195
     f9e:	01 96       	adiw	r24, 0x01	; 1
     fa0:	80 32       	cpi	r24, 0x20	; 32
     fa2:	91 05       	cpc	r25, r1
     fa4:	c0 f4       	brcc	.+48     	; 0xfd6 <__vector_30+0x74>
     fa6:	90 93 95 01 	sts	0x0195, r25
     faa:	80 93 94 01 	sts	0x0194, r24
     fae:	20 91 96 01 	lds	r18, 0x0196
     fb2:	30 91 97 01 	lds	r19, 0x0197
     fb6:	28 17       	cp	r18, r24
     fb8:	39 07       	cpc	r19, r25
     fba:	d1 f0       	breq	.+52     	; 0xff0 <__vector_30+0x8e>
     fbc:	ff 91       	pop	r31
     fbe:	ef 91       	pop	r30
     fc0:	9f 91       	pop	r25
     fc2:	8f 91       	pop	r24
     fc4:	3f 91       	pop	r19
     fc6:	2f 91       	pop	r18
     fc8:	0f 90       	pop	r0
     fca:	0b be       	out	0x3b, r0	; 59
     fcc:	0f 90       	pop	r0
     fce:	0f be       	out	0x3f, r0	; 63
     fd0:	0f 90       	pop	r0
     fd2:	1f 90       	pop	r1
     fd4:	18 95       	reti
     fd6:	10 92 95 01 	sts	0x0195, r1
     fda:	10 92 94 01 	sts	0x0194, r1
     fde:	80 e0       	ldi	r24, 0x00	; 0
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	20 91 96 01 	lds	r18, 0x0196
     fe6:	30 91 97 01 	lds	r19, 0x0197
     fea:	28 17       	cp	r18, r24
     fec:	39 07       	cpc	r19, r25
     fee:	31 f7       	brne	.-52     	; 0xfbc <__vector_30+0x5a>
     ff0:	01 96       	adiw	r24, 0x01	; 1
     ff2:	90 93 97 01 	sts	0x0197, r25
     ff6:	80 93 96 01 	sts	0x0196, r24
     ffa:	80 97       	sbiw	r24, 0x20	; 32
     ffc:	f8 f2       	brcs	.-66     	; 0xfbc <__vector_30+0x5a>
     ffe:	10 92 97 01 	sts	0x0197, r1
    1002:	10 92 96 01 	sts	0x0196, r1
    1006:	da cf       	rjmp	.-76     	; 0xfbc <__vector_30+0x5a>

00001008 <pvPortMalloc>:
    1008:	cf 93       	push	r28
    100a:	df 93       	push	r29
    100c:	ec 01       	movw	r28, r24
    100e:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <vTaskSuspendAll>
    1012:	40 91 a0 01 	lds	r20, 0x01A0
    1016:	50 91 a1 01 	lds	r21, 0x01A1
    101a:	9e 01       	movw	r18, r28
    101c:	24 0f       	add	r18, r20
    101e:	35 1f       	adc	r19, r21
    1020:	28 37       	cpi	r18, 0x78	; 120
    1022:	8a e0       	ldi	r24, 0x0A	; 10
    1024:	38 07       	cpc	r19, r24
    1026:	80 f4       	brcc	.+32     	; 0x1048 <pvPortMalloc+0x40>
    1028:	42 17       	cp	r20, r18
    102a:	53 07       	cpc	r21, r19
    102c:	68 f4       	brcc	.+26     	; 0x1048 <pvPortMalloc+0x40>
    102e:	ea 01       	movw	r28, r20
    1030:	ce 55       	subi	r28, 0x5E	; 94
    1032:	de 4f       	sbci	r29, 0xFE	; 254
    1034:	30 93 a1 01 	sts	0x01A1, r19
    1038:	20 93 a0 01 	sts	0x01A0, r18
    103c:	0e 94 9f 10 	call	0x213e	; 0x213e <xTaskResumeAll>
    1040:	ce 01       	movw	r24, r28
    1042:	df 91       	pop	r29
    1044:	cf 91       	pop	r28
    1046:	08 95       	ret
    1048:	c0 e0       	ldi	r28, 0x00	; 0
    104a:	d0 e0       	ldi	r29, 0x00	; 0
    104c:	0e 94 9f 10 	call	0x213e	; 0x213e <xTaskResumeAll>
    1050:	ce 01       	movw	r24, r28
    1052:	df 91       	pop	r29
    1054:	cf 91       	pop	r28
    1056:	08 95       	ret

00001058 <vPortFree>:
    1058:	08 95       	ret

0000105a <vPortInitialiseBlocks>:
    105a:	10 92 a1 01 	sts	0x01A1, r1
    105e:	10 92 a0 01 	sts	0x01A0, r1
    1062:	08 95       	ret

00001064 <xPortGetFreeHeapSize>:
    1064:	20 91 a0 01 	lds	r18, 0x01A0
    1068:	30 91 a1 01 	lds	r19, 0x01A1
    106c:	88 e7       	ldi	r24, 0x78	; 120
    106e:	9a e0       	ldi	r25, 0x0A	; 10
    1070:	82 1b       	sub	r24, r18
    1072:	93 0b       	sbc	r25, r19
    1074:	08 95       	ret

00001076 <pxPortInitialiseStack>:
	// variable here which holds the address of the top of the stack. It will be
	// grabbed by the task's wrapper object just after xTaskCreate() is called so that
	// the task object knows where its stack is. The stack can then be dumped to a
	// serial port (as a hex printout) for debugging purposes. 
	#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
		portStackTopForTask = (size_t)pxTopOfStack;
    1076:	90 93 7d 0c 	sts	0x0C7D, r25
    107a:	80 93 7c 0c 	sts	0x0C7C, r24
	#endif

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    107e:	31 e1       	ldi	r19, 0x11	; 17
    1080:	fc 01       	movw	r30, r24
    1082:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1084:	31 97       	sbiw	r30, 0x01	; 1
    1086:	22 e2       	ldi	r18, 0x22	; 34
    1088:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    108a:	fc 01       	movw	r30, r24
    108c:	32 97       	sbiw	r30, 0x02	; 2
    108e:	a3 e3       	ldi	r26, 0x33	; 51
    1090:	a0 83       	st	Z, r26
	pxTopOfStack--;
#else
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1092:	fc 01       	movw	r30, r24
    1094:	33 97       	sbiw	r30, 0x03	; 3
    1096:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1098:	fc 01       	movw	r30, r24
    109a:	34 97       	sbiw	r30, 0x04	; 4
    109c:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    109e:	fc 01       	movw	r30, r24
    10a0:	35 97       	sbiw	r30, 0x05	; 5
    10a2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    10a4:	fc 01       	movw	r30, r24
    10a6:	36 97       	sbiw	r30, 0x06	; 6
    10a8:	60 e8       	ldi	r22, 0x80	; 128
    10aa:	60 83       	st	Z, r22
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
	pxTopOfStack--;
#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    10ac:	fc 01       	movw	r30, r24
    10ae:	37 97       	sbiw	r30, 0x07	; 7
    10b0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    10b2:	fc 01       	movw	r30, r24
    10b4:	38 97       	sbiw	r30, 0x08	; 8
    10b6:	62 e0       	ldi	r22, 0x02	; 2
    10b8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    10ba:	fc 01       	movw	r30, r24
    10bc:	39 97       	sbiw	r30, 0x09	; 9
    10be:	63 e0       	ldi	r22, 0x03	; 3
    10c0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    10c2:	fc 01       	movw	r30, r24
    10c4:	3a 97       	sbiw	r30, 0x0a	; 10
    10c6:	64 e0       	ldi	r22, 0x04	; 4
    10c8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    10ca:	fc 01       	movw	r30, r24
    10cc:	3b 97       	sbiw	r30, 0x0b	; 11
    10ce:	65 e0       	ldi	r22, 0x05	; 5
    10d0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    10d2:	fc 01       	movw	r30, r24
    10d4:	3c 97       	sbiw	r30, 0x0c	; 12
    10d6:	66 e0       	ldi	r22, 0x06	; 6
    10d8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    10da:	fc 01       	movw	r30, r24
    10dc:	3d 97       	sbiw	r30, 0x0d	; 13
    10de:	67 e0       	ldi	r22, 0x07	; 7
    10e0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    10e2:	fc 01       	movw	r30, r24
    10e4:	3e 97       	sbiw	r30, 0x0e	; 14
    10e6:	68 e0       	ldi	r22, 0x08	; 8
    10e8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    10ea:	fc 01       	movw	r30, r24
    10ec:	3f 97       	sbiw	r30, 0x0f	; 15
    10ee:	69 e0       	ldi	r22, 0x09	; 9
    10f0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    10f2:	fc 01       	movw	r30, r24
    10f4:	70 97       	sbiw	r30, 0x10	; 16
    10f6:	60 e1       	ldi	r22, 0x10	; 16
    10f8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    10fa:	fc 01       	movw	r30, r24
    10fc:	71 97       	sbiw	r30, 0x11	; 17
    10fe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1100:	fc 01       	movw	r30, r24
    1102:	72 97       	sbiw	r30, 0x12	; 18
    1104:	32 e1       	ldi	r19, 0x12	; 18
    1106:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1108:	fc 01       	movw	r30, r24
    110a:	73 97       	sbiw	r30, 0x13	; 19
    110c:	33 e1       	ldi	r19, 0x13	; 19
    110e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1110:	fc 01       	movw	r30, r24
    1112:	74 97       	sbiw	r30, 0x14	; 20
    1114:	34 e1       	ldi	r19, 0x14	; 20
    1116:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1118:	fc 01       	movw	r30, r24
    111a:	75 97       	sbiw	r30, 0x15	; 21
    111c:	35 e1       	ldi	r19, 0x15	; 21
    111e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1120:	fc 01       	movw	r30, r24
    1122:	76 97       	sbiw	r30, 0x16	; 22
    1124:	36 e1       	ldi	r19, 0x16	; 22
    1126:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1128:	fc 01       	movw	r30, r24
    112a:	77 97       	sbiw	r30, 0x17	; 23
    112c:	37 e1       	ldi	r19, 0x17	; 23
    112e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1130:	fc 01       	movw	r30, r24
    1132:	78 97       	sbiw	r30, 0x18	; 24
    1134:	38 e1       	ldi	r19, 0x18	; 24
    1136:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1138:	fc 01       	movw	r30, r24
    113a:	79 97       	sbiw	r30, 0x19	; 25
    113c:	39 e1       	ldi	r19, 0x19	; 25
    113e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1140:	fc 01       	movw	r30, r24
    1142:	7a 97       	sbiw	r30, 0x1a	; 26
    1144:	30 e2       	ldi	r19, 0x20	; 32
    1146:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1148:	fc 01       	movw	r30, r24
    114a:	7b 97       	sbiw	r30, 0x1b	; 27
    114c:	31 e2       	ldi	r19, 0x21	; 33
    114e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1150:	fc 01       	movw	r30, r24
    1152:	7c 97       	sbiw	r30, 0x1c	; 28
    1154:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1156:	fc 01       	movw	r30, r24
    1158:	7d 97       	sbiw	r30, 0x1d	; 29
    115a:	23 e2       	ldi	r18, 0x23	; 35
    115c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    115e:	fc 01       	movw	r30, r24
    1160:	7e 97       	sbiw	r30, 0x1e	; 30
    1162:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1164:	fc 01       	movw	r30, r24
    1166:	7f 97       	sbiw	r30, 0x1f	; 31
    1168:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    116a:	fc 01       	movw	r30, r24
    116c:	b0 97       	sbiw	r30, 0x20	; 32
    116e:	26 e2       	ldi	r18, 0x26	; 38
    1170:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1172:	fc 01       	movw	r30, r24
    1174:	b1 97       	sbiw	r30, 0x21	; 33
    1176:	27 e2       	ldi	r18, 0x27	; 39
    1178:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    117a:	fc 01       	movw	r30, r24
    117c:	b2 97       	sbiw	r30, 0x22	; 34
    117e:	28 e2       	ldi	r18, 0x28	; 40
    1180:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1182:	fc 01       	movw	r30, r24
    1184:	b3 97       	sbiw	r30, 0x23	; 35
    1186:	29 e2       	ldi	r18, 0x29	; 41
    1188:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    118a:	fc 01       	movw	r30, r24
    118c:	b4 97       	sbiw	r30, 0x24	; 36
    118e:	20 e3       	ldi	r18, 0x30	; 48
    1190:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1192:	fc 01       	movw	r30, r24
    1194:	b5 97       	sbiw	r30, 0x25	; 37
    1196:	21 e3       	ldi	r18, 0x31	; 49
    1198:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    119a:	86 97       	sbiw	r24, 0x26	; 38
    119c:	08 95       	ret

0000119e <xPortStartScheduler>:
		OCR5AL = compare_match.byte[0];         // register, then low byte
		TCCR5B = (1 << CS51) | (1 << WGM52);    // Prescale F_CPU / 8, clear on match
		TIMSK5 |= (1 << OCIE5A);                // Enable the timer interrupt
	#elif (defined TIMER3_COMPA_vect)           // Use Timer 3 on ATmega128/1284
		#define RT_VECT TIMER3_COMPA_vect
		OCR3AH = compare_match.byte[1];         // Set high byte of compare match
    119e:	87 e0       	ldi	r24, 0x07	; 7
    11a0:	80 93 87 00 	sts	0x0087, r24
		OCR3AL = compare_match.byte[0];         // register, then low byte
    11a4:	8f ec       	ldi	r24, 0xCF	; 207
    11a6:	80 93 86 00 	sts	0x0086, r24
		TCCR3B = (1 << CS31) | (1 << WGM32);    // Prescale F_CPU / 8, clear on match
    11aa:	8a e0       	ldi	r24, 0x0A	; 10
    11ac:	80 93 8a 00 	sts	0x008A, r24
		#ifdef TIMSK3                           // Exists on 640/1280/1281/2560/2561
			TIMSK3 |= (1 << OCIE3A);            // but not on most others
		#elif defined ETIMSK
			ETIMSK |= (1 << OCIE3A);
    11b0:	ed e7       	ldi	r30, 0x7D	; 125
    11b2:	f0 e0       	ldi	r31, 0x00	; 0
    11b4:	80 81       	ld	r24, Z
    11b6:	80 61       	ori	r24, 0x10	; 16
    11b8:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    11ba:	a0 91 1a 0c 	lds	r26, 0x0C1A
    11be:	b0 91 1b 0c 	lds	r27, 0x0C1B
    11c2:	cd 91       	ld	r28, X+
    11c4:	cd bf       	out	0x3d, r28	; 61
    11c6:	dd 91       	ld	r29, X+
    11c8:	de bf       	out	0x3e, r29	; 62
    11ca:	ff 91       	pop	r31
    11cc:	ef 91       	pop	r30
    11ce:	df 91       	pop	r29
    11d0:	cf 91       	pop	r28
    11d2:	bf 91       	pop	r27
    11d4:	af 91       	pop	r26
    11d6:	9f 91       	pop	r25
    11d8:	8f 91       	pop	r24
    11da:	7f 91       	pop	r23
    11dc:	6f 91       	pop	r22
    11de:	5f 91       	pop	r21
    11e0:	4f 91       	pop	r20
    11e2:	3f 91       	pop	r19
    11e4:	2f 91       	pop	r18
    11e6:	1f 91       	pop	r17
    11e8:	0f 91       	pop	r16
    11ea:	ff 90       	pop	r15
    11ec:	ef 90       	pop	r14
    11ee:	df 90       	pop	r13
    11f0:	cf 90       	pop	r12
    11f2:	bf 90       	pop	r11
    11f4:	af 90       	pop	r10
    11f6:	9f 90       	pop	r9
    11f8:	8f 90       	pop	r8
    11fa:	7f 90       	pop	r7
    11fc:	6f 90       	pop	r6
    11fe:	5f 90       	pop	r5
    1200:	4f 90       	pop	r4
    1202:	3f 90       	pop	r3
    1204:	2f 90       	pop	r2
    1206:	1f 90       	pop	r1
    1208:	0f 90       	pop	r0
    120a:	0f be       	out	0x3f, r0	; 63
    120c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    120e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1210:	81 e0       	ldi	r24, 0x01	; 1
    1212:	08 95       	ret

00001214 <vPortEndScheduler>:

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1214:	08 95       	ret

00001216 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1216:	0f 92       	push	r0
    1218:	0f b6       	in	r0, 0x3f	; 63
    121a:	f8 94       	cli
    121c:	0f 92       	push	r0
    121e:	1f 92       	push	r1
    1220:	11 24       	eor	r1, r1
    1222:	2f 92       	push	r2
    1224:	3f 92       	push	r3
    1226:	4f 92       	push	r4
    1228:	5f 92       	push	r5
    122a:	6f 92       	push	r6
    122c:	7f 92       	push	r7
    122e:	8f 92       	push	r8
    1230:	9f 92       	push	r9
    1232:	af 92       	push	r10
    1234:	bf 92       	push	r11
    1236:	cf 92       	push	r12
    1238:	df 92       	push	r13
    123a:	ef 92       	push	r14
    123c:	ff 92       	push	r15
    123e:	0f 93       	push	r16
    1240:	1f 93       	push	r17
    1242:	2f 93       	push	r18
    1244:	3f 93       	push	r19
    1246:	4f 93       	push	r20
    1248:	5f 93       	push	r21
    124a:	6f 93       	push	r22
    124c:	7f 93       	push	r23
    124e:	8f 93       	push	r24
    1250:	9f 93       	push	r25
    1252:	af 93       	push	r26
    1254:	bf 93       	push	r27
    1256:	cf 93       	push	r28
    1258:	df 93       	push	r29
    125a:	ef 93       	push	r30
    125c:	ff 93       	push	r31
    125e:	a0 91 1a 0c 	lds	r26, 0x0C1A
    1262:	b0 91 1b 0c 	lds	r27, 0x0C1B
    1266:	0d b6       	in	r0, 0x3d	; 61
    1268:	0d 92       	st	X+, r0
    126a:	0e b6       	in	r0, 0x3e	; 62
    126c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    126e:	0e 94 b4 11 	call	0x2368	; 0x2368 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1272:	a0 91 1a 0c 	lds	r26, 0x0C1A
    1276:	b0 91 1b 0c 	lds	r27, 0x0C1B
    127a:	cd 91       	ld	r28, X+
    127c:	cd bf       	out	0x3d, r28	; 61
    127e:	dd 91       	ld	r29, X+
    1280:	de bf       	out	0x3e, r29	; 62
    1282:	ff 91       	pop	r31
    1284:	ef 91       	pop	r30
    1286:	df 91       	pop	r29
    1288:	cf 91       	pop	r28
    128a:	bf 91       	pop	r27
    128c:	af 91       	pop	r26
    128e:	9f 91       	pop	r25
    1290:	8f 91       	pop	r24
    1292:	7f 91       	pop	r23
    1294:	6f 91       	pop	r22
    1296:	5f 91       	pop	r21
    1298:	4f 91       	pop	r20
    129a:	3f 91       	pop	r19
    129c:	2f 91       	pop	r18
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	ff 90       	pop	r15
    12a4:	ef 90       	pop	r14
    12a6:	df 90       	pop	r13
    12a8:	cf 90       	pop	r12
    12aa:	bf 90       	pop	r11
    12ac:	af 90       	pop	r10
    12ae:	9f 90       	pop	r9
    12b0:	8f 90       	pop	r8
    12b2:	7f 90       	pop	r7
    12b4:	6f 90       	pop	r6
    12b6:	5f 90       	pop	r5
    12b8:	4f 90       	pop	r4
    12ba:	3f 90       	pop	r3
    12bc:	2f 90       	pop	r2
    12be:	1f 90       	pop	r1
    12c0:	0f 90       	pop	r0
    12c2:	0f be       	out	0x3f, r0	; 63
    12c4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12c6:	08 95       	ret

000012c8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    12c8:	0f 92       	push	r0
    12ca:	0f b6       	in	r0, 0x3f	; 63
    12cc:	f8 94       	cli
    12ce:	0f 92       	push	r0
    12d0:	1f 92       	push	r1
    12d2:	11 24       	eor	r1, r1
    12d4:	2f 92       	push	r2
    12d6:	3f 92       	push	r3
    12d8:	4f 92       	push	r4
    12da:	5f 92       	push	r5
    12dc:	6f 92       	push	r6
    12de:	7f 92       	push	r7
    12e0:	8f 92       	push	r8
    12e2:	9f 92       	push	r9
    12e4:	af 92       	push	r10
    12e6:	bf 92       	push	r11
    12e8:	cf 92       	push	r12
    12ea:	df 92       	push	r13
    12ec:	ef 92       	push	r14
    12ee:	ff 92       	push	r15
    12f0:	0f 93       	push	r16
    12f2:	1f 93       	push	r17
    12f4:	2f 93       	push	r18
    12f6:	3f 93       	push	r19
    12f8:	4f 93       	push	r20
    12fa:	5f 93       	push	r21
    12fc:	6f 93       	push	r22
    12fe:	7f 93       	push	r23
    1300:	8f 93       	push	r24
    1302:	9f 93       	push	r25
    1304:	af 93       	push	r26
    1306:	bf 93       	push	r27
    1308:	cf 93       	push	r28
    130a:	df 93       	push	r29
    130c:	ef 93       	push	r30
    130e:	ff 93       	push	r31
    1310:	a0 91 1a 0c 	lds	r26, 0x0C1A
    1314:	b0 91 1b 0c 	lds	r27, 0x0C1B
    1318:	0d b6       	in	r0, 0x3d	; 61
    131a:	0d 92       	st	X+, r0
    131c:	0e b6       	in	r0, 0x3e	; 62
    131e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1320:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <vTaskIncrementTick>
	vTaskSwitchContext();
    1324:	0e 94 b4 11 	call	0x2368	; 0x2368 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1328:	a0 91 1a 0c 	lds	r26, 0x0C1A
    132c:	b0 91 1b 0c 	lds	r27, 0x0C1B
    1330:	cd 91       	ld	r28, X+
    1332:	cd bf       	out	0x3d, r28	; 61
    1334:	dd 91       	ld	r29, X+
    1336:	de bf       	out	0x3e, r29	; 62
    1338:	ff 91       	pop	r31
    133a:	ef 91       	pop	r30
    133c:	df 91       	pop	r29
    133e:	cf 91       	pop	r28
    1340:	bf 91       	pop	r27
    1342:	af 91       	pop	r26
    1344:	9f 91       	pop	r25
    1346:	8f 91       	pop	r24
    1348:	7f 91       	pop	r23
    134a:	6f 91       	pop	r22
    134c:	5f 91       	pop	r21
    134e:	4f 91       	pop	r20
    1350:	3f 91       	pop	r19
    1352:	2f 91       	pop	r18
    1354:	1f 91       	pop	r17
    1356:	0f 91       	pop	r16
    1358:	ff 90       	pop	r15
    135a:	ef 90       	pop	r14
    135c:	df 90       	pop	r13
    135e:	cf 90       	pop	r12
    1360:	bf 90       	pop	r11
    1362:	af 90       	pop	r10
    1364:	9f 90       	pop	r9
    1366:	8f 90       	pop	r8
    1368:	7f 90       	pop	r7
    136a:	6f 90       	pop	r6
    136c:	5f 90       	pop	r5
    136e:	4f 90       	pop	r4
    1370:	3f 90       	pop	r3
    1372:	2f 90       	pop	r2
    1374:	1f 90       	pop	r1
    1376:	0f 90       	pop	r0
    1378:	0f be       	out	0x3f, r0	; 63
    137a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    137c:	08 95       	ret

0000137e <__vector_26>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    137e:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1382:	18 95       	reti

00001384 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1384:	cf 93       	push	r28
    1386:	df 93       	push	r29
    1388:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    138a:	88 a1       	ldd	r24, Y+32	; 0x20
    138c:	81 11       	cpse	r24, r1
    138e:	0b c0       	rjmp	.+22     	; 0x13a6 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1390:	88 81       	ld	r24, Y
    1392:	99 81       	ldd	r25, Y+1	; 0x01
    1394:	89 2b       	or	r24, r25
    1396:	09 f4       	brne	.+2      	; 0x139a <prvCopyDataToQueue+0x16>
    1398:	46 c0       	rjmp	.+140    	; 0x1426 <prvCopyDataToQueue+0xa2>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    139a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    139c:	8f 5f       	subi	r24, 0xFF	; 255
    139e:	8e 8f       	std	Y+30, r24	; 0x1e
}
    13a0:	df 91       	pop	r29
    13a2:	cf 91       	pop	r28
    13a4:	08 95       	ret
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    13a6:	41 11       	cpse	r20, r1
    13a8:	1c c0       	rjmp	.+56     	; 0x13e2 <prvCopyDataToQueue+0x5e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    13aa:	48 2f       	mov	r20, r24
    13ac:	50 e0       	ldi	r21, 0x00	; 0
    13ae:	8c 81       	ldd	r24, Y+4	; 0x04
    13b0:	9d 81       	ldd	r25, Y+5	; 0x05
    13b2:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    13b6:	28 a1       	ldd	r18, Y+32	; 0x20
    13b8:	8c 81       	ldd	r24, Y+4	; 0x04
    13ba:	9d 81       	ldd	r25, Y+5	; 0x05
    13bc:	82 0f       	add	r24, r18
    13be:	91 1d       	adc	r25, r1
    13c0:	9d 83       	std	Y+5, r25	; 0x05
    13c2:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    13c4:	2a 81       	ldd	r18, Y+2	; 0x02
    13c6:	3b 81       	ldd	r19, Y+3	; 0x03
    13c8:	82 17       	cp	r24, r18
    13ca:	93 07       	cpc	r25, r19
    13cc:	30 f3       	brcs	.-52     	; 0x139a <prvCopyDataToQueue+0x16>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    13ce:	88 81       	ld	r24, Y
    13d0:	99 81       	ldd	r25, Y+1	; 0x01
    13d2:	9d 83       	std	Y+5, r25	; 0x05
    13d4:	8c 83       	std	Y+4, r24	; 0x04
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    13d6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13d8:	8f 5f       	subi	r24, 0xFF	; 255
    13da:	8e 8f       	std	Y+30, r24	; 0x1e
}
    13dc:	df 91       	pop	r29
    13de:	cf 91       	pop	r28
    13e0:	08 95       	ret
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    13e2:	48 2f       	mov	r20, r24
    13e4:	50 e0       	ldi	r21, 0x00	; 0
    13e6:	8e 81       	ldd	r24, Y+6	; 0x06
    13e8:	9f 81       	ldd	r25, Y+7	; 0x07
    13ea:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    13ee:	28 a1       	ldd	r18, Y+32	; 0x20
    13f0:	30 e0       	ldi	r19, 0x00	; 0
    13f2:	31 95       	neg	r19
    13f4:	21 95       	neg	r18
    13f6:	31 09       	sbc	r19, r1
    13f8:	8e 81       	ldd	r24, Y+6	; 0x06
    13fa:	9f 81       	ldd	r25, Y+7	; 0x07
    13fc:	82 0f       	add	r24, r18
    13fe:	93 1f       	adc	r25, r19
    1400:	9f 83       	std	Y+7, r25	; 0x07
    1402:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1404:	48 81       	ld	r20, Y
    1406:	59 81       	ldd	r21, Y+1	; 0x01
    1408:	84 17       	cp	r24, r20
    140a:	95 07       	cpc	r25, r21
    140c:	30 f6       	brcc	.-116    	; 0x139a <prvCopyDataToQueue+0x16>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    140e:	8a 81       	ldd	r24, Y+2	; 0x02
    1410:	9b 81       	ldd	r25, Y+3	; 0x03
    1412:	82 0f       	add	r24, r18
    1414:	93 1f       	adc	r25, r19
    1416:	9f 83       	std	Y+7, r25	; 0x07
    1418:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    141a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    141c:	8f 5f       	subi	r24, 0xFF	; 255
    141e:	8e 8f       	std	Y+30, r24	; 0x1e
}
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	08 95       	ret
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1426:	8a 81       	ldd	r24, Y+2	; 0x02
    1428:	9b 81       	ldd	r25, Y+3	; 0x03
    142a:	0e 94 59 13 	call	0x26b2	; 0x26b2 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    142e:	1b 82       	std	Y+3, r1	; 0x03
    1430:	1a 82       	std	Y+2, r1	; 0x02
    1432:	b3 cf       	rjmp	.-154    	; 0x139a <prvCopyDataToQueue+0x16>

00001434 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1434:	fc 01       	movw	r30, r24
    1436:	cb 01       	movw	r24, r22
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1438:	a0 81       	ld	r26, Z
    143a:	b1 81       	ldd	r27, Z+1	; 0x01
    143c:	10 97       	sbiw	r26, 0x00	; 0
    143e:	99 f0       	breq	.+38     	; 0x1466 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1440:	40 a1       	ldd	r20, Z+32	; 0x20
    1442:	50 e0       	ldi	r21, 0x00	; 0
    1444:	26 81       	ldd	r18, Z+6	; 0x06
    1446:	37 81       	ldd	r19, Z+7	; 0x07
    1448:	24 0f       	add	r18, r20
    144a:	35 1f       	adc	r19, r21
    144c:	37 83       	std	Z+7, r19	; 0x07
    144e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1450:	62 81       	ldd	r22, Z+2	; 0x02
    1452:	73 81       	ldd	r23, Z+3	; 0x03
    1454:	26 17       	cp	r18, r22
    1456:	37 07       	cpc	r19, r23
    1458:	18 f0       	brcs	.+6      	; 0x1460 <prvCopyDataFromQueue+0x2c>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    145a:	b7 83       	std	Z+7, r27	; 0x07
    145c:	a6 83       	std	Z+6, r26	; 0x06
    145e:	9d 01       	movw	r18, r26
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1460:	b9 01       	movw	r22, r18
    1462:	0c 94 c8 16 	jmp	0x2d90	; 0x2d90 <memcpy>
    1466:	08 95       	ret

00001468 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1468:	0f 93       	push	r16
    146a:	1f 93       	push	r17
    146c:	cf 93       	push	r28
    146e:	df 93       	push	r29
    1470:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1472:	0f b6       	in	r0, 0x3f	; 63
    1474:	f8 94       	cli
    1476:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1478:	8a a1       	ldd	r24, Y+34	; 0x22
    147a:	18 16       	cp	r1, r24
    147c:	dc f4       	brge	.+54     	; 0x14b4 <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    147e:	8b 89       	ldd	r24, Y+19	; 0x13
    1480:	88 23       	and	r24, r24
    1482:	c1 f0       	breq	.+48     	; 0x14b4 <prvUnlockQueue+0x4c>
    1484:	8e 01       	movw	r16, r28
    1486:	0d 5e       	subi	r16, 0xED	; 237
    1488:	1f 4f       	sbci	r17, 0xFF	; 255
    148a:	08 c0       	rjmp	.+16     	; 0x149c <prvUnlockQueue+0x34>
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
    148c:	8a a1       	ldd	r24, Y+34	; 0x22
    148e:	81 50       	subi	r24, 0x01	; 1
    1490:	8a a3       	std	Y+34, r24	; 0x22
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1492:	18 16       	cp	r1, r24
    1494:	7c f4       	brge	.+30     	; 0x14b4 <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1496:	8b 89       	ldd	r24, Y+19	; 0x13
    1498:	88 23       	and	r24, r24
    149a:	61 f0       	breq	.+24     	; 0x14b4 <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    149c:	c8 01       	movw	r24, r16
    149e:	0e 94 23 12 	call	0x2446	; 0x2446 <xTaskRemoveFromEventList>
    14a2:	88 23       	and	r24, r24
    14a4:	99 f3       	breq	.-26     	; 0x148c <prvUnlockQueue+0x24>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    14a6:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    14aa:	8a a1       	ldd	r24, Y+34	; 0x22
    14ac:	81 50       	subi	r24, 0x01	; 1
    14ae:	8a a3       	std	Y+34, r24	; 0x22
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    14b0:	18 16       	cp	r1, r24
    14b2:	8c f3       	brlt	.-30     	; 0x1496 <prvUnlockQueue+0x2e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    14b4:	8f ef       	ldi	r24, 0xFF	; 255
    14b6:	8a a3       	std	Y+34, r24	; 0x22
	}
	taskEXIT_CRITICAL();
    14b8:	0f 90       	pop	r0
    14ba:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    14bc:	0f b6       	in	r0, 0x3f	; 63
    14be:	f8 94       	cli
    14c0:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    14c2:	89 a1       	ldd	r24, Y+33	; 0x21
    14c4:	18 16       	cp	r1, r24
    14c6:	dc f4       	brge	.+54     	; 0x14fe <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14c8:	88 85       	ldd	r24, Y+8	; 0x08
    14ca:	88 23       	and	r24, r24
    14cc:	c1 f0       	breq	.+48     	; 0x14fe <prvUnlockQueue+0x96>
    14ce:	8e 01       	movw	r16, r28
    14d0:	08 5f       	subi	r16, 0xF8	; 248
    14d2:	1f 4f       	sbci	r17, 0xFF	; 255
    14d4:	08 c0       	rjmp	.+16     	; 0x14e6 <prvUnlockQueue+0x7e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
    14d6:	89 a1       	ldd	r24, Y+33	; 0x21
    14d8:	81 50       	subi	r24, 0x01	; 1
    14da:	89 a3       	std	Y+33, r24	; 0x21
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    14dc:	18 16       	cp	r1, r24
    14de:	7c f4       	brge	.+30     	; 0x14fe <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14e0:	88 85       	ldd	r24, Y+8	; 0x08
    14e2:	88 23       	and	r24, r24
    14e4:	61 f0       	breq	.+24     	; 0x14fe <prvUnlockQueue+0x96>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14e6:	c8 01       	movw	r24, r16
    14e8:	0e 94 23 12 	call	0x2446	; 0x2446 <xTaskRemoveFromEventList>
    14ec:	88 23       	and	r24, r24
    14ee:	99 f3       	breq	.-26     	; 0x14d6 <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
    14f0:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    14f4:	89 a1       	ldd	r24, Y+33	; 0x21
    14f6:	81 50       	subi	r24, 0x01	; 1
    14f8:	89 a3       	std	Y+33, r24	; 0x21
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    14fa:	18 16       	cp	r1, r24
    14fc:	8c f3       	brlt	.-30     	; 0x14e0 <prvUnlockQueue+0x78>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    14fe:	8f ef       	ldi	r24, 0xFF	; 255
    1500:	89 a3       	std	Y+33, r24	; 0x21
	}
	taskEXIT_CRITICAL();
    1502:	0f 90       	pop	r0
    1504:	0f be       	out	0x3f, r0	; 63
}
    1506:	df 91       	pop	r29
    1508:	cf 91       	pop	r28
    150a:	1f 91       	pop	r17
    150c:	0f 91       	pop	r16
    150e:	08 95       	ret

00001510 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    1510:	cf 93       	push	r28
    1512:	df 93       	push	r29
    1514:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );

	/* If the queue being reset has already been used (has not just been
	created), then only reset the queue if its event lists are empty. */
	if( xNewQueue != pdTRUE )
    1516:	61 30       	cpi	r22, 0x01	; 1
    1518:	51 f0       	breq	.+20     	; 0x152e <xQueueGenericReset+0x1e>
	{
		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    151a:	9b 89       	ldd	r25, Y+19	; 0x13
		{
			xReturn = pdFAIL;
		}

		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    151c:	88 85       	ldd	r24, Y+8	; 0x08
    151e:	88 23       	and	r24, r24
    1520:	21 f0       	breq	.+8      	; 0x152a <xQueueGenericReset+0x1a>
    1522:	80 e0       	ldi	r24, 0x00	; 0
		vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
		vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
	}

	return xReturn;
}
    1524:	df 91       	pop	r29
    1526:	cf 91       	pop	r28
    1528:	08 95       	ret
		{
			xReturn = pdFAIL;
		}
	}

	if( xReturn == pdPASS )
    152a:	91 11       	cpse	r25, r1
    152c:	fa cf       	rjmp	.-12     	; 0x1522 <xQueueGenericReset+0x12>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    152e:	28 81       	ld	r18, Y
    1530:	39 81       	ldd	r19, Y+1	; 0x01
    1532:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1534:	68 a1       	ldd	r22, Y+32	; 0x20
    1536:	86 9f       	mul	r24, r22
    1538:	c0 01       	movw	r24, r0
    153a:	11 24       	eor	r1, r1
    153c:	a9 01       	movw	r20, r18
    153e:	48 0f       	add	r20, r24
    1540:	59 1f       	adc	r21, r25
    1542:	5b 83       	std	Y+3, r21	; 0x03
    1544:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1546:	1e 8e       	std	Y+30, r1	; 0x1e
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1548:	3d 83       	std	Y+5, r19	; 0x05
    154a:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    154c:	86 1b       	sub	r24, r22
    154e:	91 09       	sbc	r25, r1
    1550:	82 0f       	add	r24, r18
    1552:	93 1f       	adc	r25, r19
    1554:	9f 83       	std	Y+7, r25	; 0x07
    1556:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1558:	8f ef       	ldi	r24, 0xFF	; 255
    155a:	89 a3       	std	Y+33, r24	; 0x21
		pxQueue->xTxLock = queueUNLOCKED;
    155c:	8a a3       	std	Y+34, r24	; 0x22

		/* Ensure the event queues start with the correct state. */
		vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    155e:	ce 01       	movw	r24, r28
    1560:	08 96       	adiw	r24, 0x08	; 8
    1562:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>
		vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1566:	ce 01       	movw	r24, r28
    1568:	43 96       	adiw	r24, 0x13	; 19
    156a:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>
    156e:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    1570:	df 91       	pop	r29
    1572:	cf 91       	pop	r28
    1574:	08 95       	ret

00001576 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    1576:	0f 93       	push	r16
    1578:	1f 93       	push	r17
    157a:	cf 93       	push	r28
    157c:	df 93       	push	r29
    157e:	18 2f       	mov	r17, r24
    1580:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1582:	88 23       	and	r24, r24
    1584:	01 f1       	breq	.+64     	; 0x15c6 <xQueueGenericCreate+0x50>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1586:	83 e2       	ldi	r24, 0x23	; 35
    1588:	90 e0       	ldi	r25, 0x00	; 0
    158a:	0e 94 04 08 	call	0x1008	; 0x1008 <pvPortMalloc>
    158e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1590:	00 97       	sbiw	r24, 0x00	; 0
    1592:	c9 f0       	breq	.+50     	; 0x15c6 <xQueueGenericCreate+0x50>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1594:	10 9f       	mul	r17, r16
    1596:	c0 01       	movw	r24, r0
    1598:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    159a:	01 96       	adiw	r24, 0x01	; 1
    159c:	0e 94 04 08 	call	0x1008	; 0x1008 <pvPortMalloc>
    15a0:	99 83       	std	Y+1, r25	; 0x01
    15a2:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    15a4:	89 2b       	or	r24, r25
    15a6:	61 f0       	breq	.+24     	; 0x15c0 <xQueueGenericCreate+0x4a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    15a8:	1f 8f       	std	Y+31, r17	; 0x1f
				pxNewQueue->uxItemSize = uxItemSize;
    15aa:	08 a3       	std	Y+32, r16	; 0x20
				xQueueGenericReset( pxNewQueue, pdTRUE );
    15ac:	61 e0       	ldi	r22, 0x01	; 1
    15ae:	ce 01       	movw	r24, r28
    15b0:	0e 94 88 0a 	call	0x1510	; 0x1510 <xQueueGenericReset>
	}

	configASSERT( xReturn );

	return xReturn;
}
    15b4:	ce 01       	movw	r24, r28
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	08 95       	ret
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    15c0:	ce 01       	movw	r24, r28
    15c2:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    15c6:	c0 e0       	ldi	r28, 0x00	; 0
    15c8:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    15ca:	ce 01       	movw	r24, r28
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	1f 91       	pop	r17
    15d2:	0f 91       	pop	r16
    15d4:	08 95       	ret

000015d6 <xQueueGetMutexHolder>:
		/* This function is called by xSemaphoreGetMutexHolder(), and should not
		be called directly.  Note:  This is is a good way of determining if the
		calling task is the mutex holder, but not a good way of determining the
		identity of the mutex holder, as the holder may change between the 
		following critical section exiting and the function returning. */
		taskENTER_CRITICAL();
    15d6:	0f b6       	in	r0, 0x3f	; 63
    15d8:	f8 94       	cli
    15da:	0f 92       	push	r0
		{
			if( xSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
    15dc:	fc 01       	movw	r30, r24
    15de:	20 81       	ld	r18, Z
    15e0:	31 81       	ldd	r19, Z+1	; 0x01
    15e2:	23 2b       	or	r18, r19
    15e4:	29 f4       	brne	.+10     	; 0x15f0 <xQueueGetMutexHolder+0x1a>
			{
				pxReturn = ( void * ) xSemaphore->pxMutexHolder;
    15e6:	82 81       	ldd	r24, Z+2	; 0x02
    15e8:	93 81       	ldd	r25, Z+3	; 0x03
			else
			{
				pxReturn = NULL;
			}
		}
		taskEXIT_CRITICAL();
    15ea:	0f 90       	pop	r0
    15ec:	0f be       	out	0x3f, r0	; 63
		
		return pxReturn;
	}
    15ee:	08 95       	ret
			{
				pxReturn = ( void * ) xSemaphore->pxMutexHolder;
			}
			else
			{
				pxReturn = NULL;
    15f0:	80 e0       	ldi	r24, 0x00	; 0
    15f2:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    15f4:	0f 90       	pop	r0
    15f6:	0f be       	out	0x3f, r0	; 63
		
		return pxReturn;
	}
    15f8:	08 95       	ret

000015fa <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    15fa:	6f 92       	push	r6
    15fc:	7f 92       	push	r7
    15fe:	8f 92       	push	r8
    1600:	9f 92       	push	r9
    1602:	af 92       	push	r10
    1604:	bf 92       	push	r11
    1606:	cf 92       	push	r12
    1608:	df 92       	push	r13
    160a:	ef 92       	push	r14
    160c:	ff 92       	push	r15
    160e:	0f 93       	push	r16
    1610:	cf 93       	push	r28
    1612:	df 93       	push	r29
    1614:	cd b7       	in	r28, 0x3d	; 61
    1616:	de b7       	in	r29, 0x3e	; 62
    1618:	29 97       	sbiw	r28, 0x09	; 9
    161a:	0f b6       	in	r0, 0x3f	; 63
    161c:	f8 94       	cli
    161e:	de bf       	out	0x3e, r29	; 62
    1620:	0f be       	out	0x3f, r0	; 63
    1622:	cd bf       	out	0x3d, r28	; 61
    1624:	5c 01       	movw	r10, r24
    1626:	4b 01       	movw	r8, r22
    1628:	2e 83       	std	Y+6, r18	; 0x06
    162a:	3f 83       	std	Y+7, r19	; 0x07
    162c:	48 87       	std	Y+8, r20	; 0x08
    162e:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1630:	20 e0       	ldi	r18, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1632:	3c 01       	movw	r6, r24
    1634:	88 e0       	ldi	r24, 0x08	; 8
    1636:	68 0e       	add	r6, r24
    1638:	71 1c       	adc	r7, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    163a:	0f b6       	in	r0, 0x3f	; 63
    163c:	f8 94       	cli
    163e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1640:	f5 01       	movw	r30, r10
    1642:	96 8d       	ldd	r25, Z+30	; 0x1e
    1644:	87 8d       	ldd	r24, Z+31	; 0x1f
    1646:	98 17       	cp	r25, r24
    1648:	08 f4       	brcc	.+2      	; 0x164c <xQueueGenericSend+0x52>
    164a:	55 c0       	rjmp	.+170    	; 0x16f6 <xQueueGenericSend+0xfc>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    164c:	ce 80       	ldd	r12, Y+6	; 0x06
    164e:	df 80       	ldd	r13, Y+7	; 0x07
    1650:	e8 84       	ldd	r14, Y+8	; 0x08
    1652:	f9 84       	ldd	r15, Y+9	; 0x09
    1654:	cd 28       	or	r12, r13
    1656:	ce 28       	or	r12, r14
    1658:	cf 28       	or	r12, r15
    165a:	09 f4       	brne	.+2      	; 0x165e <xQueueGenericSend+0x64>
    165c:	6c c0       	rjmp	.+216    	; 0x1736 <xQueueGenericSend+0x13c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    165e:	22 23       	and	r18, r18
    1660:	61 f1       	breq	.+88     	; 0x16ba <xQueueGenericSend+0xc0>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    1662:	0f 90       	pop	r0
    1664:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1666:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    166a:	0f b6       	in	r0, 0x3f	; 63
    166c:	f8 94       	cli
    166e:	0f 92       	push	r0
    1670:	f5 01       	movw	r30, r10
    1672:	81 a1       	ldd	r24, Z+33	; 0x21
    1674:	8f 3f       	cpi	r24, 0xFF	; 255
    1676:	31 f1       	breq	.+76     	; 0x16c4 <xQueueGenericSend+0xca>
    1678:	f5 01       	movw	r30, r10
    167a:	82 a1       	ldd	r24, Z+34	; 0x22
    167c:	8f 3f       	cpi	r24, 0xFF	; 255
    167e:	39 f1       	breq	.+78     	; 0x16ce <xQueueGenericSend+0xd4>
    1680:	0f 90       	pop	r0
    1682:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1684:	be 01       	movw	r22, r28
    1686:	6a 5f       	subi	r22, 0xFA	; 250
    1688:	7f 4f       	sbci	r23, 0xFF	; 255
    168a:	ce 01       	movw	r24, r28
    168c:	01 96       	adiw	r24, 0x01	; 1
    168e:	0e 94 75 12 	call	0x24ea	; 0x24ea <xTaskCheckForTimeOut>
    1692:	81 11       	cpse	r24, r1
    1694:	54 c0       	rjmp	.+168    	; 0x173e <xQueueGenericSend+0x144>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1696:	0f b6       	in	r0, 0x3f	; 63
    1698:	f8 94       	cli
    169a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    169c:	f5 01       	movw	r30, r10
    169e:	96 8d       	ldd	r25, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    16a0:	0f 90       	pop	r0
    16a2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    16a4:	f5 01       	movw	r30, r10
    16a6:	87 8d       	ldd	r24, Z+31	; 0x1f
    16a8:	98 17       	cp	r25, r24
    16aa:	99 f0       	breq	.+38     	; 0x16d2 <xQueueGenericSend+0xd8>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    16ac:	c5 01       	movw	r24, r10
    16ae:	0e 94 34 0a 	call	0x1468	; 0x1468 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    16b2:	0e 94 9f 10 	call	0x213e	; 0x213e <xTaskResumeAll>
    16b6:	21 e0       	ldi	r18, 0x01	; 1
    16b8:	c0 cf       	rjmp	.-128    	; 0x163a <xQueueGenericSend+0x40>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    16ba:	ce 01       	movw	r24, r28
    16bc:	01 96       	adiw	r24, 0x01	; 1
    16be:	0e 94 64 12 	call	0x24c8	; 0x24c8 <vTaskSetTimeOutState>
    16c2:	cf cf       	rjmp	.-98     	; 0x1662 <xQueueGenericSend+0x68>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    16c4:	11 a2       	std	Z+33, r1	; 0x21
    16c6:	f5 01       	movw	r30, r10
    16c8:	82 a1       	ldd	r24, Z+34	; 0x22
    16ca:	8f 3f       	cpi	r24, 0xFF	; 255
    16cc:	c9 f6       	brne	.-78     	; 0x1680 <xQueueGenericSend+0x86>
    16ce:	12 a2       	std	Z+34, r1	; 0x22
    16d0:	d7 cf       	rjmp	.-82     	; 0x1680 <xQueueGenericSend+0x86>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    16d2:	4e 81       	ldd	r20, Y+6	; 0x06
    16d4:	5f 81       	ldd	r21, Y+7	; 0x07
    16d6:	68 85       	ldd	r22, Y+8	; 0x08
    16d8:	79 85       	ldd	r23, Y+9	; 0x09
    16da:	c3 01       	movw	r24, r6
    16dc:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    16e0:	c5 01       	movw	r24, r10
    16e2:	0e 94 34 0a 	call	0x1468	; 0x1468 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    16e6:	0e 94 9f 10 	call	0x213e	; 0x213e <xTaskResumeAll>
    16ea:	81 11       	cpse	r24, r1
    16ec:	e4 cf       	rjmp	.-56     	; 0x16b6 <xQueueGenericSend+0xbc>
				{
					portYIELD_WITHIN_API();
    16ee:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortYield>
    16f2:	21 e0       	ldi	r18, 0x01	; 1
    16f4:	a2 cf       	rjmp	.-188    	; 0x163a <xQueueGenericSend+0x40>
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    16f6:	40 2f       	mov	r20, r16
    16f8:	b4 01       	movw	r22, r8
    16fa:	c5 01       	movw	r24, r10
    16fc:	0e 94 c2 09 	call	0x1384	; 0x1384 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1700:	f5 01       	movw	r30, r10
    1702:	83 89       	ldd	r24, Z+19	; 0x13
    1704:	81 11       	cpse	r24, r1
    1706:	22 c0       	rjmp	.+68     	; 0x174c <xQueueGenericSend+0x152>
						takes care of that. */
						portYIELD_WITHIN_API();
					}
				}

				taskEXIT_CRITICAL();
    1708:	0f 90       	pop	r0
    170a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    170c:	81 e0       	ldi	r24, 0x01	; 1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    170e:	29 96       	adiw	r28, 0x09	; 9
    1710:	0f b6       	in	r0, 0x3f	; 63
    1712:	f8 94       	cli
    1714:	de bf       	out	0x3e, r29	; 62
    1716:	0f be       	out	0x3f, r0	; 63
    1718:	cd bf       	out	0x3d, r28	; 61
    171a:	df 91       	pop	r29
    171c:	cf 91       	pop	r28
    171e:	0f 91       	pop	r16
    1720:	ff 90       	pop	r15
    1722:	ef 90       	pop	r14
    1724:	df 90       	pop	r13
    1726:	cf 90       	pop	r12
    1728:	bf 90       	pop	r11
    172a:	af 90       	pop	r10
    172c:	9f 90       	pop	r9
    172e:	8f 90       	pop	r8
    1730:	7f 90       	pop	r7
    1732:	6f 90       	pop	r6
    1734:	08 95       	ret
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1736:	0f 90       	pop	r0
    1738:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    173a:	80 e0       	ldi	r24, 0x00	; 0
    173c:	e8 cf       	rjmp	.-48     	; 0x170e <xQueueGenericSend+0x114>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    173e:	c5 01       	movw	r24, r10
    1740:	0e 94 34 0a 	call	0x1468	; 0x1468 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1744:	0e 94 9f 10 	call	0x213e	; 0x213e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1748:	80 e0       	ldi	r24, 0x00	; 0
    174a:	e1 cf       	rjmp	.-62     	; 0x170e <xQueueGenericSend+0x114>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    174c:	c5 01       	movw	r24, r10
    174e:	43 96       	adiw	r24, 0x13	; 19
    1750:	0e 94 23 12 	call	0x2446	; 0x2446 <xTaskRemoveFromEventList>
    1754:	81 30       	cpi	r24, 0x01	; 1
    1756:	c1 f6       	brne	.-80     	; 0x1708 <xQueueGenericSend+0x10e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1758:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortYield>
    175c:	d5 cf       	rjmp	.-86     	; 0x1708 <xQueueGenericSend+0x10e>

0000175e <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    175e:	0f 93       	push	r16
    1760:	cf 93       	push	r28
    1762:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1764:	83 e2       	ldi	r24, 0x23	; 35
    1766:	90 e0       	ldi	r25, 0x00	; 0
    1768:	0e 94 04 08 	call	0x1008	; 0x1008 <pvPortMalloc>
    176c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    176e:	00 97       	sbiw	r24, 0x00	; 0
    1770:	01 f1       	breq	.+64     	; 0x17b2 <xQueueCreateMutex+0x54>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1772:	1b 82       	std	Y+3, r1	; 0x03
    1774:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1776:	19 82       	std	Y+1, r1	; 0x01
    1778:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    177a:	1d 82       	std	Y+5, r1	; 0x05
    177c:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    177e:	1f 82       	std	Y+7, r1	; 0x07
    1780:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1782:	1e 8e       	std	Y+30, r1	; 0x1e
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    1784:	81 e0       	ldi	r24, 0x01	; 1
    1786:	8f 8f       	std	Y+31, r24	; 0x1f
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    1788:	18 a2       	std	Y+32, r1	; 0x20
			pxNewQueue->xRxLock = queueUNLOCKED;
    178a:	8f ef       	ldi	r24, 0xFF	; 255
    178c:	89 a3       	std	Y+33, r24	; 0x21
			pxNewQueue->xTxLock = queueUNLOCKED;
    178e:	8a a3       	std	Y+34, r24	; 0x22
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1790:	ce 01       	movw	r24, r28
    1792:	08 96       	adiw	r24, 0x08	; 8
    1794:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1798:	ce 01       	movw	r24, r28
    179a:	43 96       	adiw	r24, 0x13	; 19
    179c:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    17a0:	00 e0       	ldi	r16, 0x00	; 0
    17a2:	20 e0       	ldi	r18, 0x00	; 0
    17a4:	30 e0       	ldi	r19, 0x00	; 0
    17a6:	a9 01       	movw	r20, r18
    17a8:	60 e0       	ldi	r22, 0x00	; 0
    17aa:	70 e0       	ldi	r23, 0x00	; 0
    17ac:	ce 01       	movw	r24, r28
    17ae:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    17b2:	ce 01       	movw	r24, r28
    17b4:	df 91       	pop	r29
    17b6:	cf 91       	pop	r28
    17b8:	0f 91       	pop	r16
    17ba:	08 95       	ret

000017bc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    17bc:	0f 93       	push	r16
    17be:	1f 93       	push	r17
    17c0:	cf 93       	push	r28
    17c2:	df 93       	push	r29
    17c4:	ec 01       	movw	r28, r24
    17c6:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    17c8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    17ca:	8f 8d       	ldd	r24, Y+31	; 0x1f
    17cc:	98 17       	cp	r25, r24
    17ce:	30 f0       	brcs	.+12     	; 0x17dc <xQueueGenericSendFromISR+0x20>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    17d0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    17d2:	df 91       	pop	r29
    17d4:	cf 91       	pop	r28
    17d6:	1f 91       	pop	r17
    17d8:	0f 91       	pop	r16
    17da:	08 95       	ret
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    17dc:	42 2f       	mov	r20, r18
    17de:	ce 01       	movw	r24, r28
    17e0:	0e 94 c2 09 	call	0x1384	; 0x1384 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    17e4:	8a a1       	ldd	r24, Y+34	; 0x22
    17e6:	8f 3f       	cpi	r24, 0xFF	; 255
    17e8:	41 f0       	breq	.+16     	; 0x17fa <xQueueGenericSendFromISR+0x3e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    17ea:	8f 5f       	subi	r24, 0xFF	; 255
    17ec:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    17ee:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    17f0:	df 91       	pop	r29
    17f2:	cf 91       	pop	r28
    17f4:	1f 91       	pop	r17
    17f6:	0f 91       	pop	r16
    17f8:	08 95       	ret

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17fa:	8b 89       	ldd	r24, Y+19	; 0x13
    17fc:	88 23       	and	r24, r24
    17fe:	b9 f3       	breq	.-18     	; 0x17ee <xQueueGenericSendFromISR+0x32>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1800:	ce 01       	movw	r24, r28
    1802:	43 96       	adiw	r24, 0x13	; 19
    1804:	0e 94 23 12 	call	0x2446	; 0x2446 <xTaskRemoveFromEventList>
    1808:	88 23       	and	r24, r24
    180a:	89 f3       	breq	.-30     	; 0x17ee <xQueueGenericSendFromISR+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    180c:	81 e0       	ldi	r24, 0x01	; 1
    180e:	f8 01       	movw	r30, r16
    1810:	80 83       	st	Z, r24
    1812:	df cf       	rjmp	.-66     	; 0x17d2 <xQueueGenericSendFromISR+0x16>

00001814 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1814:	af 92       	push	r10
    1816:	bf 92       	push	r11
    1818:	cf 92       	push	r12
    181a:	df 92       	push	r13
    181c:	ef 92       	push	r14
    181e:	ff 92       	push	r15
    1820:	0f 93       	push	r16
    1822:	cf 93       	push	r28
    1824:	df 93       	push	r29
    1826:	cd b7       	in	r28, 0x3d	; 61
    1828:	de b7       	in	r29, 0x3e	; 62
    182a:	29 97       	sbiw	r28, 0x09	; 9
    182c:	0f b6       	in	r0, 0x3f	; 63
    182e:	f8 94       	cli
    1830:	de bf       	out	0x3e, r29	; 62
    1832:	0f be       	out	0x3f, r0	; 63
    1834:	cd bf       	out	0x3d, r28	; 61
    1836:	7c 01       	movw	r14, r24
    1838:	6b 01       	movw	r12, r22
    183a:	2e 83       	std	Y+6, r18	; 0x06
    183c:	3f 83       	std	Y+7, r19	; 0x07
    183e:	48 87       	std	Y+8, r20	; 0x08
    1840:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1842:	90 e0       	ldi	r25, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1844:	57 01       	movw	r10, r14
    1846:	83 e1       	ldi	r24, 0x13	; 19
    1848:	a8 0e       	add	r10, r24
    184a:	b1 1c       	adc	r11, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    184c:	0f b6       	in	r0, 0x3f	; 63
    184e:	f8 94       	cli
    1850:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1852:	f7 01       	movw	r30, r14
    1854:	86 8d       	ldd	r24, Z+30	; 0x1e
    1856:	81 11       	cpse	r24, r1
    1858:	69 c0       	rjmp	.+210    	; 0x192c <xQueueGenericReceive+0x118>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    185a:	4e 81       	ldd	r20, Y+6	; 0x06
    185c:	5f 81       	ldd	r21, Y+7	; 0x07
    185e:	68 85       	ldd	r22, Y+8	; 0x08
    1860:	79 85       	ldd	r23, Y+9	; 0x09
    1862:	45 2b       	or	r20, r21
    1864:	46 2b       	or	r20, r22
    1866:	47 2b       	or	r20, r23
    1868:	09 f4       	brne	.+2      	; 0x186c <xQueueGenericReceive+0x58>
    186a:	7d c0       	rjmp	.+250    	; 0x1966 <xQueueGenericReceive+0x152>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    186c:	99 23       	and	r25, r25
    186e:	09 f4       	brne	.+2      	; 0x1872 <xQueueGenericReceive+0x5e>
    1870:	3e c0       	rjmp	.+124    	; 0x18ee <xQueueGenericReceive+0xda>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    1872:	0f 90       	pop	r0
    1874:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1876:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    187a:	0f b6       	in	r0, 0x3f	; 63
    187c:	f8 94       	cli
    187e:	0f 92       	push	r0
    1880:	f7 01       	movw	r30, r14
    1882:	81 a1       	ldd	r24, Z+33	; 0x21
    1884:	8f 3f       	cpi	r24, 0xFF	; 255
    1886:	09 f4       	brne	.+2      	; 0x188a <xQueueGenericReceive+0x76>
    1888:	3e c0       	rjmp	.+124    	; 0x1906 <xQueueGenericReceive+0xf2>
    188a:	f7 01       	movw	r30, r14
    188c:	82 a1       	ldd	r24, Z+34	; 0x22
    188e:	8f 3f       	cpi	r24, 0xFF	; 255
    1890:	09 f4       	brne	.+2      	; 0x1894 <xQueueGenericReceive+0x80>
    1892:	3f c0       	rjmp	.+126    	; 0x1912 <xQueueGenericReceive+0xfe>
    1894:	0f 90       	pop	r0
    1896:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1898:	be 01       	movw	r22, r28
    189a:	6a 5f       	subi	r22, 0xFA	; 250
    189c:	7f 4f       	sbci	r23, 0xFF	; 255
    189e:	ce 01       	movw	r24, r28
    18a0:	01 96       	adiw	r24, 0x01	; 1
    18a2:	0e 94 75 12 	call	0x24ea	; 0x24ea <xTaskCheckForTimeOut>
    18a6:	81 11       	cpse	r24, r1
    18a8:	71 c0       	rjmp	.+226    	; 0x198c <xQueueGenericReceive+0x178>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    18aa:	0f b6       	in	r0, 0x3f	; 63
    18ac:	f8 94       	cli
    18ae:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    18b0:	f7 01       	movw	r30, r14
    18b2:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    18b4:	0f 90       	pop	r0
    18b6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18b8:	81 11       	cpse	r24, r1
    18ba:	1e c0       	rjmp	.+60     	; 0x18f8 <xQueueGenericReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    18bc:	f7 01       	movw	r30, r14
    18be:	80 81       	ld	r24, Z
    18c0:	91 81       	ldd	r25, Z+1	; 0x01
    18c2:	89 2b       	or	r24, r25
    18c4:	41 f1       	breq	.+80     	; 0x1916 <xQueueGenericReceive+0x102>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18c6:	4e 81       	ldd	r20, Y+6	; 0x06
    18c8:	5f 81       	ldd	r21, Y+7	; 0x07
    18ca:	68 85       	ldd	r22, Y+8	; 0x08
    18cc:	79 85       	ldd	r23, Y+9	; 0x09
    18ce:	c5 01       	movw	r24, r10
    18d0:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18d4:	c7 01       	movw	r24, r14
    18d6:	0e 94 34 0a 	call	0x1468	; 0x1468 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18da:	0e 94 9f 10 	call	0x213e	; 0x213e <xTaskResumeAll>
    18de:	88 23       	and	r24, r24
    18e0:	11 f0       	breq	.+4      	; 0x18e6 <xQueueGenericReceive+0xd2>
    18e2:	91 e0       	ldi	r25, 0x01	; 1
    18e4:	b3 cf       	rjmp	.-154    	; 0x184c <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    18e6:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortYield>
    18ea:	91 e0       	ldi	r25, 0x01	; 1
    18ec:	af cf       	rjmp	.-162    	; 0x184c <xQueueGenericReceive+0x38>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    18ee:	ce 01       	movw	r24, r28
    18f0:	01 96       	adiw	r24, 0x01	; 1
    18f2:	0e 94 64 12 	call	0x24c8	; 0x24c8 <vTaskSetTimeOutState>
    18f6:	bd cf       	rjmp	.-134    	; 0x1872 <xQueueGenericReceive+0x5e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    18f8:	c7 01       	movw	r24, r14
    18fa:	0e 94 34 0a 	call	0x1468	; 0x1468 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18fe:	0e 94 9f 10 	call	0x213e	; 0x213e <xTaskResumeAll>
    1902:	91 e0       	ldi	r25, 0x01	; 1
    1904:	a3 cf       	rjmp	.-186    	; 0x184c <xQueueGenericReceive+0x38>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    1906:	11 a2       	std	Z+33, r1	; 0x21
    1908:	f7 01       	movw	r30, r14
    190a:	82 a1       	ldd	r24, Z+34	; 0x22
    190c:	8f 3f       	cpi	r24, 0xFF	; 255
    190e:	09 f0       	breq	.+2      	; 0x1912 <xQueueGenericReceive+0xfe>
    1910:	c1 cf       	rjmp	.-126    	; 0x1894 <xQueueGenericReceive+0x80>
    1912:	12 a2       	std	Z+34, r1	; 0x22
    1914:	bf cf       	rjmp	.-130    	; 0x1894 <xQueueGenericReceive+0x80>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						portENTER_CRITICAL();
    1916:	0f b6       	in	r0, 0x3f	; 63
    1918:	f8 94       	cli
    191a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    191c:	f7 01       	movw	r30, r14
    191e:	82 81       	ldd	r24, Z+2	; 0x02
    1920:	93 81       	ldd	r25, Z+3	; 0x03
    1922:	0e 94 06 13 	call	0x260c	; 0x260c <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1926:	0f 90       	pop	r0
    1928:	0f be       	out	0x3f, r0	; 63
    192a:	cd cf       	rjmp	.-102    	; 0x18c6 <xQueueGenericReceive+0xb2>
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    192c:	a6 80       	ldd	r10, Z+6	; 0x06
    192e:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1930:	b6 01       	movw	r22, r12
    1932:	c7 01       	movw	r24, r14
    1934:	0e 94 1a 0a 	call	0x1434	; 0x1434 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1938:	f7 01       	movw	r30, r14
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    193a:	01 11       	cpse	r16, r1
    193c:	2e c0       	rjmp	.+92     	; 0x199a <xQueueGenericReceive+0x186>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    193e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1940:	81 50       	subi	r24, 0x01	; 1
    1942:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1944:	80 81       	ld	r24, Z
    1946:	91 81       	ldd	r25, Z+1	; 0x01
    1948:	89 2b       	or	r24, r25
    194a:	b9 f1       	breq	.+110    	; 0x19ba <xQueueGenericReceive+0x1a6>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    194c:	f7 01       	movw	r30, r14
    194e:	80 85       	ldd	r24, Z+8	; 0x08
    1950:	88 23       	and	r24, r24
    1952:	41 f1       	breq	.+80     	; 0x19a4 <xQueueGenericReceive+0x190>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1954:	c7 01       	movw	r24, r14
    1956:	08 96       	adiw	r24, 0x08	; 8
    1958:	0e 94 23 12 	call	0x2446	; 0x2446 <xTaskRemoveFromEventList>
    195c:	81 30       	cpi	r24, 0x01	; 1
    195e:	11 f5       	brne	.+68     	; 0x19a4 <xQueueGenericReceive+0x190>
						{
							portYIELD_WITHIN_API();
    1960:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortYield>
    1964:	1f c0       	rjmp	.+62     	; 0x19a4 <xQueueGenericReceive+0x190>
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1966:	0f 90       	pop	r0
    1968:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    196a:	80 e0       	ldi	r24, 0x00	; 0
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    196c:	29 96       	adiw	r28, 0x09	; 9
    196e:	0f b6       	in	r0, 0x3f	; 63
    1970:	f8 94       	cli
    1972:	de bf       	out	0x3e, r29	; 62
    1974:	0f be       	out	0x3f, r0	; 63
    1976:	cd bf       	out	0x3d, r28	; 61
    1978:	df 91       	pop	r29
    197a:	cf 91       	pop	r28
    197c:	0f 91       	pop	r16
    197e:	ff 90       	pop	r15
    1980:	ef 90       	pop	r14
    1982:	df 90       	pop	r13
    1984:	cf 90       	pop	r12
    1986:	bf 90       	pop	r11
    1988:	af 90       	pop	r10
    198a:	08 95       	ret
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    198c:	c7 01       	movw	r24, r14
    198e:	0e 94 34 0a 	call	0x1468	; 0x1468 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1992:	0e 94 9f 10 	call	0x213e	; 0x213e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1996:	80 e0       	ldi	r24, 0x00	; 0
    1998:	e9 cf       	rjmp	.-46     	; 0x196c <xQueueGenericReceive+0x158>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    199a:	b7 82       	std	Z+7, r11	; 0x07
    199c:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    199e:	83 89       	ldd	r24, Z+19	; 0x13
    19a0:	81 11       	cpse	r24, r1
    19a2:	04 c0       	rjmp	.+8      	; 0x19ac <xQueueGenericReceive+0x198>
						}
					}

				}

				taskEXIT_CRITICAL();
    19a4:	0f 90       	pop	r0
    19a6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    19a8:	81 e0       	ldi	r24, 0x01	; 1
    19aa:	e0 cf       	rjmp	.-64     	; 0x196c <xQueueGenericReceive+0x158>
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19ac:	c7 01       	movw	r24, r14
    19ae:	43 96       	adiw	r24, 0x13	; 19
    19b0:	0e 94 23 12 	call	0x2446	; 0x2446 <xTaskRemoveFromEventList>
    19b4:	88 23       	and	r24, r24
    19b6:	b1 f3       	breq	.-20     	; 0x19a4 <xQueueGenericReceive+0x190>
    19b8:	d3 cf       	rjmp	.-90     	; 0x1960 <xQueueGenericReceive+0x14c>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    19ba:	0e 94 01 13 	call	0x2602	; 0x2602 <xTaskGetCurrentTaskHandle>
    19be:	f7 01       	movw	r30, r14
    19c0:	93 83       	std	Z+3, r25	; 0x03
    19c2:	82 83       	std	Z+2, r24	; 0x02
    19c4:	c3 cf       	rjmp	.-122    	; 0x194c <xQueueGenericReceive+0x138>

000019c6 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    19c6:	0f 93       	push	r16
    19c8:	1f 93       	push	r17
    19ca:	cf 93       	push	r28
    19cc:	df 93       	push	r29
    19ce:	00 d0       	rcall	.+0      	; 0x19d0 <xQueueReceiveFromISR+0xa>
    19d0:	cd b7       	in	r28, 0x3d	; 61
    19d2:	de b7       	in	r29, 0x3e	; 62
    19d4:	8c 01       	movw	r16, r24
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    19d6:	fc 01       	movw	r30, r24
    19d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    19da:	81 11       	cpse	r24, r1
    19dc:	08 c0       	rjmp	.+16     	; 0x19ee <xQueueReceiveFromISR+0x28>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    19de:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19e0:	0f 90       	pop	r0
    19e2:	0f 90       	pop	r0
    19e4:	df 91       	pop	r29
    19e6:	cf 91       	pop	r28
    19e8:	1f 91       	pop	r17
    19ea:	0f 91       	pop	r16
    19ec:	08 95       	ret
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19ee:	c8 01       	movw	r24, r16
    19f0:	49 83       	std	Y+1, r20	; 0x01
    19f2:	5a 83       	std	Y+2, r21	; 0x02
    19f4:	0e 94 1a 0a 	call	0x1434	; 0x1434 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    19f8:	f8 01       	movw	r30, r16
    19fa:	86 8d       	ldd	r24, Z+30	; 0x1e
    19fc:	81 50       	subi	r24, 0x01	; 1
    19fe:	86 8f       	std	Z+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1a00:	81 a1       	ldd	r24, Z+33	; 0x21
    1a02:	49 81       	ldd	r20, Y+1	; 0x01
    1a04:	5a 81       	ldd	r21, Y+2	; 0x02
    1a06:	8f 3f       	cpi	r24, 0xFF	; 255
    1a08:	59 f0       	breq	.+22     	; 0x1a20 <xQueueReceiveFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1a0a:	8f 5f       	subi	r24, 0xFF	; 255
    1a0c:	f8 01       	movw	r30, r16
    1a0e:	81 a3       	std	Z+33, r24	; 0x21
			}

			xReturn = pdPASS;
    1a10:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a12:	0f 90       	pop	r0
    1a14:	0f 90       	pop	r0
    1a16:	df 91       	pop	r29
    1a18:	cf 91       	pop	r28
    1a1a:	1f 91       	pop	r17
    1a1c:	0f 91       	pop	r16
    1a1e:	08 95       	ret
			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a20:	80 85       	ldd	r24, Z+8	; 0x08
    1a22:	88 23       	and	r24, r24
    1a24:	a9 f3       	breq	.-22     	; 0x1a10 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a26:	c8 01       	movw	r24, r16
    1a28:	08 96       	adiw	r24, 0x08	; 8
    1a2a:	49 83       	std	Y+1, r20	; 0x01
    1a2c:	5a 83       	std	Y+2, r21	; 0x02
    1a2e:	0e 94 23 12 	call	0x2446	; 0x2446 <xTaskRemoveFromEventList>
    1a32:	49 81       	ldd	r20, Y+1	; 0x01
    1a34:	5a 81       	ldd	r21, Y+2	; 0x02
    1a36:	88 23       	and	r24, r24
    1a38:	59 f3       	breq	.-42     	; 0x1a10 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
    1a3c:	fa 01       	movw	r30, r20
    1a3e:	80 83       	st	Z, r24
    1a40:	cf cf       	rjmp	.-98     	; 0x19e0 <xQueueReceiveFromISR+0x1a>

00001a42 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a42:	0f b6       	in	r0, 0x3f	; 63
    1a44:	f8 94       	cli
    1a46:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1a48:	fc 01       	movw	r30, r24
    1a4a:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1a4c:	0f 90       	pop	r0
    1a4e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1a50:	08 95       	ret

00001a52 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1a52:	fc 01       	movw	r30, r24
    1a54:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    1a56:	08 95       	ret

00001a58 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1a58:	cf 93       	push	r28
    1a5a:	df 93       	push	r29
    1a5c:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1a5e:	88 81       	ld	r24, Y
    1a60:	99 81       	ldd	r25, Y+1	; 0x01
    1a62:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortFree>
	vPortFree( pxQueue );
    1a66:	ce 01       	movw	r24, r28
}
    1a68:	df 91       	pop	r29
    1a6a:	cf 91       	pop	r28
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
	vPortFree( pxQueue );
    1a6c:	0c 94 2c 08 	jmp	0x1058	; 0x1058 <vPortFree>

00001a70 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1a70:	fc 01       	movw	r30, r24
    1a72:	96 8d       	ldd	r25, Z+30	; 0x1e
    1a74:	81 e0       	ldi	r24, 0x01	; 1
    1a76:	91 11       	cpse	r25, r1
    1a78:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1a7a:	08 95       	ret

00001a7c <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1a7c:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1a7e:	26 8d       	ldd	r18, Z+30	; 0x1e
    1a80:	81 e0       	ldi	r24, 0x01	; 1
    1a82:	97 8d       	ldd	r25, Z+31	; 0x1f
    1a84:	29 13       	cpse	r18, r25
    1a86:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1a88:	08 95       	ret

00001a8a <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1a8a:	80 91 50 0c 	lds	r24, 0x0C50
    1a8e:	82 30       	cpi	r24, 0x02	; 2
    1a90:	e0 f3       	brcs	.-8      	; 0x1a8a <prvIdleTask>
			{
				taskYIELD();
    1a92:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortYield>
    1a96:	f9 cf       	rjmp	.-14     	; 0x1a8a <prvIdleTask>

00001a98 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1a98:	cf 92       	push	r12
    1a9a:	df 92       	push	r13
    1a9c:	ef 92       	push	r14
    1a9e:	ff 92       	push	r15
    1aa0:	6b 01       	movw	r12, r22
    1aa2:	7c 01       	movw	r14, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1aa4:	e0 91 1a 0c 	lds	r30, 0x0C1A
    1aa8:	f0 91 1b 0c 	lds	r31, 0x0C1B
    1aac:	62 83       	std	Z+2, r22	; 0x02
    1aae:	73 83       	std	Z+3, r23	; 0x03
    1ab0:	84 83       	std	Z+4, r24	; 0x04
    1ab2:	95 83       	std	Z+5, r25	; 0x05

	if( xTimeToWake < xTickCount )
    1ab4:	80 91 24 0c 	lds	r24, 0x0C24
    1ab8:	90 91 25 0c 	lds	r25, 0x0C25
    1abc:	a0 91 26 0c 	lds	r26, 0x0C26
    1ac0:	b0 91 27 0c 	lds	r27, 0x0C27
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ac4:	60 91 1a 0c 	lds	r22, 0x0C1A
    1ac8:	70 91 1b 0c 	lds	r23, 0x0C1B
static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
    1acc:	c8 16       	cp	r12, r24
    1ace:	d9 06       	cpc	r13, r25
    1ad0:	ea 06       	cpc	r14, r26
    1ad2:	fb 06       	cpc	r15, r27
    1ad4:	10 f1       	brcs	.+68     	; 0x1b1a <prvAddCurrentTaskToDelayedList+0x82>
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ad6:	80 91 38 0c 	lds	r24, 0x0C38
    1ada:	90 91 39 0c 	lds	r25, 0x0C39
    1ade:	6e 5f       	subi	r22, 0xFE	; 254
    1ae0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ae2:	0e 94 58 14 	call	0x28b0	; 0x28b0 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1ae6:	80 91 01 01 	lds	r24, 0x0101
    1aea:	90 91 02 01 	lds	r25, 0x0102
    1aee:	a0 91 03 01 	lds	r26, 0x0103
    1af2:	b0 91 04 01 	lds	r27, 0x0104
    1af6:	c8 16       	cp	r12, r24
    1af8:	d9 06       	cpc	r13, r25
    1afa:	ea 06       	cpc	r14, r26
    1afc:	fb 06       	cpc	r15, r27
    1afe:	40 f4       	brcc	.+16     	; 0x1b10 <prvAddCurrentTaskToDelayedList+0x78>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1b00:	c0 92 01 01 	sts	0x0101, r12
    1b04:	d0 92 02 01 	sts	0x0102, r13
    1b08:	e0 92 03 01 	sts	0x0103, r14
    1b0c:	f0 92 04 01 	sts	0x0104, r15
		}
	}
}
    1b10:	ff 90       	pop	r15
    1b12:	ef 90       	pop	r14
    1b14:	df 90       	pop	r13
    1b16:	cf 90       	pop	r12
    1b18:	08 95       	ret
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b1a:	80 91 36 0c 	lds	r24, 0x0C36
    1b1e:	90 91 37 0c 	lds	r25, 0x0C37
    1b22:	6e 5f       	subi	r22, 0xFE	; 254
    1b24:	7f 4f       	sbci	r23, 0xFF	; 255
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
    1b26:	ff 90       	pop	r15
    1b28:	ef 90       	pop	r14
    1b2a:	df 90       	pop	r13
    1b2c:	cf 90       	pop	r12
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b2e:	0c 94 58 14 	jmp	0x28b0	; 0x28b0 <vListInsert>

00001b32 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1b32:	5f 92       	push	r5
    1b34:	6f 92       	push	r6
    1b36:	7f 92       	push	r7
    1b38:	8f 92       	push	r8
    1b3a:	9f 92       	push	r9
    1b3c:	af 92       	push	r10
    1b3e:	bf 92       	push	r11
    1b40:	cf 92       	push	r12
    1b42:	df 92       	push	r13
    1b44:	ef 92       	push	r14
    1b46:	ff 92       	push	r15
    1b48:	0f 93       	push	r16
    1b4a:	1f 93       	push	r17
    1b4c:	cf 93       	push	r28
    1b4e:	df 93       	push	r29
    1b50:	5c 01       	movw	r10, r24
    1b52:	4b 01       	movw	r8, r22
    1b54:	ea 01       	movw	r28, r20
    1b56:	39 01       	movw	r6, r18
    1b58:	50 2e       	mov	r5, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1b5a:	88 e2       	ldi	r24, 0x28	; 40
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	0e 94 04 08 	call	0x1008	; 0x1008 <pvPortMalloc>
    1b62:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1b64:	00 97       	sbiw	r24, 0x00	; 0
    1b66:	09 f4       	brne	.+2      	; 0x1b6a <xTaskGenericCreate+0x38>
    1b68:	ea c0       	rjmp	.+468    	; 0x1d3e <xTaskGenericCreate+0x20c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1b6a:	c1 14       	cp	r12, r1
    1b6c:	d1 04       	cpc	r13, r1
    1b6e:	09 f4       	brne	.+2      	; 0x1b72 <xTaskGenericCreate+0x40>
    1b70:	da c0       	rjmp	.+436    	; 0x1d26 <xTaskGenericCreate+0x1f4>
    1b72:	fc 01       	movw	r30, r24
    1b74:	d4 8e       	std	Z+28, r13	; 0x1c
    1b76:	c3 8e       	std	Z+27, r12	; 0x1b
    1b78:	c6 01       	movw	r24, r12
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1b7a:	ae 01       	movw	r20, r28
    1b7c:	61 e1       	ldi	r22, 0x11	; 17
    1b7e:	70 e0       	ldi	r23, 0x00	; 0
    1b80:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1b84:	21 97       	sbiw	r28, 0x01	; 1
    1b86:	f8 01       	movw	r30, r16
    1b88:	c3 8c       	ldd	r12, Z+27	; 0x1b
    1b8a:	d4 8c       	ldd	r13, Z+28	; 0x1c
    1b8c:	cc 0e       	add	r12, r28
    1b8e:	dd 1e       	adc	r13, r29
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1b90:	4a e0       	ldi	r20, 0x0A	; 10
    1b92:	50 e0       	ldi	r21, 0x00	; 0
    1b94:	b4 01       	movw	r22, r8
    1b96:	c8 01       	movw	r24, r16
    1b98:	4d 96       	adiw	r24, 0x1d	; 29
    1b9a:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1b9e:	f8 01       	movw	r30, r16
    1ba0:	16 a2       	std	Z+38, r1	; 0x26
    1ba2:	95 2c       	mov	r9, r5
    1ba4:	f3 e0       	ldi	r31, 0x03	; 3
    1ba6:	f5 15       	cp	r31, r5
    1ba8:	08 f4       	brcc	.+2      	; 0x1bac <xTaskGenericCreate+0x7a>
    1baa:	84 c0       	rjmp	.+264    	; 0x1cb4 <xTaskGenericCreate+0x182>
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1bac:	f8 01       	movw	r30, r16
    1bae:	92 8e       	std	Z+26, r9	; 0x1a
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    1bb0:	97 a2       	std	Z+39, r9	; 0x27
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1bb2:	e8 01       	movw	r28, r16
    1bb4:	22 96       	adiw	r28, 0x02	; 2
    1bb6:	ce 01       	movw	r24, r28
    1bb8:	0e 94 31 14 	call	0x2862	; 0x2862 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1bbc:	c8 01       	movw	r24, r16
    1bbe:	0e 96       	adiw	r24, 0x0e	; 14
    1bc0:	0e 94 31 14 	call	0x2862	; 0x2862 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1bc4:	f8 01       	movw	r30, r16
    1bc6:	13 87       	std	Z+11, r17	; 0x0b
    1bc8:	02 87       	std	Z+10, r16	; 0x0a

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1bca:	84 e0       	ldi	r24, 0x04	; 4
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
    1bce:	a0 e0       	ldi	r26, 0x00	; 0
    1bd0:	b0 e0       	ldi	r27, 0x00	; 0
    1bd2:	89 19       	sub	r24, r9
    1bd4:	91 09       	sbc	r25, r1
    1bd6:	a1 09       	sbc	r26, r1
    1bd8:	b1 09       	sbc	r27, r1
    1bda:	86 87       	std	Z+14, r24	; 0x0e
    1bdc:	97 87       	std	Z+15, r25	; 0x0f
    1bde:	a0 8b       	std	Z+16, r26	; 0x10
    1be0:	b1 8b       	std	Z+17, r27	; 0x11
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1be2:	17 8b       	std	Z+23, r17	; 0x17
    1be4:	06 8b       	std	Z+22, r16	; 0x16
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1be6:	a3 01       	movw	r20, r6
    1be8:	b5 01       	movw	r22, r10
    1bea:	c6 01       	movw	r24, r12
    1bec:	0e 94 3b 08 	call	0x1076	; 0x1076 <pxPortInitialiseStack>
    1bf0:	f8 01       	movw	r30, r16
    1bf2:	91 83       	std	Z+1, r25	; 0x01
    1bf4:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1bf6:	e1 14       	cp	r14, r1
    1bf8:	f1 04       	cpc	r15, r1
    1bfa:	19 f0       	breq	.+6      	; 0x1c02 <xTaskGenericCreate+0xd0>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1bfc:	f7 01       	movw	r30, r14
    1bfe:	11 83       	std	Z+1, r17	; 0x01
    1c00:	00 83       	st	Z, r16
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1c02:	0f b6       	in	r0, 0x3f	; 63
    1c04:	f8 94       	cli
    1c06:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1c08:	80 91 28 0c 	lds	r24, 0x0C28
    1c0c:	8f 5f       	subi	r24, 0xFF	; 255
    1c0e:	80 93 28 0c 	sts	0x0C28, r24
			if( pxCurrentTCB == NULL )
    1c12:	80 91 1a 0c 	lds	r24, 0x0C1A
    1c16:	90 91 1b 0c 	lds	r25, 0x0C1B
    1c1a:	89 2b       	or	r24, r25
    1c1c:	09 f4       	brne	.+2      	; 0x1c20 <xTaskGenericCreate+0xee>
    1c1e:	51 c0       	rjmp	.+162    	; 0x1cc2 <xTaskGenericCreate+0x190>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1c20:	80 91 21 0c 	lds	r24, 0x0C21
    1c24:	81 11       	cpse	r24, r1
    1c26:	0b c0       	rjmp	.+22     	; 0x1c3e <xTaskGenericCreate+0x10c>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1c28:	e0 91 1a 0c 	lds	r30, 0x0C1A
    1c2c:	f0 91 1b 0c 	lds	r31, 0x0C1B
    1c30:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c32:	58 16       	cp	r5, r24
    1c34:	20 f0       	brcs	.+8      	; 0x1c3e <xTaskGenericCreate+0x10c>
					{
						pxCurrentTCB = pxNewTCB;
    1c36:	10 93 1b 0c 	sts	0x0C1B, r17
    1c3a:	00 93 1a 0c 	sts	0x0C1A, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1c3e:	f8 01       	movw	r30, r16
    1c40:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c42:	90 91 23 0c 	lds	r25, 0x0C23
    1c46:	98 17       	cp	r25, r24
    1c48:	10 f4       	brcc	.+4      	; 0x1c4e <xTaskGenericCreate+0x11c>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1c4a:	80 93 23 0c 	sts	0x0C23, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1c4e:	90 91 1c 0c 	lds	r25, 0x0C1C
    1c52:	9f 5f       	subi	r25, 0xFF	; 255
    1c54:	90 93 1c 0c 	sts	0x0C1C, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    1c58:	90 91 22 0c 	lds	r25, 0x0C22
    1c5c:	98 17       	cp	r25, r24
    1c5e:	38 f1       	brcs	.+78     	; 0x1cae <xTaskGenericCreate+0x17c>
    1c60:	fb e0       	ldi	r31, 0x0B	; 11
    1c62:	8f 9f       	mul	r24, r31
    1c64:	c0 01       	movw	r24, r0
    1c66:	11 24       	eor	r1, r1
    1c68:	be 01       	movw	r22, r28
    1c6a:	80 5b       	subi	r24, 0xB0	; 176
    1c6c:	93 4f       	sbci	r25, 0xF3	; 243
    1c6e:	0e 94 35 14 	call	0x286a	; 0x286a <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1c72:	0f 90       	pop	r0
    1c74:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1c76:	80 91 21 0c 	lds	r24, 0x0C21
    1c7a:	88 23       	and	r24, r24
    1c7c:	39 f0       	breq	.+14     	; 0x1c8c <xTaskGenericCreate+0x15a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1c7e:	e0 91 1a 0c 	lds	r30, 0x0C1A
    1c82:	f0 91 1b 0c 	lds	r31, 0x0C1B
    1c86:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c88:	85 15       	cp	r24, r5
    1c8a:	b8 f0       	brcs	.+46     	; 0x1cba <xTaskGenericCreate+0x188>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1c8e:	df 91       	pop	r29
    1c90:	cf 91       	pop	r28
    1c92:	1f 91       	pop	r17
    1c94:	0f 91       	pop	r16
    1c96:	ff 90       	pop	r15
    1c98:	ef 90       	pop	r14
    1c9a:	df 90       	pop	r13
    1c9c:	cf 90       	pop	r12
    1c9e:	bf 90       	pop	r11
    1ca0:	af 90       	pop	r10
    1ca2:	9f 90       	pop	r9
    1ca4:	8f 90       	pop	r8
    1ca6:	7f 90       	pop	r7
    1ca8:	6f 90       	pop	r6
    1caa:	5f 90       	pop	r5
    1cac:	08 95       	ret
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );
    1cae:	80 93 22 0c 	sts	0x0C22, r24
    1cb2:	d6 cf       	rjmp	.-84     	; 0x1c60 <xTaskGenericCreate+0x12e>
    1cb4:	83 e0       	ldi	r24, 0x03	; 3
    1cb6:	98 2e       	mov	r9, r24
    1cb8:	79 cf       	rjmp	.-270    	; 0x1bac <xTaskGenericCreate+0x7a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				portYIELD_WITHIN_API();
    1cba:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	e6 cf       	rjmp	.-52     	; 0x1c8e <xTaskGenericCreate+0x15c>
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1cc2:	10 93 1b 0c 	sts	0x0C1B, r17
    1cc6:	00 93 1a 0c 	sts	0x0C1A, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1cca:	80 91 28 0c 	lds	r24, 0x0C28
    1cce:	81 30       	cpi	r24, 0x01	; 1
    1cd0:	09 f0       	breq	.+2      	; 0x1cd4 <xTaskGenericCreate+0x1a2>
    1cd2:	b5 cf       	rjmp	.-150    	; 0x1c3e <xTaskGenericCreate+0x10c>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1cd4:	80 e5       	ldi	r24, 0x50	; 80
    1cd6:	9c e0       	ldi	r25, 0x0C	; 12
    1cd8:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>
    1cdc:	8b e5       	ldi	r24, 0x5B	; 91
    1cde:	9c e0       	ldi	r25, 0x0C	; 12
    1ce0:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>
    1ce4:	86 e6       	ldi	r24, 0x66	; 102
    1ce6:	9c e0       	ldi	r25, 0x0C	; 12
    1ce8:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>
    1cec:	81 e7       	ldi	r24, 0x71	; 113
    1cee:	9c e0       	ldi	r25, 0x0C	; 12
    1cf0:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1cf4:	85 e4       	ldi	r24, 0x45	; 69
    1cf6:	9c e0       	ldi	r25, 0x0C	; 12
    1cf8:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1cfc:	8a e3       	ldi	r24, 0x3A	; 58
    1cfe:	9c e0       	ldi	r25, 0x0C	; 12
    1d00:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1d04:	8b e2       	ldi	r24, 0x2B	; 43
    1d06:	9c e0       	ldi	r25, 0x0C	; 12
    1d08:	0e 94 20 14 	call	0x2840	; 0x2840 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1d0c:	85 e4       	ldi	r24, 0x45	; 69
    1d0e:	9c e0       	ldi	r25, 0x0C	; 12
    1d10:	90 93 39 0c 	sts	0x0C39, r25
    1d14:	80 93 38 0c 	sts	0x0C38, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1d18:	8a e3       	ldi	r24, 0x3A	; 58
    1d1a:	9c e0       	ldi	r25, 0x0C	; 12
    1d1c:	90 93 37 0c 	sts	0x0C37, r25
    1d20:	80 93 36 0c 	sts	0x0C36, r24
    1d24:	8c cf       	rjmp	.-232    	; 0x1c3e <xTaskGenericCreate+0x10c>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1d26:	ce 01       	movw	r24, r28
    1d28:	0e 94 04 08 	call	0x1008	; 0x1008 <pvPortMalloc>
    1d2c:	f8 01       	movw	r30, r16
    1d2e:	94 8f       	std	Z+28, r25	; 0x1c
    1d30:	83 8f       	std	Z+27, r24	; 0x1b

		if( pxNewTCB->pxStack == NULL )
    1d32:	00 97       	sbiw	r24, 0x00	; 0
    1d34:	09 f0       	breq	.+2      	; 0x1d38 <xTaskGenericCreate+0x206>
    1d36:	21 cf       	rjmp	.-446    	; 0x1b7a <xTaskGenericCreate+0x48>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1d38:	c8 01       	movw	r24, r16
    1d3a:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d3e:	8f ef       	ldi	r24, 0xFF	; 255
    1d40:	a6 cf       	rjmp	.-180    	; 0x1c8e <xTaskGenericCreate+0x15c>

00001d42 <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
    1d42:	0f b6       	in	r0, 0x3f	; 63
    1d44:	f8 94       	cli
    1d46:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1d48:	00 97       	sbiw	r24, 0x00	; 0
    1d4a:	29 f0       	breq	.+10     	; 0x1d56 <uxTaskPriorityGet+0x14>
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1d4c:	0f 90       	pop	r0
    1d4e:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1d50:	fc 01       	movw	r30, r24
    1d52:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d54:	08 95       	ret

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1d56:	80 91 1a 0c 	lds	r24, 0x0C1A
    1d5a:	90 91 1b 0c 	lds	r25, 0x0C1B
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1d5e:	0f 90       	pop	r0
    1d60:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1d62:	fc 01       	movw	r30, r24
    1d64:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d66:	08 95       	ret

00001d68 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    1d68:	ef 92       	push	r14
    1d6a:	ff 92       	push	r15
    1d6c:	1f 93       	push	r17
    1d6e:	cf 93       	push	r28
    1d70:	df 93       	push	r29
    1d72:	ec 01       	movw	r28, r24
    1d74:	e6 2f       	mov	r30, r22
    1d76:	64 30       	cpi	r22, 0x04	; 4
    1d78:	08 f0       	brcs	.+2      	; 0x1d7c <vTaskPrioritySet+0x14>
    1d7a:	e3 e0       	ldi	r30, 0x03	; 3
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
		}

		taskENTER_CRITICAL();
    1d7c:	0f b6       	in	r0, 0x3f	; 63
    1d7e:	f8 94       	cli
    1d80:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    1d82:	80 91 1a 0c 	lds	r24, 0x0C1A
    1d86:	90 91 1b 0c 	lds	r25, 0x0C1B
    1d8a:	c8 17       	cp	r28, r24
    1d8c:	d9 07       	cpc	r29, r25
    1d8e:	d9 f1       	breq	.+118    	; 0x1e06 <vTaskPrioritySet+0x9e>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1d90:	20 97       	sbiw	r28, 0x00	; 0
    1d92:	c9 f1       	breq	.+114    	; 0x1e06 <vTaskPrioritySet+0x9e>
    1d94:	9e 01       	movw	r18, r28

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
    1d96:	8f a1       	ldd	r24, Y+39	; 0x27
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    1d98:	8e 17       	cp	r24, r30
    1d9a:	11 f1       	breq	.+68     	; 0x1de0 <vTaskPrioritySet+0x78>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
				{
					if( pxTask != NULL )
    1d9c:	11 e0       	ldi	r17, 0x01	; 1

			if( uxCurrentPriority != uxNewPriority )
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    1d9e:	8e 17       	cp	r24, r30
    1da0:	38 f5       	brcc	.+78     	; 0x1df0 <vTaskPrioritySet+0x88>
				{
					if( pxTask != NULL )
    1da2:	23 2b       	or	r18, r19
    1da4:	39 f1       	breq	.+78     	; 0x1df4 <vTaskPrioritySet+0x8c>

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1da6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1da8:	89 17       	cp	r24, r25
    1daa:	41 f1       	breq	.+80     	; 0x1dfc <vTaskPrioritySet+0x94>
					{
						pxTCB->uxPriority = uxNewPriority;
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    1dac:	ef a3       	std	Y+39, r30	; 0x27
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    1dae:	44 e0       	ldi	r20, 0x04	; 4
    1db0:	50 e0       	ldi	r21, 0x00	; 0
    1db2:	60 e0       	ldi	r22, 0x00	; 0
    1db4:	70 e0       	ldi	r23, 0x00	; 0
    1db6:	4e 1b       	sub	r20, r30
    1db8:	51 09       	sbc	r21, r1
    1dba:	61 09       	sbc	r22, r1
    1dbc:	71 09       	sbc	r23, r1
    1dbe:	4e 87       	std	Y+14, r20	; 0x0e
    1dc0:	5f 87       	std	Y+15, r21	; 0x0f
    1dc2:	68 8b       	std	Y+16, r22	; 0x10
    1dc4:	79 8b       	std	Y+17, r23	; 0x11

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    1dc6:	2b e0       	ldi	r18, 0x0B	; 11
    1dc8:	82 9f       	mul	r24, r18
    1dca:	c0 01       	movw	r24, r0
    1dcc:	11 24       	eor	r1, r1
    1dce:	80 5b       	subi	r24, 0xB0	; 176
    1dd0:	93 4f       	sbci	r25, 0xF3	; 243
    1dd2:	2c 85       	ldd	r18, Y+12	; 0x0c
    1dd4:	3d 85       	ldd	r19, Y+13	; 0x0d
    1dd6:	28 17       	cp	r18, r24
    1dd8:	39 07       	cpc	r19, r25
    1dda:	e1 f0       	breq	.+56     	; 0x1e14 <vTaskPrioritySet+0xac>
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
				}

				if( xYieldRequired == pdTRUE )
    1ddc:	11 30       	cpi	r17, 0x01	; 1
    1dde:	81 f0       	breq	.+32     	; 0x1e00 <vTaskPrioritySet+0x98>
				{
					portYIELD_WITHIN_API();
				}
			}
		}
		taskEXIT_CRITICAL();
    1de0:	0f 90       	pop	r0
    1de2:	0f be       	out	0x3f, r0	; 63
	}
    1de4:	df 91       	pop	r29
    1de6:	cf 91       	pop	r28
    1de8:	1f 91       	pop	r17
    1dea:	ff 90       	pop	r15
    1dec:	ef 90       	pop	r14
    1dee:	08 95       	ret
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
					}
				}
				else if( pxTask == NULL )
    1df0:	23 2b       	or	r18, r19
    1df2:	c9 f2       	breq	.-78     	; 0x1da6 <vTaskPrioritySet+0x3e>
    1df4:	10 e0       	ldi	r17, 0x00	; 0

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1df6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1df8:	89 13       	cpse	r24, r25
    1dfa:	d8 cf       	rjmp	.-80     	; 0x1dac <vTaskPrioritySet+0x44>
					{
						pxTCB->uxPriority = uxNewPriority;
    1dfc:	ea 8f       	std	Y+26, r30	; 0x1a
    1dfe:	d6 cf       	rjmp	.-84     	; 0x1dac <vTaskPrioritySet+0x44>
					prvAddTaskToReadyQueue( pxTCB );
				}

				if( xYieldRequired == pdTRUE )
				{
					portYIELD_WITHIN_API();
    1e00:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortYield>
    1e04:	ed cf       	rjmp	.-38     	; 0x1de0 <vTaskPrioritySet+0x78>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1e06:	c0 91 1a 0c 	lds	r28, 0x0C1A
    1e0a:	d0 91 1b 0c 	lds	r29, 0x0C1B
    1e0e:	20 e0       	ldi	r18, 0x00	; 0
    1e10:	30 e0       	ldi	r19, 0x00	; 0
    1e12:	c1 cf       	rjmp	.-126    	; 0x1d96 <vTaskPrioritySet+0x2e>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    1e14:	7e 01       	movw	r14, r28
    1e16:	82 e0       	ldi	r24, 0x02	; 2
    1e18:	e8 0e       	add	r14, r24
    1e1a:	f1 1c       	adc	r15, r1
    1e1c:	c7 01       	movw	r24, r14
    1e1e:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1e22:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e24:	90 91 22 0c 	lds	r25, 0x0C22
    1e28:	98 17       	cp	r25, r24
    1e2a:	10 f4       	brcc	.+4      	; 0x1e30 <vTaskPrioritySet+0xc8>
    1e2c:	80 93 22 0c 	sts	0x0C22, r24
    1e30:	2b e0       	ldi	r18, 0x0B	; 11
    1e32:	82 9f       	mul	r24, r18
    1e34:	c0 01       	movw	r24, r0
    1e36:	11 24       	eor	r1, r1
    1e38:	b7 01       	movw	r22, r14
    1e3a:	80 5b       	subi	r24, 0xB0	; 176
    1e3c:	93 4f       	sbci	r25, 0xF3	; 243
    1e3e:	0e 94 35 14 	call	0x286a	; 0x286a <vListInsertEnd>
    1e42:	cc cf       	rjmp	.-104    	; 0x1ddc <vTaskPrioritySet+0x74>

00001e44 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1e44:	af 92       	push	r10
    1e46:	bf 92       	push	r11
    1e48:	cf 92       	push	r12
    1e4a:	df 92       	push	r13
    1e4c:	ef 92       	push	r14
    1e4e:	ff 92       	push	r15
    1e50:	0f 93       	push	r16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
    1e52:	a1 2c       	mov	r10, r1
    1e54:	b1 2c       	mov	r11, r1
    1e56:	c1 2c       	mov	r12, r1
    1e58:	d1 2c       	mov	r13, r1
    1e5a:	99 e2       	ldi	r25, 0x29	; 41
    1e5c:	e9 2e       	mov	r14, r25
    1e5e:	9c e0       	ldi	r25, 0x0C	; 12
    1e60:	f9 2e       	mov	r15, r25
    1e62:	00 e0       	ldi	r16, 0x00	; 0
    1e64:	20 e0       	ldi	r18, 0x00	; 0
    1e66:	30 e0       	ldi	r19, 0x00	; 0
    1e68:	44 e6       	ldi	r20, 0x64	; 100
    1e6a:	50 e0       	ldi	r21, 0x00	; 0
    1e6c:	63 e7       	ldi	r22, 0x73	; 115
    1e6e:	71 e0       	ldi	r23, 0x01	; 1
    1e70:	85 e4       	ldi	r24, 0x45	; 69
    1e72:	9d e0       	ldi	r25, 0x0D	; 13
    1e74:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1e78:	81 30       	cpi	r24, 0x01	; 1
    1e7a:	41 f0       	breq	.+16     	; 0x1e8c <vTaskStartScheduler+0x48>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1e7c:	0f 91       	pop	r16
    1e7e:	ff 90       	pop	r15
    1e80:	ef 90       	pop	r14
    1e82:	df 90       	pop	r13
    1e84:	cf 90       	pop	r12
    1e86:	bf 90       	pop	r11
    1e88:	af 90       	pop	r10
    1e8a:	08 95       	ret
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1e8c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1e8e:	80 93 21 0c 	sts	0x0C21, r24
		xTickCount = ( portTickType ) 0U;
    1e92:	10 92 24 0c 	sts	0x0C24, r1
    1e96:	10 92 25 0c 	sts	0x0C25, r1
    1e9a:	10 92 26 0c 	sts	0x0C26, r1
    1e9e:	10 92 27 0c 	sts	0x0C27, r1
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1ea2:	0f 91       	pop	r16
    1ea4:	ff 90       	pop	r15
    1ea6:	ef 90       	pop	r14
    1ea8:	df 90       	pop	r13
    1eaa:	cf 90       	pop	r12
    1eac:	bf 90       	pop	r11
    1eae:	af 90       	pop	r10
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1eb0:	0c 94 cf 08 	jmp	0x119e	; 0x119e <xPortStartScheduler>

00001eb4 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1eb4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1eb6:	10 92 21 0c 	sts	0x0C21, r1
	vPortEndScheduler();
    1eba:	0c 94 0a 09 	jmp	0x1214	; 0x1214 <vPortEndScheduler>

00001ebe <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1ebe:	80 91 20 0c 	lds	r24, 0x0C20
    1ec2:	8f 5f       	subi	r24, 0xFF	; 255
    1ec4:	80 93 20 0c 	sts	0x0C20, r24
    1ec8:	08 95       	ret

00001eca <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1eca:	0f b6       	in	r0, 0x3f	; 63
    1ecc:	f8 94       	cli
    1ece:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1ed0:	60 91 24 0c 	lds	r22, 0x0C24
    1ed4:	70 91 25 0c 	lds	r23, 0x0C25
    1ed8:	80 91 26 0c 	lds	r24, 0x0C26
    1edc:	90 91 27 0c 	lds	r25, 0x0C27
	}
	taskEXIT_CRITICAL();
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1ee4:	08 95       	ret

00001ee6 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1ee6:	60 91 24 0c 	lds	r22, 0x0C24
    1eea:	70 91 25 0c 	lds	r23, 0x0C25
    1eee:	80 91 26 0c 	lds	r24, 0x0C26
    1ef2:	90 91 27 0c 	lds	r25, 0x0C27
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1ef6:	08 95       	ret

00001ef8 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1ef8:	80 91 28 0c 	lds	r24, 0x0C28
}
    1efc:	08 95       	ret

00001efe <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1efe:	00 97       	sbiw	r24, 0x00	; 0
    1f00:	11 f0       	breq	.+4      	; 0x1f06 <pcTaskGetTaskName+0x8>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1f02:	4d 96       	adiw	r24, 0x1d	; 29
    1f04:	08 95       	ret
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1f06:	80 91 1a 0c 	lds	r24, 0x0C1A
    1f0a:	90 91 1b 0c 	lds	r25, 0x0C1B
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1f0e:	4d 96       	adiw	r24, 0x1d	; 29
    1f10:	08 95       	ret

00001f12 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    1f12:	80 91 29 0c 	lds	r24, 0x0C29
    1f16:	90 91 2a 0c 	lds	r25, 0x0C2A
    1f1a:	08 95       	ret

00001f1c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1f1c:	ff 92       	push	r15
    1f1e:	0f 93       	push	r16
    1f20:	1f 93       	push	r17
    1f22:	cf 93       	push	r28
    1f24:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1f26:	80 91 20 0c 	lds	r24, 0x0C20
    1f2a:	81 11       	cpse	r24, r1
    1f2c:	ac c0       	rjmp	.+344    	; 0x2086 <vTaskIncrementTick+0x16a>
	{
		++xTickCount;
    1f2e:	80 91 24 0c 	lds	r24, 0x0C24
    1f32:	90 91 25 0c 	lds	r25, 0x0C25
    1f36:	a0 91 26 0c 	lds	r26, 0x0C26
    1f3a:	b0 91 27 0c 	lds	r27, 0x0C27
    1f3e:	01 96       	adiw	r24, 0x01	; 1
    1f40:	a1 1d       	adc	r26, r1
    1f42:	b1 1d       	adc	r27, r1
    1f44:	80 93 24 0c 	sts	0x0C24, r24
    1f48:	90 93 25 0c 	sts	0x0C25, r25
    1f4c:	a0 93 26 0c 	sts	0x0C26, r26
    1f50:	b0 93 27 0c 	sts	0x0C27, r27
		if( xTickCount == ( portTickType ) 0U )
    1f54:	80 91 24 0c 	lds	r24, 0x0C24
    1f58:	90 91 25 0c 	lds	r25, 0x0C25
    1f5c:	a0 91 26 0c 	lds	r26, 0x0C26
    1f60:	b0 91 27 0c 	lds	r27, 0x0C27
    1f64:	89 2b       	or	r24, r25
    1f66:	8a 2b       	or	r24, r26
    1f68:	8b 2b       	or	r24, r27
    1f6a:	09 f4       	brne	.+2      	; 0x1f6e <vTaskIncrementTick+0x52>
    1f6c:	97 c0       	rjmp	.+302    	; 0x209c <vTaskIncrementTick+0x180>
    1f6e:	80 91 01 01 	lds	r24, 0x0101
    1f72:	90 91 02 01 	lds	r25, 0x0102
    1f76:	a0 91 03 01 	lds	r26, 0x0103
    1f7a:	b0 91 04 01 	lds	r27, 0x0104
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1f7e:	40 91 24 0c 	lds	r20, 0x0C24
    1f82:	50 91 25 0c 	lds	r21, 0x0C25
    1f86:	60 91 26 0c 	lds	r22, 0x0C26
    1f8a:	70 91 27 0c 	lds	r23, 0x0C27
    1f8e:	48 17       	cp	r20, r24
    1f90:	59 07       	cpc	r21, r25
    1f92:	6a 07       	cpc	r22, r26
    1f94:	7b 07       	cpc	r23, r27
    1f96:	08 f4       	brcc	.+2      	; 0x1f9a <vTaskIncrementTick+0x7e>
    1f98:	7b c0       	rjmp	.+246    	; 0x2090 <vTaskIncrementTick+0x174>
    1f9a:	e0 91 38 0c 	lds	r30, 0x0C38
    1f9e:	f0 91 39 0c 	lds	r31, 0x0C39
    1fa2:	80 81       	ld	r24, Z
    1fa4:	88 23       	and	r24, r24
    1fa6:	09 f4       	brne	.+2      	; 0x1faa <vTaskIncrementTick+0x8e>
    1fa8:	5d c0       	rjmp	.+186    	; 0x2064 <vTaskIncrementTick+0x148>
    1faa:	e0 91 38 0c 	lds	r30, 0x0C38
    1fae:	f0 91 39 0c 	lds	r31, 0x0C39
    1fb2:	07 80       	ldd	r0, Z+7	; 0x07
    1fb4:	f0 85       	ldd	r31, Z+8	; 0x08
    1fb6:	e0 2d       	mov	r30, r0
    1fb8:	c0 85       	ldd	r28, Z+8	; 0x08
    1fba:	d1 85       	ldd	r29, Z+9	; 0x09
    1fbc:	8a 81       	ldd	r24, Y+2	; 0x02
    1fbe:	9b 81       	ldd	r25, Y+3	; 0x03
    1fc0:	ac 81       	ldd	r26, Y+4	; 0x04
    1fc2:	bd 81       	ldd	r27, Y+5	; 0x05
    1fc4:	40 91 24 0c 	lds	r20, 0x0C24
    1fc8:	50 91 25 0c 	lds	r21, 0x0C25
    1fcc:	60 91 26 0c 	lds	r22, 0x0C26
    1fd0:	70 91 27 0c 	lds	r23, 0x0C27
    1fd4:	48 17       	cp	r20, r24
    1fd6:	59 07       	cpc	r21, r25
    1fd8:	6a 07       	cpc	r22, r26
    1fda:	7b 07       	cpc	r23, r27
    1fdc:	08 f4       	brcc	.+2      	; 0x1fe0 <vTaskIncrementTick+0xc4>
    1fde:	a1 c0       	rjmp	.+322    	; 0x2122 <vTaskIncrementTick+0x206>
    1fe0:	2b e0       	ldi	r18, 0x0B	; 11
    1fe2:	f2 2e       	mov	r15, r18
    1fe4:	1b c0       	rjmp	.+54     	; 0x201c <vTaskIncrementTick+0x100>
    1fe6:	e0 91 38 0c 	lds	r30, 0x0C38
    1fea:	f0 91 39 0c 	lds	r31, 0x0C39
    1fee:	07 80       	ldd	r0, Z+7	; 0x07
    1ff0:	f0 85       	ldd	r31, Z+8	; 0x08
    1ff2:	e0 2d       	mov	r30, r0
    1ff4:	c0 85       	ldd	r28, Z+8	; 0x08
    1ff6:	d1 85       	ldd	r29, Z+9	; 0x09
    1ff8:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffa:	9b 81       	ldd	r25, Y+3	; 0x03
    1ffc:	ac 81       	ldd	r26, Y+4	; 0x04
    1ffe:	bd 81       	ldd	r27, Y+5	; 0x05
    2000:	40 91 24 0c 	lds	r20, 0x0C24
    2004:	50 91 25 0c 	lds	r21, 0x0C25
    2008:	60 91 26 0c 	lds	r22, 0x0C26
    200c:	70 91 27 0c 	lds	r23, 0x0C27
    2010:	48 17       	cp	r20, r24
    2012:	59 07       	cpc	r21, r25
    2014:	6a 07       	cpc	r22, r26
    2016:	7b 07       	cpc	r23, r27
    2018:	08 f4       	brcc	.+2      	; 0x201c <vTaskIncrementTick+0x100>
    201a:	83 c0       	rjmp	.+262    	; 0x2122 <vTaskIncrementTick+0x206>
    201c:	8e 01       	movw	r16, r28
    201e:	0e 5f       	subi	r16, 0xFE	; 254
    2020:	1f 4f       	sbci	r17, 0xFF	; 255
    2022:	c8 01       	movw	r24, r16
    2024:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>
    2028:	88 8d       	ldd	r24, Y+24	; 0x18
    202a:	99 8d       	ldd	r25, Y+25	; 0x19
    202c:	89 2b       	or	r24, r25
    202e:	21 f0       	breq	.+8      	; 0x2038 <vTaskIncrementTick+0x11c>
    2030:	ce 01       	movw	r24, r28
    2032:	0e 96       	adiw	r24, 0x0e	; 14
    2034:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>
    2038:	8a 8d       	ldd	r24, Y+26	; 0x1a
    203a:	90 91 22 0c 	lds	r25, 0x0C22
    203e:	98 17       	cp	r25, r24
    2040:	10 f4       	brcc	.+4      	; 0x2046 <vTaskIncrementTick+0x12a>
    2042:	80 93 22 0c 	sts	0x0C22, r24
    2046:	f8 9e       	mul	r15, r24
    2048:	c0 01       	movw	r24, r0
    204a:	11 24       	eor	r1, r1
    204c:	b8 01       	movw	r22, r16
    204e:	80 5b       	subi	r24, 0xB0	; 176
    2050:	93 4f       	sbci	r25, 0xF3	; 243
    2052:	0e 94 35 14 	call	0x286a	; 0x286a <vListInsertEnd>
    2056:	e0 91 38 0c 	lds	r30, 0x0C38
    205a:	f0 91 39 0c 	lds	r31, 0x0C39
    205e:	80 81       	ld	r24, Z
    2060:	81 11       	cpse	r24, r1
    2062:	c1 cf       	rjmp	.-126    	; 0x1fe6 <vTaskIncrementTick+0xca>
    2064:	8f ef       	ldi	r24, 0xFF	; 255
    2066:	9f ef       	ldi	r25, 0xFF	; 255
    2068:	dc 01       	movw	r26, r24
    206a:	80 93 01 01 	sts	0x0101, r24
    206e:	90 93 02 01 	sts	0x0102, r25
    2072:	a0 93 03 01 	sts	0x0103, r26
    2076:	b0 93 04 01 	sts	0x0104, r27
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    207a:	df 91       	pop	r29
    207c:	cf 91       	pop	r28
    207e:	1f 91       	pop	r17
    2080:	0f 91       	pop	r16
    2082:	ff 90       	pop	r15
    2084:	08 95       	ret
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
    2086:	80 91 1f 0c 	lds	r24, 0x0C1F
    208a:	8f 5f       	subi	r24, 0xFF	; 255
    208c:	80 93 1f 0c 	sts	0x0C1F, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2090:	df 91       	pop	r29
    2092:	cf 91       	pop	r28
    2094:	1f 91       	pop	r17
    2096:	0f 91       	pop	r16
    2098:	ff 90       	pop	r15
    209a:	08 95       	ret
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    209c:	80 91 38 0c 	lds	r24, 0x0C38
    20a0:	90 91 39 0c 	lds	r25, 0x0C39
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    20a4:	20 91 36 0c 	lds	r18, 0x0C36
    20a8:	30 91 37 0c 	lds	r19, 0x0C37
    20ac:	30 93 39 0c 	sts	0x0C39, r19
    20b0:	20 93 38 0c 	sts	0x0C38, r18
			pxOverflowDelayedTaskList = pxTemp;
    20b4:	90 93 37 0c 	sts	0x0C37, r25
    20b8:	80 93 36 0c 	sts	0x0C36, r24
			xNumOfOverflows++;
    20bc:	80 91 1d 0c 	lds	r24, 0x0C1D
    20c0:	8f 5f       	subi	r24, 0xFF	; 255
    20c2:	80 93 1d 0c 	sts	0x0C1D, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    20c6:	e0 91 38 0c 	lds	r30, 0x0C38
    20ca:	f0 91 39 0c 	lds	r31, 0x0C39
    20ce:	80 81       	ld	r24, Z
    20d0:	81 11       	cpse	r24, r1
    20d2:	0c c0       	rjmp	.+24     	; 0x20ec <vTaskIncrementTick+0x1d0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    20d4:	8f ef       	ldi	r24, 0xFF	; 255
    20d6:	9f ef       	ldi	r25, 0xFF	; 255
    20d8:	dc 01       	movw	r26, r24
    20da:	80 93 01 01 	sts	0x0101, r24
    20de:	90 93 02 01 	sts	0x0102, r25
    20e2:	a0 93 03 01 	sts	0x0103, r26
    20e6:	b0 93 04 01 	sts	0x0104, r27
    20ea:	49 cf       	rjmp	.-366    	; 0x1f7e <vTaskIncrementTick+0x62>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    20ec:	e0 91 38 0c 	lds	r30, 0x0C38
    20f0:	f0 91 39 0c 	lds	r31, 0x0C39
    20f4:	07 80       	ldd	r0, Z+7	; 0x07
    20f6:	f0 85       	ldd	r31, Z+8	; 0x08
    20f8:	e0 2d       	mov	r30, r0
    20fa:	00 84       	ldd	r0, Z+8	; 0x08
    20fc:	f1 85       	ldd	r31, Z+9	; 0x09
    20fe:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2100:	52 81       	ldd	r21, Z+2	; 0x02
    2102:	43 81       	ldd	r20, Z+3	; 0x03
    2104:	34 81       	ldd	r19, Z+4	; 0x04
    2106:	25 81       	ldd	r18, Z+5	; 0x05
    2108:	50 93 01 01 	sts	0x0101, r21
    210c:	40 93 02 01 	sts	0x0102, r20
    2110:	30 93 03 01 	sts	0x0103, r19
    2114:	20 93 04 01 	sts	0x0104, r18
    2118:	85 2f       	mov	r24, r21
    211a:	94 2f       	mov	r25, r20
    211c:	a3 2f       	mov	r26, r19
    211e:	b2 2f       	mov	r27, r18
    2120:	2e cf       	rjmp	.-420    	; 0x1f7e <vTaskIncrementTick+0x62>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2122:	80 93 01 01 	sts	0x0101, r24
    2126:	90 93 02 01 	sts	0x0102, r25
    212a:	a0 93 03 01 	sts	0x0103, r26
    212e:	b0 93 04 01 	sts	0x0104, r27
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2132:	df 91       	pop	r29
    2134:	cf 91       	pop	r28
    2136:	1f 91       	pop	r17
    2138:	0f 91       	pop	r16
    213a:	ff 90       	pop	r15
    213c:	08 95       	ret

0000213e <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    213e:	ef 92       	push	r14
    2140:	ff 92       	push	r15
    2142:	0f 93       	push	r16
    2144:	1f 93       	push	r17
    2146:	cf 93       	push	r28
    2148:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    214a:	0f b6       	in	r0, 0x3f	; 63
    214c:	f8 94       	cli
    214e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2150:	80 91 20 0c 	lds	r24, 0x0C20
    2154:	81 50       	subi	r24, 0x01	; 1
    2156:	80 93 20 0c 	sts	0x0C20, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    215a:	80 91 20 0c 	lds	r24, 0x0C20
    215e:	81 11       	cpse	r24, r1
    2160:	44 c0       	rjmp	.+136    	; 0x21ea <xTaskResumeAll+0xac>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2162:	80 91 28 0c 	lds	r24, 0x0C28
    2166:	88 23       	and	r24, r24
    2168:	09 f4       	brne	.+2      	; 0x216c <xTaskResumeAll+0x2e>
    216a:	3f c0       	rjmp	.+126    	; 0x21ea <xTaskResumeAll+0xac>
    216c:	e1 2c       	mov	r14, r1
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    216e:	3b e0       	ldi	r19, 0x0B	; 11
    2170:	f3 2e       	mov	r15, r19
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2172:	80 91 2b 0c 	lds	r24, 0x0C2B
    2176:	88 23       	and	r24, r24
    2178:	69 f1       	breq	.+90     	; 0x21d4 <xTaskResumeAll+0x96>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    217a:	e0 91 32 0c 	lds	r30, 0x0C32
    217e:	f0 91 33 0c 	lds	r31, 0x0C33
    2182:	c0 85       	ldd	r28, Z+8	; 0x08
    2184:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2186:	ce 01       	movw	r24, r28
    2188:	0e 96       	adiw	r24, 0x0e	; 14
    218a:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    218e:	8e 01       	movw	r16, r28
    2190:	0e 5f       	subi	r16, 0xFE	; 254
    2192:	1f 4f       	sbci	r17, 0xFF	; 255
    2194:	c8 01       	movw	r24, r16
    2196:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    219a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    219c:	90 91 22 0c 	lds	r25, 0x0C22
    21a0:	98 17       	cp	r25, r24
    21a2:	10 f4       	brcc	.+4      	; 0x21a8 <xTaskResumeAll+0x6a>
    21a4:	80 93 22 0c 	sts	0x0C22, r24
    21a8:	f8 9e       	mul	r15, r24
    21aa:	c0 01       	movw	r24, r0
    21ac:	11 24       	eor	r1, r1
    21ae:	b8 01       	movw	r22, r16
    21b0:	80 5b       	subi	r24, 0xB0	; 176
    21b2:	93 4f       	sbci	r25, 0xF3	; 243
    21b4:	0e 94 35 14 	call	0x286a	; 0x286a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    21b8:	e0 91 1a 0c 	lds	r30, 0x0C1A
    21bc:	f0 91 1b 0c 	lds	r31, 0x0C1B
    21c0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    21c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    21c4:	98 17       	cp	r25, r24
    21c6:	a8 f2       	brcs	.-86     	; 0x2172 <xTaskResumeAll+0x34>
					{
						xYieldRequired = pdTRUE;
    21c8:	ee 24       	eor	r14, r14
    21ca:	e3 94       	inc	r14
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    21cc:	80 91 2b 0c 	lds	r24, 0x0C2B
    21d0:	81 11       	cpse	r24, r1
    21d2:	d3 cf       	rjmp	.-90     	; 0x217a <xTaskResumeAll+0x3c>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    21d4:	80 91 1f 0c 	lds	r24, 0x0C1F
    21d8:	81 11       	cpse	r24, r1
    21da:	18 c0       	rjmp	.+48     	; 0x220c <xTaskResumeAll+0xce>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    21dc:	81 e0       	ldi	r24, 0x01	; 1
    21de:	e8 16       	cp	r14, r24
    21e0:	c9 f0       	breq	.+50     	; 0x2214 <xTaskResumeAll+0xd6>
    21e2:	80 91 1e 0c 	lds	r24, 0x0C1E
    21e6:	81 30       	cpi	r24, 0x01	; 1
    21e8:	a9 f0       	breq	.+42     	; 0x2214 <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    21ea:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    21ec:	0f 90       	pop	r0
    21ee:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    21f0:	df 91       	pop	r29
    21f2:	cf 91       	pop	r28
    21f4:	1f 91       	pop	r17
    21f6:	0f 91       	pop	r16
    21f8:	ff 90       	pop	r15
    21fa:	ef 90       	pop	r14
    21fc:	08 95       	ret
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    21fe:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <vTaskIncrementTick>
						--uxMissedTicks;
    2202:	80 91 1f 0c 	lds	r24, 0x0C1F
    2206:	81 50       	subi	r24, 0x01	; 1
    2208:	80 93 1f 0c 	sts	0x0C1F, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    220c:	80 91 1f 0c 	lds	r24, 0x0C1F
    2210:	81 11       	cpse	r24, r1
    2212:	f5 cf       	rjmp	.-22     	; 0x21fe <xTaskResumeAll+0xc0>
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2214:	10 92 1e 0c 	sts	0x0C1E, r1
					portYIELD_WITHIN_API();
    2218:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    221c:	81 e0       	ldi	r24, 0x01	; 1
    221e:	e6 cf       	rjmp	.-52     	; 0x21ec <xTaskResumeAll+0xae>

00002220 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2220:	cf 92       	push	r12
    2222:	df 92       	push	r13
    2224:	ef 92       	push	r14
    2226:	ff 92       	push	r15
    2228:	0f 93       	push	r16
    222a:	1f 93       	push	r17
    222c:	cf 93       	push	r28
    222e:	df 93       	push	r29
    2230:	00 d0       	rcall	.+0      	; 0x2232 <vTaskDelayUntil+0x12>
    2232:	00 d0       	rcall	.+0      	; 0x2234 <vTaskDelayUntil+0x14>
    2234:	cd b7       	in	r28, 0x3d	; 61
    2236:	de b7       	in	r29, 0x3e	; 62

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2238:	20 91 20 0c 	lds	r18, 0x0C20
    223c:	2f 5f       	subi	r18, 0xFF	; 255
    223e:	20 93 20 0c 	sts	0x0C20, r18
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2242:	fc 01       	movw	r30, r24
    2244:	00 81       	ld	r16, Z
    2246:	11 81       	ldd	r17, Z+1	; 0x01
    2248:	22 81       	ldd	r18, Z+2	; 0x02
    224a:	33 81       	ldd	r19, Z+3	; 0x03
    224c:	40 0f       	add	r20, r16
    224e:	51 1f       	adc	r21, r17
    2250:	62 1f       	adc	r22, r18
    2252:	73 1f       	adc	r23, r19

			if( xTickCount < *pxPreviousWakeTime )
    2254:	c0 90 24 0c 	lds	r12, 0x0C24
    2258:	d0 90 25 0c 	lds	r13, 0x0C25
    225c:	e0 90 26 0c 	lds	r14, 0x0C26
    2260:	f0 90 27 0c 	lds	r15, 0x0C27
    2264:	c0 16       	cp	r12, r16
    2266:	d1 06       	cpc	r13, r17
    2268:	e2 06       	cpc	r14, r18
    226a:	f3 06       	cpc	r15, r19
    226c:	e8 f4       	brcc	.+58     	; 0x22a8 <vTaskDelayUntil+0x88>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    226e:	40 17       	cp	r20, r16
    2270:	51 07       	cpc	r21, r17
    2272:	62 07       	cpc	r22, r18
    2274:	73 07       	cpc	r23, r19
    2276:	e8 f0       	brcs	.+58     	; 0x22b2 <vTaskDelayUntil+0x92>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2278:	fc 01       	movw	r30, r24
    227a:	40 83       	st	Z, r20
    227c:	51 83       	std	Z+1, r21	; 0x01
    227e:	62 83       	std	Z+2, r22	; 0x02
    2280:	73 83       	std	Z+3, r23	; 0x03
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
				prvAddCurrentTaskToDelayedList( xTimeToWake );
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2282:	0e 94 9f 10 	call	0x213e	; 0x213e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2286:	81 11       	cpse	r24, r1
    2288:	02 c0       	rjmp	.+4      	; 0x228e <vTaskDelayUntil+0x6e>
		{
			portYIELD_WITHIN_API();
    228a:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortYield>
		}
	}
    228e:	0f 90       	pop	r0
    2290:	0f 90       	pop	r0
    2292:	0f 90       	pop	r0
    2294:	0f 90       	pop	r0
    2296:	df 91       	pop	r29
    2298:	cf 91       	pop	r28
    229a:	1f 91       	pop	r17
    229c:	0f 91       	pop	r16
    229e:	ff 90       	pop	r15
    22a0:	ef 90       	pop	r14
    22a2:	df 90       	pop	r13
    22a4:	cf 90       	pop	r12
    22a6:	08 95       	ret
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    22a8:	40 17       	cp	r20, r16
    22aa:	51 07       	cpc	r21, r17
    22ac:	62 07       	cpc	r22, r18
    22ae:	73 07       	cpc	r23, r19
    22b0:	68 f0       	brcs	.+26     	; 0x22cc <vTaskDelayUntil+0xac>
    22b2:	00 91 24 0c 	lds	r16, 0x0C24
    22b6:	10 91 25 0c 	lds	r17, 0x0C25
    22ba:	20 91 26 0c 	lds	r18, 0x0C26
    22be:	30 91 27 0c 	lds	r19, 0x0C27
    22c2:	04 17       	cp	r16, r20
    22c4:	15 07       	cpc	r17, r21
    22c6:	26 07       	cpc	r18, r22
    22c8:	37 07       	cpc	r19, r23
    22ca:	b0 f6       	brcc	.-84     	; 0x2278 <vTaskDelayUntil+0x58>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22cc:	fc 01       	movw	r30, r24
    22ce:	40 83       	st	Z, r20
    22d0:	51 83       	std	Z+1, r21	; 0x01
    22d2:	62 83       	std	Z+2, r22	; 0x02
    22d4:	73 83       	std	Z+3, r23	; 0x03
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    22d6:	80 91 1a 0c 	lds	r24, 0x0C1A
    22da:	90 91 1b 0c 	lds	r25, 0x0C1B
    22de:	02 96       	adiw	r24, 0x02	; 2
    22e0:	49 83       	std	Y+1, r20	; 0x01
    22e2:	5a 83       	std	Y+2, r21	; 0x02
    22e4:	6b 83       	std	Y+3, r22	; 0x03
    22e6:	7c 83       	std	Y+4, r23	; 0x04
    22e8:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    22ec:	49 81       	ldd	r20, Y+1	; 0x01
    22ee:	5a 81       	ldd	r21, Y+2	; 0x02
    22f0:	6b 81       	ldd	r22, Y+3	; 0x03
    22f2:	7c 81       	ldd	r23, Y+4	; 0x04
    22f4:	cb 01       	movw	r24, r22
    22f6:	ba 01       	movw	r22, r20
    22f8:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <prvAddCurrentTaskToDelayedList>
    22fc:	c2 cf       	rjmp	.-124    	; 0x2282 <vTaskDelayUntil+0x62>

000022fe <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    22fe:	cf 92       	push	r12
    2300:	df 92       	push	r13
    2302:	ef 92       	push	r14
    2304:	ff 92       	push	r15
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2306:	61 15       	cp	r22, r1
    2308:	71 05       	cpc	r23, r1
    230a:	81 05       	cpc	r24, r1
    230c:	91 05       	cpc	r25, r1
    230e:	39 f4       	brne	.+14     	; 0x231e <vTaskDelay+0x20>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    2310:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortYield>
		}
	}
    2314:	ff 90       	pop	r15
    2316:	ef 90       	pop	r14
    2318:	df 90       	pop	r13
    231a:	cf 90       	pop	r12
    231c:	08 95       	ret

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    231e:	20 91 20 0c 	lds	r18, 0x0C20
    2322:	2f 5f       	subi	r18, 0xFF	; 255
    2324:	20 93 20 0c 	sts	0x0C20, r18
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2328:	c0 90 24 0c 	lds	r12, 0x0C24
    232c:	d0 90 25 0c 	lds	r13, 0x0C25
    2330:	e0 90 26 0c 	lds	r14, 0x0C26
    2334:	f0 90 27 0c 	lds	r15, 0x0C27
    2338:	c6 0e       	add	r12, r22
    233a:	d7 1e       	adc	r13, r23
    233c:	e8 1e       	adc	r14, r24
    233e:	f9 1e       	adc	r15, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2340:	80 91 1a 0c 	lds	r24, 0x0C1A
    2344:	90 91 1b 0c 	lds	r25, 0x0C1B
    2348:	02 96       	adiw	r24, 0x02	; 2
    234a:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    234e:	c7 01       	movw	r24, r14
    2350:	b6 01       	movw	r22, r12
    2352:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2356:	0e 94 9f 10 	call	0x213e	; 0x213e <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    235a:	88 23       	and	r24, r24
    235c:	c9 f2       	breq	.-78     	; 0x2310 <vTaskDelay+0x12>
		{
			portYIELD_WITHIN_API();
		}
	}
    235e:	ff 90       	pop	r15
    2360:	ef 90       	pop	r14
    2362:	df 90       	pop	r13
    2364:	cf 90       	pop	r12
    2366:	08 95       	ret

00002368 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2368:	80 91 20 0c 	lds	r24, 0x0C20
    236c:	81 11       	cpse	r24, r1
    236e:	39 c0       	rjmp	.+114    	; 0x23e2 <vTaskSwitchContext+0x7a>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2370:	e0 91 22 0c 	lds	r30, 0x0C22
    2374:	8b e0       	ldi	r24, 0x0B	; 11
    2376:	e8 9f       	mul	r30, r24
    2378:	f0 01       	movw	r30, r0
    237a:	11 24       	eor	r1, r1
    237c:	e0 5b       	subi	r30, 0xB0	; 176
    237e:	f3 4f       	sbci	r31, 0xF3	; 243
    2380:	80 81       	ld	r24, Z
    2382:	81 11       	cpse	r24, r1
    2384:	10 c0       	rjmp	.+32     	; 0x23a6 <vTaskSwitchContext+0x3e>
    2386:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2388:	80 91 22 0c 	lds	r24, 0x0C22
    238c:	81 50       	subi	r24, 0x01	; 1
    238e:	80 93 22 0c 	sts	0x0C22, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2392:	e0 91 22 0c 	lds	r30, 0x0C22
    2396:	9e 9f       	mul	r25, r30
    2398:	f0 01       	movw	r30, r0
    239a:	11 24       	eor	r1, r1
    239c:	e0 5b       	subi	r30, 0xB0	; 176
    239e:	f3 4f       	sbci	r31, 0xF3	; 243
    23a0:	80 81       	ld	r24, Z
    23a2:	88 23       	and	r24, r24
    23a4:	89 f3       	breq	.-30     	; 0x2388 <vTaskSwitchContext+0x20>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    23a6:	e0 91 22 0c 	lds	r30, 0x0C22
    23aa:	8b e0       	ldi	r24, 0x0B	; 11
    23ac:	e8 9f       	mul	r30, r24
    23ae:	f0 01       	movw	r30, r0
    23b0:	11 24       	eor	r1, r1
    23b2:	e0 5b       	subi	r30, 0xB0	; 176
    23b4:	f3 4f       	sbci	r31, 0xF3	; 243
    23b6:	a1 81       	ldd	r26, Z+1	; 0x01
    23b8:	b2 81       	ldd	r27, Z+2	; 0x02
    23ba:	14 96       	adiw	r26, 0x04	; 4
    23bc:	0d 90       	ld	r0, X+
    23be:	bc 91       	ld	r27, X
    23c0:	a0 2d       	mov	r26, r0
    23c2:	b2 83       	std	Z+2, r27	; 0x02
    23c4:	a1 83       	std	Z+1, r26	; 0x01
    23c6:	cf 01       	movw	r24, r30
    23c8:	03 96       	adiw	r24, 0x03	; 3
    23ca:	a8 17       	cp	r26, r24
    23cc:	b9 07       	cpc	r27, r25
    23ce:	69 f0       	breq	.+26     	; 0x23ea <vTaskSwitchContext+0x82>
    23d0:	18 96       	adiw	r26, 0x08	; 8
    23d2:	8d 91       	ld	r24, X+
    23d4:	9c 91       	ld	r25, X
    23d6:	19 97       	sbiw	r26, 0x09	; 9
    23d8:	90 93 1b 0c 	sts	0x0C1B, r25
    23dc:	80 93 1a 0c 	sts	0x0C1A, r24
    23e0:	08 95       	ret
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    23e2:	81 e0       	ldi	r24, 0x01	; 1
    23e4:	80 93 1e 0c 	sts	0x0C1E, r24
    23e8:	08 95       	ret
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    23ea:	14 96       	adiw	r26, 0x04	; 4
    23ec:	0d 90       	ld	r0, X+
    23ee:	bc 91       	ld	r27, X
    23f0:	a0 2d       	mov	r26, r0
    23f2:	b2 83       	std	Z+2, r27	; 0x02
    23f4:	a1 83       	std	Z+1, r26	; 0x01
    23f6:	ec cf       	rjmp	.-40     	; 0x23d0 <vTaskSwitchContext+0x68>

000023f8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    23f8:	cf 92       	push	r12
    23fa:	df 92       	push	r13
    23fc:	ef 92       	push	r14
    23fe:	ff 92       	push	r15
    2400:	6a 01       	movw	r12, r20
    2402:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2404:	60 91 1a 0c 	lds	r22, 0x0C1A
    2408:	70 91 1b 0c 	lds	r23, 0x0C1B
    240c:	62 5f       	subi	r22, 0xF2	; 242
    240e:	7f 4f       	sbci	r23, 0xFF	; 255
    2410:	0e 94 58 14 	call	0x28b0	; 0x28b0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2414:	80 91 1a 0c 	lds	r24, 0x0C1A
    2418:	90 91 1b 0c 	lds	r25, 0x0C1B
    241c:	02 96       	adiw	r24, 0x02	; 2
    241e:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2422:	60 91 24 0c 	lds	r22, 0x0C24
    2426:	70 91 25 0c 	lds	r23, 0x0C25
    242a:	80 91 26 0c 	lds	r24, 0x0C26
    242e:	90 91 27 0c 	lds	r25, 0x0C27
    2432:	6c 0d       	add	r22, r12
    2434:	7d 1d       	adc	r23, r13
    2436:	8e 1d       	adc	r24, r14
    2438:	9f 1d       	adc	r25, r15
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    243a:	ff 90       	pop	r15
    243c:	ef 90       	pop	r14
    243e:	df 90       	pop	r13
    2440:	cf 90       	pop	r12
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2442:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <prvAddCurrentTaskToDelayedList>

00002446 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2446:	0f 93       	push	r16
    2448:	1f 93       	push	r17
    244a:	cf 93       	push	r28
    244c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    244e:	dc 01       	movw	r26, r24
    2450:	17 96       	adiw	r26, 0x07	; 7
    2452:	ed 91       	ld	r30, X+
    2454:	fc 91       	ld	r31, X
    2456:	18 97       	sbiw	r26, 0x08	; 8
    2458:	c0 85       	ldd	r28, Z+8	; 0x08
    245a:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    245c:	8e 01       	movw	r16, r28
    245e:	02 5f       	subi	r16, 0xF2	; 242
    2460:	1f 4f       	sbci	r17, 0xFF	; 255
    2462:	c8 01       	movw	r24, r16
    2464:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2468:	80 91 20 0c 	lds	r24, 0x0C20
    246c:	81 11       	cpse	r24, r1
    246e:	23 c0       	rjmp	.+70     	; 0x24b6 <xTaskRemoveFromEventList+0x70>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2470:	8e 01       	movw	r16, r28
    2472:	0e 5f       	subi	r16, 0xFE	; 254
    2474:	1f 4f       	sbci	r17, 0xFF	; 255
    2476:	c8 01       	movw	r24, r16
    2478:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    247c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    247e:	90 91 22 0c 	lds	r25, 0x0C22
    2482:	98 17       	cp	r25, r24
    2484:	f0 f0       	brcs	.+60     	; 0x24c2 <xTaskRemoveFromEventList+0x7c>
    2486:	bb e0       	ldi	r27, 0x0B	; 11
    2488:	8b 9f       	mul	r24, r27
    248a:	c0 01       	movw	r24, r0
    248c:	11 24       	eor	r1, r1
    248e:	b8 01       	movw	r22, r16
    2490:	80 5b       	subi	r24, 0xB0	; 176
    2492:	93 4f       	sbci	r25, 0xF3	; 243
    2494:	0e 94 35 14 	call	0x286a	; 0x286a <vListInsertEnd>
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2498:	e0 91 1a 0c 	lds	r30, 0x0C1A
    249c:	f0 91 1b 0c 	lds	r31, 0x0C1B
    24a0:	81 e0       	ldi	r24, 0x01	; 1
    24a2:	2a 8d       	ldd	r18, Y+26	; 0x1a
    24a4:	92 8d       	ldd	r25, Z+26	; 0x1a
    24a6:	29 17       	cp	r18, r25
    24a8:	08 f4       	brcc	.+2      	; 0x24ac <xTaskRemoveFromEventList+0x66>
    24aa:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    24ac:	df 91       	pop	r29
    24ae:	cf 91       	pop	r28
    24b0:	1f 91       	pop	r17
    24b2:	0f 91       	pop	r16
    24b4:	08 95       	ret
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    24b6:	b8 01       	movw	r22, r16
    24b8:	8b e2       	ldi	r24, 0x2B	; 43
    24ba:	9c e0       	ldi	r25, 0x0C	; 12
    24bc:	0e 94 35 14 	call	0x286a	; 0x286a <vListInsertEnd>
    24c0:	eb cf       	rjmp	.-42     	; 0x2498 <xTaskRemoveFromEventList+0x52>
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    24c2:	80 93 22 0c 	sts	0x0C22, r24
    24c6:	df cf       	rjmp	.-66     	; 0x2486 <xTaskRemoveFromEventList+0x40>

000024c8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    24c8:	20 91 1d 0c 	lds	r18, 0x0C1D
    24cc:	fc 01       	movw	r30, r24
    24ce:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    24d0:	40 91 24 0c 	lds	r20, 0x0C24
    24d4:	50 91 25 0c 	lds	r21, 0x0C25
    24d8:	60 91 26 0c 	lds	r22, 0x0C26
    24dc:	70 91 27 0c 	lds	r23, 0x0C27
    24e0:	41 83       	std	Z+1, r20	; 0x01
    24e2:	52 83       	std	Z+2, r21	; 0x02
    24e4:	63 83       	std	Z+3, r22	; 0x03
    24e6:	74 83       	std	Z+4, r23	; 0x04
    24e8:	08 95       	ret

000024ea <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    24ea:	cf 92       	push	r12
    24ec:	df 92       	push	r13
    24ee:	ef 92       	push	r14
    24f0:	ff 92       	push	r15
    24f2:	0f 93       	push	r16
    24f4:	1f 93       	push	r17
    24f6:	fc 01       	movw	r30, r24
    24f8:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    24fa:	0f b6       	in	r0, 0x3f	; 63
    24fc:	f8 94       	cli
    24fe:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2500:	80 91 1d 0c 	lds	r24, 0x0C1D
    2504:	90 81       	ld	r25, Z
    2506:	98 17       	cp	r25, r24
    2508:	09 f4       	brne	.+2      	; 0x250c <xTaskCheckForTimeOut+0x22>
    250a:	59 c0       	rjmp	.+178    	; 0x25be <xTaskCheckForTimeOut+0xd4>
    250c:	41 81       	ldd	r20, Z+1	; 0x01
    250e:	52 81       	ldd	r21, Z+2	; 0x02
    2510:	63 81       	ldd	r22, Z+3	; 0x03
    2512:	74 81       	ldd	r23, Z+4	; 0x04
    2514:	00 91 24 0c 	lds	r16, 0x0C24
    2518:	10 91 25 0c 	lds	r17, 0x0C25
    251c:	20 91 26 0c 	lds	r18, 0x0C26
    2520:	30 91 27 0c 	lds	r19, 0x0C27
    2524:	04 17       	cp	r16, r20
    2526:	15 07       	cpc	r17, r21
    2528:	26 07       	cpc	r18, r22
    252a:	37 07       	cpc	r19, r23
    252c:	f0 f5       	brcc	.+124    	; 0x25aa <xTaskCheckForTimeOut+0xc0>
    252e:	8a 01       	movw	r16, r20
    2530:	9b 01       	movw	r18, r22
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2532:	40 91 24 0c 	lds	r20, 0x0C24
    2536:	50 91 25 0c 	lds	r21, 0x0C25
    253a:	60 91 26 0c 	lds	r22, 0x0C26
    253e:	70 91 27 0c 	lds	r23, 0x0C27
    2542:	cd 90       	ld	r12, X+
    2544:	dd 90       	ld	r13, X+
    2546:	ed 90       	ld	r14, X+
    2548:	fc 90       	ld	r15, X
    254a:	13 97       	sbiw	r26, 0x03	; 3
    254c:	40 1b       	sub	r20, r16
    254e:	51 0b       	sbc	r21, r17
    2550:	62 0b       	sbc	r22, r18
    2552:	73 0b       	sbc	r23, r19
    2554:	4c 15       	cp	r20, r12
    2556:	5d 05       	cpc	r21, r13
    2558:	6e 05       	cpc	r22, r14
    255a:	7f 05       	cpc	r23, r15
    255c:	30 f5       	brcc	.+76     	; 0x25aa <xTaskCheckForTimeOut+0xc0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    255e:	40 91 24 0c 	lds	r20, 0x0C24
    2562:	50 91 25 0c 	lds	r21, 0x0C25
    2566:	60 91 26 0c 	lds	r22, 0x0C26
    256a:	70 91 27 0c 	lds	r23, 0x0C27
    256e:	c4 1a       	sub	r12, r20
    2570:	d5 0a       	sbc	r13, r21
    2572:	e6 0a       	sbc	r14, r22
    2574:	f7 0a       	sbc	r15, r23
    2576:	c0 0e       	add	r12, r16
    2578:	d1 1e       	adc	r13, r17
    257a:	e2 1e       	adc	r14, r18
    257c:	f3 1e       	adc	r15, r19
    257e:	cd 92       	st	X+, r12
    2580:	dd 92       	st	X+, r13
    2582:	ed 92       	st	X+, r14
    2584:	fc 92       	st	X, r15
    2586:	13 97       	sbiw	r26, 0x03	; 3
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2588:	80 91 1d 0c 	lds	r24, 0x0C1D
    258c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    258e:	80 91 24 0c 	lds	r24, 0x0C24
    2592:	90 91 25 0c 	lds	r25, 0x0C25
    2596:	a0 91 26 0c 	lds	r26, 0x0C26
    259a:	b0 91 27 0c 	lds	r27, 0x0C27
    259e:	81 83       	std	Z+1, r24	; 0x01
    25a0:	92 83       	std	Z+2, r25	; 0x02
    25a2:	a3 83       	std	Z+3, r26	; 0x03
    25a4:	b4 83       	std	Z+4, r27	; 0x04
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
    25a6:	80 e0       	ldi	r24, 0x00	; 0
    25a8:	01 c0       	rjmp	.+2      	; 0x25ac <xTaskCheckForTimeOut+0xc2>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    25aa:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    25ac:	0f 90       	pop	r0
    25ae:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    25b0:	1f 91       	pop	r17
    25b2:	0f 91       	pop	r16
    25b4:	ff 90       	pop	r15
    25b6:	ef 90       	pop	r14
    25b8:	df 90       	pop	r13
    25ba:	cf 90       	pop	r12
    25bc:	08 95       	ret
    25be:	01 81       	ldd	r16, Z+1	; 0x01
    25c0:	12 81       	ldd	r17, Z+2	; 0x02
    25c2:	23 81       	ldd	r18, Z+3	; 0x03
    25c4:	34 81       	ldd	r19, Z+4	; 0x04
    25c6:	b5 cf       	rjmp	.-150    	; 0x2532 <xTaskCheckForTimeOut+0x48>

000025c8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    25c8:	81 e0       	ldi	r24, 0x01	; 1
    25ca:	80 93 1e 0c 	sts	0x0C1E, r24
    25ce:	08 95       	ret

000025d0 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    25d0:	00 97       	sbiw	r24, 0x00	; 0
    25d2:	81 f0       	breq	.+32     	; 0x25f4 <uxTaskGetStackHighWaterMark+0x24>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    25d4:	dc 01       	movw	r26, r24
    25d6:	5b 96       	adiw	r26, 0x1b	; 27
    25d8:	ed 91       	ld	r30, X+
    25da:	fc 91       	ld	r31, X
    25dc:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    25de:	80 81       	ld	r24, Z
    25e0:	81 31       	cpi	r24, 0x11	; 17
    25e2:	69 f4       	brne	.+26     	; 0x25fe <uxTaskGetStackHighWaterMark+0x2e>
    25e4:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    25e6:	80 e0       	ldi	r24, 0x00	; 0
    25e8:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    25ea:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    25ec:	21 91       	ld	r18, Z+
    25ee:	21 31       	cpi	r18, 0x11	; 17
    25f0:	e1 f3       	breq	.-8      	; 0x25ea <uxTaskGetStackHighWaterMark+0x1a>
    25f2:	08 95       	ret
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    25f4:	80 91 1a 0c 	lds	r24, 0x0C1A
    25f8:	90 91 1b 0c 	lds	r25, 0x0C1B
    25fc:	eb cf       	rjmp	.-42     	; 0x25d4 <uxTaskGetStackHighWaterMark+0x4>

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    25fe:	80 e0       	ldi	r24, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2600:	08 95       	ret

00002602 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2602:	80 91 1a 0c 	lds	r24, 0x0C1A
    2606:	90 91 1b 0c 	lds	r25, 0x0C1B

		return xReturn;
	}
    260a:	08 95       	ret

0000260c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    260c:	0f 93       	push	r16
    260e:	1f 93       	push	r17
    2610:	cf 93       	push	r28
    2612:	df 93       	push	r29
    2614:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2616:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2618:	e0 91 1a 0c 	lds	r30, 0x0C1A
    261c:	f0 91 1b 0c 	lds	r31, 0x0C1B
    2620:	92 8d       	ldd	r25, Z+26	; 0x1a
    2622:	89 17       	cp	r24, r25
    2624:	10 f5       	brcc	.+68     	; 0x266a <vTaskPriorityInherit+0x5e>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2626:	e0 91 1a 0c 	lds	r30, 0x0C1A
    262a:	f0 91 1b 0c 	lds	r31, 0x0C1B
    262e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2630:	44 e0       	ldi	r20, 0x04	; 4
    2632:	50 e0       	ldi	r21, 0x00	; 0
    2634:	60 e0       	ldi	r22, 0x00	; 0
    2636:	70 e0       	ldi	r23, 0x00	; 0
    2638:	49 1b       	sub	r20, r25
    263a:	51 09       	sbc	r21, r1
    263c:	61 09       	sbc	r22, r1
    263e:	71 09       	sbc	r23, r1
    2640:	4e 87       	std	Y+14, r20	; 0x0e
    2642:	5f 87       	std	Y+15, r21	; 0x0f
    2644:	68 8b       	std	Y+16, r22	; 0x10
    2646:	79 8b       	std	Y+17, r23	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2648:	2b e0       	ldi	r18, 0x0B	; 11
    264a:	82 9f       	mul	r24, r18
    264c:	c0 01       	movw	r24, r0
    264e:	11 24       	eor	r1, r1
    2650:	80 5b       	subi	r24, 0xB0	; 176
    2652:	93 4f       	sbci	r25, 0xF3	; 243
    2654:	2c 85       	ldd	r18, Y+12	; 0x0c
    2656:	3d 85       	ldd	r19, Y+13	; 0x0d
    2658:	28 17       	cp	r18, r24
    265a:	39 07       	cpc	r19, r25
    265c:	59 f0       	breq	.+22     	; 0x2674 <vTaskPriorityInherit+0x68>
				prvAddTaskToReadyQueue( pxTCB );
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    265e:	e0 91 1a 0c 	lds	r30, 0x0C1A
    2662:	f0 91 1b 0c 	lds	r31, 0x0C1B
    2666:	82 8d       	ldd	r24, Z+26	; 0x1a
    2668:	8a 8f       	std	Y+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    266a:	df 91       	pop	r29
    266c:	cf 91       	pop	r28
    266e:	1f 91       	pop	r17
    2670:	0f 91       	pop	r16
    2672:	08 95       	ret

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2674:	8e 01       	movw	r16, r28
    2676:	0e 5f       	subi	r16, 0xFE	; 254
    2678:	1f 4f       	sbci	r17, 0xFF	; 255
    267a:	c8 01       	movw	r24, r16
    267c:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2680:	e0 91 1a 0c 	lds	r30, 0x0C1A
    2684:	f0 91 1b 0c 	lds	r31, 0x0C1B
    2688:	82 8d       	ldd	r24, Z+26	; 0x1a
    268a:	8a 8f       	std	Y+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    268c:	90 91 22 0c 	lds	r25, 0x0C22
    2690:	98 17       	cp	r25, r24
    2692:	10 f4       	brcc	.+4      	; 0x2698 <vTaskPriorityInherit+0x8c>
    2694:	80 93 22 0c 	sts	0x0C22, r24
    2698:	2b e0       	ldi	r18, 0x0B	; 11
    269a:	82 9f       	mul	r24, r18
    269c:	c0 01       	movw	r24, r0
    269e:	11 24       	eor	r1, r1
    26a0:	b8 01       	movw	r22, r16
    26a2:	80 5b       	subi	r24, 0xB0	; 176
    26a4:	93 4f       	sbci	r25, 0xF3	; 243
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    26a6:	df 91       	pop	r29
    26a8:	cf 91       	pop	r28
    26aa:	1f 91       	pop	r17
    26ac:	0f 91       	pop	r16
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
				prvAddTaskToReadyQueue( pxTCB );
    26ae:	0c 94 35 14 	jmp	0x286a	; 0x286a <vListInsertEnd>

000026b2 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    26b2:	0f 93       	push	r16
    26b4:	1f 93       	push	r17
    26b6:	cf 93       	push	r28
    26b8:	df 93       	push	r29
    26ba:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    26bc:	00 97       	sbiw	r24, 0x00	; 0
    26be:	59 f1       	breq	.+86     	; 0x2716 <vTaskPriorityDisinherit+0x64>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    26c0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    26c2:	8f a1       	ldd	r24, Y+39	; 0x27
    26c4:	98 17       	cp	r25, r24
    26c6:	39 f1       	breq	.+78     	; 0x2716 <vTaskPriorityDisinherit+0x64>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    26c8:	8e 01       	movw	r16, r28
    26ca:	0e 5f       	subi	r16, 0xFE	; 254
    26cc:	1f 4f       	sbci	r17, 0xFF	; 255
    26ce:	c8 01       	movw	r24, r16
    26d0:	0e 94 ab 14 	call	0x2956	; 0x2956 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    26d4:	8f a1       	ldd	r24, Y+39	; 0x27
    26d6:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    26d8:	44 e0       	ldi	r20, 0x04	; 4
    26da:	50 e0       	ldi	r21, 0x00	; 0
    26dc:	60 e0       	ldi	r22, 0x00	; 0
    26de:	70 e0       	ldi	r23, 0x00	; 0
    26e0:	48 1b       	sub	r20, r24
    26e2:	51 09       	sbc	r21, r1
    26e4:	61 09       	sbc	r22, r1
    26e6:	71 09       	sbc	r23, r1
    26e8:	4e 87       	std	Y+14, r20	; 0x0e
    26ea:	5f 87       	std	Y+15, r21	; 0x0f
    26ec:	68 8b       	std	Y+16, r22	; 0x10
    26ee:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    26f0:	90 91 22 0c 	lds	r25, 0x0C22
    26f4:	98 17       	cp	r25, r24
    26f6:	10 f4       	brcc	.+4      	; 0x26fc <vTaskPriorityDisinherit+0x4a>
    26f8:	80 93 22 0c 	sts	0x0C22, r24
    26fc:	2b e0       	ldi	r18, 0x0B	; 11
    26fe:	82 9f       	mul	r24, r18
    2700:	c0 01       	movw	r24, r0
    2702:	11 24       	eor	r1, r1
    2704:	b8 01       	movw	r22, r16
    2706:	80 5b       	subi	r24, 0xB0	; 176
    2708:	93 4f       	sbci	r25, 0xF3	; 243
			}
		}
	}
    270a:	df 91       	pop	r29
    270c:	cf 91       	pop	r28
    270e:	1f 91       	pop	r17
    2710:	0f 91       	pop	r16
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
    2712:	0c 94 35 14 	jmp	0x286a	; 0x286a <vListInsertEnd>
			}
		}
	}
    2716:	df 91       	pop	r29
    2718:	cf 91       	pop	r28
    271a:	1f 91       	pop	r17
    271c:	0f 91       	pop	r16
    271e:	08 95       	ret

00002720 <_ZN7base232C1Ejh>:
    2720:	cf 93       	push	r28
    2722:	df 93       	push	r29
    2724:	ec 01       	movw	r28, r24
    2726:	44 23       	and	r20, r20
    2728:	09 f4       	brne	.+2      	; 0x272c <_ZN7base232C1Ejh+0xc>
    272a:	41 c0       	rjmp	.+130    	; 0x27ae <_ZN7base232C1Ejh+0x8e>
    272c:	8c e9       	ldi	r24, 0x9C	; 156
    272e:	90 e0       	ldi	r25, 0x00	; 0
    2730:	99 83       	std	Y+1, r25	; 0x01
    2732:	88 83       	st	Y, r24
    2734:	8b e9       	ldi	r24, 0x9B	; 155
    2736:	90 e0       	ldi	r25, 0x00	; 0
    2738:	9b 83       	std	Y+3, r25	; 0x03
    273a:	8a 83       	std	Y+2, r24	; 0x02
    273c:	8a e9       	ldi	r24, 0x9A	; 154
    273e:	90 e0       	ldi	r25, 0x00	; 0
    2740:	9d 83       	std	Y+5, r25	; 0x05
    2742:	8c 83       	std	Y+4, r24	; 0x04
    2744:	88 e1       	ldi	r24, 0x18	; 24
    2746:	80 93 9a 00 	sts	0x009A, r24
    274a:	86 e0       	ldi	r24, 0x06	; 6
    274c:	80 93 9d 00 	sts	0x009D, r24
    2750:	10 92 98 00 	sts	0x0098, r1
    2754:	9b 01       	movw	r18, r22
    2756:	40 e0       	ldi	r20, 0x00	; 0
    2758:	50 e0       	ldi	r21, 0x00	; 0
    275a:	22 0f       	add	r18, r18
    275c:	33 1f       	adc	r19, r19
    275e:	44 1f       	adc	r20, r20
    2760:	55 1f       	adc	r21, r21
    2762:	22 0f       	add	r18, r18
    2764:	33 1f       	adc	r19, r19
    2766:	44 1f       	adc	r20, r20
    2768:	55 1f       	adc	r21, r21
    276a:	22 0f       	add	r18, r18
    276c:	33 1f       	adc	r19, r19
    276e:	44 1f       	adc	r20, r20
    2770:	55 1f       	adc	r21, r21
    2772:	22 0f       	add	r18, r18
    2774:	33 1f       	adc	r19, r19
    2776:	44 1f       	adc	r20, r20
    2778:	55 1f       	adc	r21, r21
    277a:	60 e0       	ldi	r22, 0x00	; 0
    277c:	74 e2       	ldi	r23, 0x24	; 36
    277e:	84 ef       	ldi	r24, 0xF4	; 244
    2780:	90 e0       	ldi	r25, 0x00	; 0
    2782:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <__udivmodsi4>
    2786:	20 93 99 00 	sts	0x0099, r18
    278a:	80 91 9b 00 	lds	r24, 0x009B
    278e:	81 60       	ori	r24, 0x01	; 1
    2790:	80 93 9b 00 	sts	0x009B, r24
    2794:	80 e2       	ldi	r24, 0x20	; 32
    2796:	8e 83       	std	Y+6, r24	; 0x06
    2798:	80 e8       	ldi	r24, 0x80	; 128
    279a:	8f 83       	std	Y+7, r24	; 0x07
    279c:	80 e4       	ldi	r24, 0x40	; 64
    279e:	88 87       	std	Y+8, r24	; 0x08
    27a0:	e8 81       	ld	r30, Y
    27a2:	f9 81       	ldd	r31, Y+1	; 0x01
    27a4:	80 81       	ld	r24, Z
    27a6:	80 81       	ld	r24, Z
    27a8:	df 91       	pop	r29
    27aa:	cf 91       	pop	r28
    27ac:	08 95       	ret
    27ae:	8c e2       	ldi	r24, 0x2C	; 44
    27b0:	90 e0       	ldi	r25, 0x00	; 0
    27b2:	99 83       	std	Y+1, r25	; 0x01
    27b4:	88 83       	st	Y, r24
    27b6:	8b e2       	ldi	r24, 0x2B	; 43
    27b8:	90 e0       	ldi	r25, 0x00	; 0
    27ba:	9b 83       	std	Y+3, r25	; 0x03
    27bc:	8a 83       	std	Y+2, r24	; 0x02
    27be:	8a e2       	ldi	r24, 0x2A	; 42
    27c0:	90 e0       	ldi	r25, 0x00	; 0
    27c2:	9d 83       	std	Y+5, r25	; 0x05
    27c4:	8c 83       	std	Y+4, r24	; 0x04
    27c6:	88 e1       	ldi	r24, 0x18	; 24
    27c8:	8a b9       	out	0x0a, r24	; 10
    27ca:	86 e0       	ldi	r24, 0x06	; 6
    27cc:	80 93 95 00 	sts	0x0095, r24
    27d0:	10 92 90 00 	sts	0x0090, r1
    27d4:	9b 01       	movw	r18, r22
    27d6:	40 e0       	ldi	r20, 0x00	; 0
    27d8:	50 e0       	ldi	r21, 0x00	; 0
    27da:	22 0f       	add	r18, r18
    27dc:	33 1f       	adc	r19, r19
    27de:	44 1f       	adc	r20, r20
    27e0:	55 1f       	adc	r21, r21
    27e2:	22 0f       	add	r18, r18
    27e4:	33 1f       	adc	r19, r19
    27e6:	44 1f       	adc	r20, r20
    27e8:	55 1f       	adc	r21, r21
    27ea:	22 0f       	add	r18, r18
    27ec:	33 1f       	adc	r19, r19
    27ee:	44 1f       	adc	r20, r20
    27f0:	55 1f       	adc	r21, r21
    27f2:	22 0f       	add	r18, r18
    27f4:	33 1f       	adc	r19, r19
    27f6:	44 1f       	adc	r20, r20
    27f8:	55 1f       	adc	r21, r21
    27fa:	60 e0       	ldi	r22, 0x00	; 0
    27fc:	74 e2       	ldi	r23, 0x24	; 36
    27fe:	84 ef       	ldi	r24, 0xF4	; 244
    2800:	90 e0       	ldi	r25, 0x00	; 0
    2802:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <__udivmodsi4>
    2806:	29 b9       	out	0x09, r18	; 9
    2808:	58 9a       	sbi	0x0b, 0	; 11
    280a:	c4 cf       	rjmp	.-120    	; 0x2794 <_ZN7base232C1Ejh+0x74>

0000280c <_ZN7base23213ready_to_sendEv>:
    280c:	dc 01       	movw	r26, r24
    280e:	12 96       	adiw	r26, 0x02	; 2
    2810:	ed 91       	ld	r30, X+
    2812:	fc 91       	ld	r31, X
    2814:	13 97       	sbiw	r26, 0x03	; 3
    2816:	20 81       	ld	r18, Z
    2818:	16 96       	adiw	r26, 0x06	; 6
    281a:	8c 91       	ld	r24, X
    281c:	28 23       	and	r18, r24
    281e:	81 e0       	ldi	r24, 0x01	; 1
    2820:	09 f4       	brne	.+2      	; 0x2824 <_ZN7base23213ready_to_sendEv+0x18>
    2822:	80 e0       	ldi	r24, 0x00	; 0
    2824:	08 95       	ret

00002826 <_ZN7base23210is_sendingEv>:
    2826:	dc 01       	movw	r26, r24
    2828:	12 96       	adiw	r26, 0x02	; 2
    282a:	ed 91       	ld	r30, X+
    282c:	fc 91       	ld	r31, X
    282e:	13 97       	sbiw	r26, 0x03	; 3
    2830:	20 81       	ld	r18, Z
    2832:	18 96       	adiw	r26, 0x08	; 8
    2834:	8c 91       	ld	r24, X
    2836:	28 23       	and	r18, r24
    2838:	81 e0       	ldi	r24, 0x01	; 1
    283a:	09 f0       	breq	.+2      	; 0x283e <_ZN7base23210is_sendingEv+0x18>
    283c:	80 e0       	ldi	r24, 0x00	; 0
    283e:	08 95       	ret

00002840 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2840:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2842:	03 96       	adiw	r24, 0x03	; 3
    2844:	92 83       	std	Z+2, r25	; 0x02
    2846:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2848:	4f ef       	ldi	r20, 0xFF	; 255
    284a:	5f ef       	ldi	r21, 0xFF	; 255
    284c:	ba 01       	movw	r22, r20
    284e:	43 83       	std	Z+3, r20	; 0x03
    2850:	54 83       	std	Z+4, r21	; 0x04
    2852:	65 83       	std	Z+5, r22	; 0x05
    2854:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2856:	90 87       	std	Z+8, r25	; 0x08
    2858:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    285a:	92 87       	std	Z+10, r25	; 0x0a
    285c:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    285e:	10 82       	st	Z, r1
    2860:	08 95       	ret

00002862 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2862:	fc 01       	movw	r30, r24
    2864:	13 86       	std	Z+11, r1	; 0x0b
    2866:	12 86       	std	Z+10, r1	; 0x0a
    2868:	08 95       	ret

0000286a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    286a:	cf 93       	push	r28
    286c:	df 93       	push	r29
    286e:	dc 01       	movw	r26, r24
    2870:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2872:	11 96       	adiw	r26, 0x01	; 1
    2874:	2d 91       	ld	r18, X+
    2876:	3c 91       	ld	r19, X
    2878:	12 97       	sbiw	r26, 0x02	; 2

	pxNewListItem->pxNext = pxIndex->pxNext;
    287a:	e9 01       	movw	r28, r18
    287c:	8c 81       	ldd	r24, Y+4	; 0x04
    287e:	9d 81       	ldd	r25, Y+5	; 0x05
    2880:	95 83       	std	Z+5, r25	; 0x05
    2882:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2884:	37 83       	std	Z+7, r19	; 0x07
    2886:	26 83       	std	Z+6, r18	; 0x06
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2888:	8c 81       	ldd	r24, Y+4	; 0x04
    288a:	9d 81       	ldd	r25, Y+5	; 0x05
    288c:	ec 01       	movw	r28, r24
    288e:	7f 83       	std	Y+7, r23	; 0x07
    2890:	6e 83       	std	Y+6, r22	; 0x06
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2892:	e9 01       	movw	r28, r18
    2894:	7d 83       	std	Y+5, r23	; 0x05
    2896:	6c 83       	std	Y+4, r22	; 0x04
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2898:	12 96       	adiw	r26, 0x02	; 2
    289a:	7c 93       	st	X, r23
    289c:	6e 93       	st	-X, r22
    289e:	11 97       	sbiw	r26, 0x01	; 1

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    28a0:	b3 87       	std	Z+11, r27	; 0x0b
    28a2:	a2 87       	std	Z+10, r26	; 0x0a

	( pxList->uxNumberOfItems )++;
    28a4:	8c 91       	ld	r24, X
    28a6:	8f 5f       	subi	r24, 0xFF	; 255
    28a8:	8c 93       	st	X, r24
}
    28aa:	df 91       	pop	r29
    28ac:	cf 91       	pop	r28
    28ae:	08 95       	ret

000028b0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    28b0:	ef 92       	push	r14
    28b2:	ff 92       	push	r15
    28b4:	0f 93       	push	r16
    28b6:	1f 93       	push	r17
    28b8:	cf 93       	push	r28
    28ba:	df 93       	push	r29
    28bc:	7c 01       	movw	r14, r24
    28be:	db 01       	movw	r26, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    28c0:	0d 91       	ld	r16, X+
    28c2:	1d 91       	ld	r17, X+
    28c4:	2d 91       	ld	r18, X+
    28c6:	3c 91       	ld	r19, X
    28c8:	13 97       	sbiw	r26, 0x03	; 3
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    28ca:	0f 3f       	cpi	r16, 0xFF	; 255
    28cc:	8f ef       	ldi	r24, 0xFF	; 255
    28ce:	18 07       	cpc	r17, r24
    28d0:	28 07       	cpc	r18, r24
    28d2:	38 07       	cpc	r19, r24
    28d4:	e1 f1       	breq	.+120    	; 0x294e <vListInsert+0x9e>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    28d6:	f7 01       	movw	r30, r14
    28d8:	33 96       	adiw	r30, 0x03	; 3
    28da:	e7 01       	movw	r28, r14
    28dc:	8f 81       	ldd	r24, Y+7	; 0x07
    28de:	98 85       	ldd	r25, Y+8	; 0x08
    28e0:	ec 01       	movw	r28, r24
    28e2:	48 81       	ld	r20, Y
    28e4:	59 81       	ldd	r21, Y+1	; 0x01
    28e6:	6a 81       	ldd	r22, Y+2	; 0x02
    28e8:	7b 81       	ldd	r23, Y+3	; 0x03
    28ea:	04 17       	cp	r16, r20
    28ec:	15 07       	cpc	r17, r21
    28ee:	26 07       	cpc	r18, r22
    28f0:	37 07       	cpc	r19, r23
    28f2:	78 f0       	brcs	.+30     	; 0x2912 <vListInsert+0x62>
    28f4:	04 80       	ldd	r0, Z+4	; 0x04
    28f6:	f5 81       	ldd	r31, Z+5	; 0x05
    28f8:	e0 2d       	mov	r30, r0
    28fa:	84 81       	ldd	r24, Z+4	; 0x04
    28fc:	95 81       	ldd	r25, Z+5	; 0x05
    28fe:	ec 01       	movw	r28, r24
    2900:	48 81       	ld	r20, Y
    2902:	59 81       	ldd	r21, Y+1	; 0x01
    2904:	6a 81       	ldd	r22, Y+2	; 0x02
    2906:	7b 81       	ldd	r23, Y+3	; 0x03
    2908:	04 17       	cp	r16, r20
    290a:	15 07       	cpc	r17, r21
    290c:	26 07       	cpc	r18, r22
    290e:	37 07       	cpc	r19, r23
    2910:	88 f7       	brcc	.-30     	; 0x28f4 <vListInsert+0x44>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2912:	84 81       	ldd	r24, Z+4	; 0x04
    2914:	95 81       	ldd	r25, Z+5	; 0x05
    2916:	15 96       	adiw	r26, 0x05	; 5
    2918:	9c 93       	st	X, r25
    291a:	8e 93       	st	-X, r24
    291c:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    291e:	ec 01       	movw	r28, r24
    2920:	bf 83       	std	Y+7, r27	; 0x07
    2922:	ae 83       	std	Y+6, r26	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
    2924:	17 96       	adiw	r26, 0x07	; 7
    2926:	fc 93       	st	X, r31
    2928:	ee 93       	st	-X, r30
    292a:	16 97       	sbiw	r26, 0x06	; 6
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    292c:	b5 83       	std	Z+5, r27	; 0x05
    292e:	a4 83       	std	Z+4, r26	; 0x04

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2930:	1b 96       	adiw	r26, 0x0b	; 11
    2932:	fc 92       	st	X, r15
    2934:	ee 92       	st	-X, r14
    2936:	1a 97       	sbiw	r26, 0x0a	; 10

	( pxList->uxNumberOfItems )++;
    2938:	f7 01       	movw	r30, r14
    293a:	80 81       	ld	r24, Z
    293c:	8f 5f       	subi	r24, 0xFF	; 255
    293e:	80 83       	st	Z, r24
}
    2940:	df 91       	pop	r29
    2942:	cf 91       	pop	r28
    2944:	1f 91       	pop	r17
    2946:	0f 91       	pop	r16
    2948:	ff 90       	pop	r15
    294a:	ef 90       	pop	r14
    294c:	08 95       	ret
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    294e:	e7 01       	movw	r28, r14
    2950:	e9 85       	ldd	r30, Y+9	; 0x09
    2952:	fa 85       	ldd	r31, Y+10	; 0x0a
    2954:	de cf       	rjmp	.-68     	; 0x2912 <vListInsert+0x62>

00002956 <vListRemove>:
    2956:	cf 93       	push	r28
    2958:	df 93       	push	r29
    295a:	fc 01       	movw	r30, r24
    295c:	a4 81       	ldd	r26, Z+4	; 0x04
    295e:	b5 81       	ldd	r27, Z+5	; 0x05
    2960:	86 81       	ldd	r24, Z+6	; 0x06
    2962:	97 81       	ldd	r25, Z+7	; 0x07
    2964:	17 96       	adiw	r26, 0x07	; 7
    2966:	9c 93       	st	X, r25
    2968:	8e 93       	st	-X, r24
    296a:	16 97       	sbiw	r26, 0x06	; 6
    296c:	c6 81       	ldd	r28, Z+6	; 0x06
    296e:	d7 81       	ldd	r29, Z+7	; 0x07
    2970:	bd 83       	std	Y+5, r27	; 0x05
    2972:	ac 83       	std	Y+4, r26	; 0x04
    2974:	a2 85       	ldd	r26, Z+10	; 0x0a
    2976:	b3 85       	ldd	r27, Z+11	; 0x0b
    2978:	11 96       	adiw	r26, 0x01	; 1
    297a:	8d 91       	ld	r24, X+
    297c:	9c 91       	ld	r25, X
    297e:	12 97       	sbiw	r26, 0x02	; 2
    2980:	8e 17       	cp	r24, r30
    2982:	9f 07       	cpc	r25, r31
    2984:	41 f0       	breq	.+16     	; 0x2996 <vListRemove+0x40>
    2986:	13 86       	std	Z+11, r1	; 0x0b
    2988:	12 86       	std	Z+10, r1	; 0x0a
    298a:	8c 91       	ld	r24, X
    298c:	81 50       	subi	r24, 0x01	; 1
    298e:	8c 93       	st	X, r24
    2990:	df 91       	pop	r29
    2992:	cf 91       	pop	r28
    2994:	08 95       	ret
    2996:	12 96       	adiw	r26, 0x02	; 2
    2998:	dc 93       	st	X, r29
    299a:	ce 93       	st	-X, r28
    299c:	11 97       	sbiw	r26, 0x01	; 1
    299e:	13 86       	std	Z+11, r1	; 0x0b
    29a0:	12 86       	std	Z+10, r1	; 0x0a
    29a2:	8c 91       	ld	r24, X
    29a4:	81 50       	subi	r24, 0x01	; 1
    29a6:	8c 93       	st	X, r24
    29a8:	df 91       	pop	r29
    29aa:	cf 91       	pop	r28
    29ac:	08 95       	ret

000029ae <_ZN14frt_base_queueImE7butt_inERKm>:
    29ae:	80 e0       	ldi	r24, 0x00	; 0
    29b0:	08 95       	ret

000029b2 <_ZN14frt_base_queueImE11ISR_butt_inERKm>:
    29b2:	80 e0       	ldi	r24, 0x00	; 0
    29b4:	08 95       	ret

000029b6 <_ZN9frt_queueImE3putERKm>:
    29b6:	0f 93       	push	r16
    29b8:	fc 01       	movw	r30, r24
    29ba:	26 81       	ldd	r18, Z+6	; 0x06
    29bc:	37 81       	ldd	r19, Z+7	; 0x07
    29be:	40 85       	ldd	r20, Z+8	; 0x08
    29c0:	51 85       	ldd	r21, Z+9	; 0x09
    29c2:	00 e0       	ldi	r16, 0x00	; 0
    29c4:	84 81       	ldd	r24, Z+4	; 0x04
    29c6:	95 81       	ldd	r25, Z+5	; 0x05
    29c8:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xQueueGenericSend>
    29cc:	91 e0       	ldi	r25, 0x01	; 1
    29ce:	81 11       	cpse	r24, r1
    29d0:	01 c0       	rjmp	.+2      	; 0x29d4 <_ZN9frt_queueImE3putERKm+0x1e>
    29d2:	90 e0       	ldi	r25, 0x00	; 0
    29d4:	89 2f       	mov	r24, r25
    29d6:	0f 91       	pop	r16
    29d8:	08 95       	ret

000029da <_ZN9frt_queueImE7butt_inERKm>:
    29da:	0f 93       	push	r16
    29dc:	fc 01       	movw	r30, r24
    29de:	26 81       	ldd	r18, Z+6	; 0x06
    29e0:	37 81       	ldd	r19, Z+7	; 0x07
    29e2:	40 85       	ldd	r20, Z+8	; 0x08
    29e4:	51 85       	ldd	r21, Z+9	; 0x09
    29e6:	01 e0       	ldi	r16, 0x01	; 1
    29e8:	84 81       	ldd	r24, Z+4	; 0x04
    29ea:	95 81       	ldd	r25, Z+5	; 0x05
    29ec:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xQueueGenericSend>
    29f0:	91 e0       	ldi	r25, 0x01	; 1
    29f2:	81 11       	cpse	r24, r1
    29f4:	01 c0       	rjmp	.+2      	; 0x29f8 <_ZN9frt_queueImE7butt_inERKm+0x1e>
    29f6:	90 e0       	ldi	r25, 0x00	; 0
    29f8:	89 2f       	mov	r24, r25
    29fa:	0f 91       	pop	r16
    29fc:	08 95       	ret

000029fe <_ZN9frt_queueImE7ISR_putERKm>:
    29fe:	cf 93       	push	r28
    2a00:	df 93       	push	r29
    2a02:	1f 92       	push	r1
    2a04:	cd b7       	in	r28, 0x3d	; 61
    2a06:	de b7       	in	r29, 0x3e	; 62
    2a08:	19 82       	std	Y+1, r1	; 0x01
    2a0a:	20 e0       	ldi	r18, 0x00	; 0
    2a0c:	ae 01       	movw	r20, r28
    2a0e:	4f 5f       	subi	r20, 0xFF	; 255
    2a10:	5f 4f       	sbci	r21, 0xFF	; 255
    2a12:	fc 01       	movw	r30, r24
    2a14:	84 81       	ldd	r24, Z+4	; 0x04
    2a16:	95 81       	ldd	r25, Z+5	; 0x05
    2a18:	0e 94 de 0b 	call	0x17bc	; 0x17bc <xQueueGenericSendFromISR>
    2a1c:	91 e0       	ldi	r25, 0x01	; 1
    2a1e:	81 11       	cpse	r24, r1
    2a20:	01 c0       	rjmp	.+2      	; 0x2a24 <_ZN9frt_queueImE7ISR_putERKm+0x26>
    2a22:	90 e0       	ldi	r25, 0x00	; 0
    2a24:	89 2f       	mov	r24, r25
    2a26:	0f 90       	pop	r0
    2a28:	df 91       	pop	r29
    2a2a:	cf 91       	pop	r28
    2a2c:	08 95       	ret

00002a2e <_ZN9frt_queueImE11ISR_butt_inERKm>:
    2a2e:	cf 93       	push	r28
    2a30:	df 93       	push	r29
    2a32:	1f 92       	push	r1
    2a34:	cd b7       	in	r28, 0x3d	; 61
    2a36:	de b7       	in	r29, 0x3e	; 62
    2a38:	19 82       	std	Y+1, r1	; 0x01
    2a3a:	21 e0       	ldi	r18, 0x01	; 1
    2a3c:	ae 01       	movw	r20, r28
    2a3e:	4f 5f       	subi	r20, 0xFF	; 255
    2a40:	5f 4f       	sbci	r21, 0xFF	; 255
    2a42:	fc 01       	movw	r30, r24
    2a44:	84 81       	ldd	r24, Z+4	; 0x04
    2a46:	95 81       	ldd	r25, Z+5	; 0x05
    2a48:	0e 94 de 0b 	call	0x17bc	; 0x17bc <xQueueGenericSendFromISR>
    2a4c:	91 e0       	ldi	r25, 0x01	; 1
    2a4e:	81 11       	cpse	r24, r1
    2a50:	01 c0       	rjmp	.+2      	; 0x2a54 <_ZN9frt_queueImE11ISR_butt_inERKm+0x26>
    2a52:	90 e0       	ldi	r25, 0x00	; 0
    2a54:	89 2f       	mov	r24, r25
    2a56:	0f 90       	pop	r0
    2a58:	df 91       	pop	r29
    2a5a:	cf 91       	pop	r28
    2a5c:	08 95       	ret

00002a5e <_ZN9frt_queueImE3getEv>:
    2a5e:	0f 93       	push	r16
    2a60:	cf 93       	push	r28
    2a62:	df 93       	push	r29
    2a64:	00 d0       	rcall	.+0      	; 0x2a66 <_ZN9frt_queueImE3getEv+0x8>
    2a66:	00 d0       	rcall	.+0      	; 0x2a68 <_ZN9frt_queueImE3getEv+0xa>
    2a68:	cd b7       	in	r28, 0x3d	; 61
    2a6a:	de b7       	in	r29, 0x3e	; 62
    2a6c:	00 e0       	ldi	r16, 0x00	; 0
    2a6e:	2f ef       	ldi	r18, 0xFF	; 255
    2a70:	3f ef       	ldi	r19, 0xFF	; 255
    2a72:	a9 01       	movw	r20, r18
    2a74:	be 01       	movw	r22, r28
    2a76:	6f 5f       	subi	r22, 0xFF	; 255
    2a78:	7f 4f       	sbci	r23, 0xFF	; 255
    2a7a:	fc 01       	movw	r30, r24
    2a7c:	84 81       	ldd	r24, Z+4	; 0x04
    2a7e:	95 81       	ldd	r25, Z+5	; 0x05
    2a80:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xQueueGenericReceive>
    2a84:	69 81       	ldd	r22, Y+1	; 0x01
    2a86:	7a 81       	ldd	r23, Y+2	; 0x02
    2a88:	8b 81       	ldd	r24, Y+3	; 0x03
    2a8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a8c:	0f 90       	pop	r0
    2a8e:	0f 90       	pop	r0
    2a90:	0f 90       	pop	r0
    2a92:	0f 90       	pop	r0
    2a94:	df 91       	pop	r29
    2a96:	cf 91       	pop	r28
    2a98:	0f 91       	pop	r16
    2a9a:	08 95       	ret

00002a9c <_ZN9frt_queueImE3getEPm>:
    2a9c:	0f 93       	push	r16
    2a9e:	00 e0       	ldi	r16, 0x00	; 0
    2aa0:	2f ef       	ldi	r18, 0xFF	; 255
    2aa2:	3f ef       	ldi	r19, 0xFF	; 255
    2aa4:	a9 01       	movw	r20, r18
    2aa6:	fc 01       	movw	r30, r24
    2aa8:	84 81       	ldd	r24, Z+4	; 0x04
    2aaa:	95 81       	ldd	r25, Z+5	; 0x05
    2aac:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xQueueGenericReceive>
    2ab0:	0f 91       	pop	r16
    2ab2:	08 95       	ret

00002ab4 <_ZN9frt_queueImE10get_a_copyEv>:
    2ab4:	0f 93       	push	r16
    2ab6:	cf 93       	push	r28
    2ab8:	df 93       	push	r29
    2aba:	00 d0       	rcall	.+0      	; 0x2abc <_ZN9frt_queueImE10get_a_copyEv+0x8>
    2abc:	00 d0       	rcall	.+0      	; 0x2abe <_ZN9frt_queueImE10get_a_copyEv+0xa>
    2abe:	cd b7       	in	r28, 0x3d	; 61
    2ac0:	de b7       	in	r29, 0x3e	; 62
    2ac2:	01 e0       	ldi	r16, 0x01	; 1
    2ac4:	2f ef       	ldi	r18, 0xFF	; 255
    2ac6:	3f ef       	ldi	r19, 0xFF	; 255
    2ac8:	a9 01       	movw	r20, r18
    2aca:	be 01       	movw	r22, r28
    2acc:	6f 5f       	subi	r22, 0xFF	; 255
    2ace:	7f 4f       	sbci	r23, 0xFF	; 255
    2ad0:	fc 01       	movw	r30, r24
    2ad2:	84 81       	ldd	r24, Z+4	; 0x04
    2ad4:	95 81       	ldd	r25, Z+5	; 0x05
    2ad6:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xQueueGenericReceive>
    2ada:	69 81       	ldd	r22, Y+1	; 0x01
    2adc:	7a 81       	ldd	r23, Y+2	; 0x02
    2ade:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae2:	0f 90       	pop	r0
    2ae4:	0f 90       	pop	r0
    2ae6:	0f 90       	pop	r0
    2ae8:	0f 90       	pop	r0
    2aea:	df 91       	pop	r29
    2aec:	cf 91       	pop	r28
    2aee:	0f 91       	pop	r16
    2af0:	08 95       	ret

00002af2 <_ZN9frt_queueImE10get_a_copyERm>:
    2af2:	0f 93       	push	r16
    2af4:	01 e0       	ldi	r16, 0x01	; 1
    2af6:	2f ef       	ldi	r18, 0xFF	; 255
    2af8:	3f ef       	ldi	r19, 0xFF	; 255
    2afa:	a9 01       	movw	r20, r18
    2afc:	fc 01       	movw	r30, r24
    2afe:	84 81       	ldd	r24, Z+4	; 0x04
    2b00:	95 81       	ldd	r25, Z+5	; 0x05
    2b02:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xQueueGenericReceive>
    2b06:	0f 91       	pop	r16
    2b08:	08 95       	ret

00002b0a <_ZN9frt_queueImE7ISR_getEv>:
    2b0a:	cf 93       	push	r28
    2b0c:	df 93       	push	r29
    2b0e:	00 d0       	rcall	.+0      	; 0x2b10 <_ZN9frt_queueImE7ISR_getEv+0x6>
    2b10:	00 d0       	rcall	.+0      	; 0x2b12 <_ZN9frt_queueImE7ISR_getEv+0x8>
    2b12:	1f 92       	push	r1
    2b14:	cd b7       	in	r28, 0x3d	; 61
    2b16:	de b7       	in	r29, 0x3e	; 62
    2b18:	ae 01       	movw	r20, r28
    2b1a:	4b 5f       	subi	r20, 0xFB	; 251
    2b1c:	5f 4f       	sbci	r21, 0xFF	; 255
    2b1e:	be 01       	movw	r22, r28
    2b20:	6f 5f       	subi	r22, 0xFF	; 255
    2b22:	7f 4f       	sbci	r23, 0xFF	; 255
    2b24:	fc 01       	movw	r30, r24
    2b26:	84 81       	ldd	r24, Z+4	; 0x04
    2b28:	95 81       	ldd	r25, Z+5	; 0x05
    2b2a:	0e 94 e3 0c 	call	0x19c6	; 0x19c6 <xQueueReceiveFromISR>
    2b2e:	69 81       	ldd	r22, Y+1	; 0x01
    2b30:	7a 81       	ldd	r23, Y+2	; 0x02
    2b32:	8b 81       	ldd	r24, Y+3	; 0x03
    2b34:	9c 81       	ldd	r25, Y+4	; 0x04
    2b36:	0f 90       	pop	r0
    2b38:	0f 90       	pop	r0
    2b3a:	0f 90       	pop	r0
    2b3c:	0f 90       	pop	r0
    2b3e:	0f 90       	pop	r0
    2b40:	df 91       	pop	r29
    2b42:	cf 91       	pop	r28
    2b44:	08 95       	ret

00002b46 <_ZN9frt_queueImE7ISR_getEPm>:
    2b46:	cf 93       	push	r28
    2b48:	df 93       	push	r29
    2b4a:	1f 92       	push	r1
    2b4c:	cd b7       	in	r28, 0x3d	; 61
    2b4e:	de b7       	in	r29, 0x3e	; 62
    2b50:	ae 01       	movw	r20, r28
    2b52:	4f 5f       	subi	r20, 0xFF	; 255
    2b54:	5f 4f       	sbci	r21, 0xFF	; 255
    2b56:	fc 01       	movw	r30, r24
    2b58:	84 81       	ldd	r24, Z+4	; 0x04
    2b5a:	95 81       	ldd	r25, Z+5	; 0x05
    2b5c:	0e 94 e3 0c 	call	0x19c6	; 0x19c6 <xQueueReceiveFromISR>
    2b60:	0f 90       	pop	r0
    2b62:	df 91       	pop	r29
    2b64:	cf 91       	pop	r28
    2b66:	08 95       	ret

00002b68 <_ZN9frt_queueImE8is_emptyEv>:
    2b68:	fc 01       	movw	r30, r24
    2b6a:	84 81       	ldd	r24, Z+4	; 0x04
    2b6c:	95 81       	ldd	r25, Z+5	; 0x05
    2b6e:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <uxQueueMessagesWaiting>
    2b72:	91 e0       	ldi	r25, 0x01	; 1
    2b74:	81 11       	cpse	r24, r1
    2b76:	90 e0       	ldi	r25, 0x00	; 0
    2b78:	89 2f       	mov	r24, r25
    2b7a:	08 95       	ret

00002b7c <_ZN9frt_queueImE9not_emptyEv>:
    2b7c:	fc 01       	movw	r30, r24
    2b7e:	84 81       	ldd	r24, Z+4	; 0x04
    2b80:	95 81       	ldd	r25, Z+5	; 0x05
    2b82:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <uxQueueMessagesWaiting>
    2b86:	91 e0       	ldi	r25, 0x01	; 1
    2b88:	81 11       	cpse	r24, r1
    2b8a:	01 c0       	rjmp	.+2      	; 0x2b8e <_ZN9frt_queueImE9not_emptyEv+0x12>
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	89 2f       	mov	r24, r25
    2b90:	08 95       	ret

00002b92 <_ZN9frt_queueImE12num_items_inEv>:
    2b92:	fc 01       	movw	r30, r24
    2b94:	84 81       	ldd	r24, Z+4	; 0x04
    2b96:	95 81       	ldd	r25, Z+5	; 0x05
    2b98:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <uxQueueMessagesWaiting>
    2b9c:	90 e0       	ldi	r25, 0x00	; 0
    2b9e:	08 95       	ret

00002ba0 <_ZN9frt_queueImE12ISR_is_emptyEv>:
    2ba0:	fc 01       	movw	r30, r24
    2ba2:	84 81       	ldd	r24, Z+4	; 0x04
    2ba4:	95 81       	ldd	r25, Z+5	; 0x05
    2ba6:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <uxQueueMessagesWaitingFromISR>
    2baa:	91 e0       	ldi	r25, 0x01	; 1
    2bac:	81 11       	cpse	r24, r1
    2bae:	90 e0       	ldi	r25, 0x00	; 0
    2bb0:	89 2f       	mov	r24, r25
    2bb2:	08 95       	ret

00002bb4 <_ZN9frt_queueImE13ISR_not_emptyEv>:
    2bb4:	fc 01       	movw	r30, r24
    2bb6:	84 81       	ldd	r24, Z+4	; 0x04
    2bb8:	95 81       	ldd	r25, Z+5	; 0x05
    2bba:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <uxQueueMessagesWaitingFromISR>
    2bbe:	91 e0       	ldi	r25, 0x01	; 1
    2bc0:	81 11       	cpse	r24, r1
    2bc2:	01 c0       	rjmp	.+2      	; 0x2bc6 <_ZN9frt_queueImE13ISR_not_emptyEv+0x12>
    2bc4:	90 e0       	ldi	r25, 0x00	; 0
    2bc6:	89 2f       	mov	r24, r25
    2bc8:	08 95       	ret

00002bca <_ZN9frt_queueImE16ISR_num_items_inEv>:
    2bca:	fc 01       	movw	r30, r24
    2bcc:	84 81       	ldd	r24, Z+4	; 0x04
    2bce:	95 81       	ldd	r25, Z+5	; 0x05
    2bd0:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <uxQueueMessagesWaitingFromISR>
    2bd4:	90 e0       	ldi	r25, 0x00	; 0
    2bd6:	08 95       	ret

00002bd8 <main>:
    2bd8:	0f 93       	push	r16
    2bda:	1f 93       	push	r17
    2bdc:	cf 93       	push	r28
    2bde:	df 93       	push	r29
    2be0:	cd b7       	in	r28, 0x3d	; 61
    2be2:	de b7       	in	r29, 0x3e	; 62
    2be4:	62 97       	sbiw	r28, 0x12	; 18
    2be6:	0f b6       	in	r0, 0x3f	; 63
    2be8:	f8 94       	cli
    2bea:	de bf       	out	0x3e, r29	; 62
    2bec:	0f be       	out	0x3f, r0	; 63
    2bee:	cd bf       	out	0x3d, r28	; 61
    2bf0:	88 e1       	ldi	r24, 0x18	; 24
    2bf2:	0f b6       	in	r0, 0x3f	; 63
    2bf4:	f8 94       	cli
    2bf6:	81 bd       	out	0x21, r24	; 33
    2bf8:	11 bc       	out	0x21, r1	; 33
    2bfa:	0f be       	out	0x3f, r0	; 63
    2bfc:	41 e0       	ldi	r20, 0x01	; 1
    2bfe:	60 e8       	ldi	r22, 0x80	; 128
    2c00:	75 e2       	ldi	r23, 0x25	; 37
    2c02:	ce 01       	movw	r24, r28
    2c04:	01 96       	adiw	r24, 0x01	; 1
    2c06:	0e 94 0c 07 	call	0xe18	; 0xe18 <_ZN5rs232C1Ejh>
    2c0a:	82 e1       	ldi	r24, 0x12	; 18
    2c0c:	90 e0       	ldi	r25, 0x00	; 0
    2c0e:	0e 94 be 04 	call	0x97c	; 0x97c <_Znwj>
    2c12:	8e 01       	movw	r16, r28
    2c14:	0f 5f       	subi	r16, 0xFF	; 255
    2c16:	1f 4f       	sbci	r17, 0xFF	; 255
    2c18:	28 e1       	ldi	r18, 0x18	; 24
    2c1a:	31 e0       	ldi	r19, 0x01	; 1
    2c1c:	41 e0       	ldi	r20, 0x01	; 1
    2c1e:	65 e0       	ldi	r22, 0x05	; 5
    2c20:	71 e0       	ldi	r23, 0x01	; 1
    2c22:	0e 94 30 01 	call	0x260	; 0x260 <_ZN10motor_taskC1EPKchjP8emstream>
    2c26:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <vTaskStartScheduler>
    2c2a:	80 e0       	ldi	r24, 0x00	; 0
    2c2c:	90 e0       	ldi	r25, 0x00	; 0
    2c2e:	62 96       	adiw	r28, 0x12	; 18
    2c30:	0f b6       	in	r0, 0x3f	; 63
    2c32:	f8 94       	cli
    2c34:	de bf       	out	0x3e, r29	; 62
    2c36:	0f be       	out	0x3f, r0	; 63
    2c38:	cd bf       	out	0x3d, r28	; 61
    2c3a:	df 91       	pop	r29
    2c3c:	cf 91       	pop	r28
    2c3e:	1f 91       	pop	r17
    2c40:	0f 91       	pop	r16
    2c42:	08 95       	ret

00002c44 <_GLOBAL__sub_I_print_ser_queue>:
    2c44:	0f 93       	push	r16
    2c46:	1f 93       	push	r17
    2c48:	0a e0       	ldi	r16, 0x0A	; 10
    2c4a:	10 e0       	ldi	r17, 0x00	; 0
    2c4c:	20 e0       	ldi	r18, 0x00	; 0
    2c4e:	30 e0       	ldi	r19, 0x00	; 0
    2c50:	40 e0       	ldi	r20, 0x00	; 0
    2c52:	50 e0       	ldi	r21, 0x00	; 0
    2c54:	60 e2       	ldi	r22, 0x20	; 32
    2c56:	70 e0       	ldi	r23, 0x00	; 0
    2c58:	82 e8       	ldi	r24, 0x82	; 130
    2c5a:	91 e0       	ldi	r25, 0x01	; 1
    2c5c:	0e 94 8f 04 	call	0x91e	; 0x91e <_ZN14frt_text_queueC1EjP8emstreamm>
    2c60:	10 92 7b 01 	sts	0x017B, r1
    2c64:	10 92 7a 01 	sts	0x017A, r1
    2c68:	83 e1       	ldi	r24, 0x13	; 19
    2c6a:	91 e0       	ldi	r25, 0x01	; 1
    2c6c:	90 93 79 01 	sts	0x0179, r25
    2c70:	80 93 78 01 	sts	0x0178, r24
    2c74:	40 e0       	ldi	r20, 0x00	; 0
    2c76:	64 e0       	ldi	r22, 0x04	; 4
    2c78:	84 e1       	ldi	r24, 0x14	; 20
    2c7a:	0e 94 bb 0a 	call	0x1576	; 0x1576 <xQueueGenericCreate>
    2c7e:	90 93 7d 01 	sts	0x017D, r25
    2c82:	80 93 7c 01 	sts	0x017C, r24
    2c86:	8f ef       	ldi	r24, 0xFF	; 255
    2c88:	9f ef       	ldi	r25, 0xFF	; 255
    2c8a:	dc 01       	movw	r26, r24
    2c8c:	80 93 7e 01 	sts	0x017E, r24
    2c90:	90 93 7f 01 	sts	0x017F, r25
    2c94:	a0 93 80 01 	sts	0x0180, r26
    2c98:	b0 93 81 01 	sts	0x0181, r27
    2c9c:	1f 91       	pop	r17
    2c9e:	0f 91       	pop	r16
    2ca0:	08 95       	ret

00002ca2 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
    2ca2:	0e 94 34 02 	call	0x468	; 0x468 <_ZN8frt_task22_call_users_run_methodEPS_>

00002ca6 <_ZN14frt_text_queue7putcharEc>:
    2ca6:	0f 93       	push	r16
    2ca8:	cf 93       	push	r28
    2caa:	df 93       	push	r29
    2cac:	1f 92       	push	r1
    2cae:	cd b7       	in	r28, 0x3d	; 61
    2cb0:	de b7       	in	r29, 0x3e	; 62
    2cb2:	69 83       	std	Y+1, r22	; 0x01
    2cb4:	fc 01       	movw	r30, r24
    2cb6:	22 85       	ldd	r18, Z+10	; 0x0a
    2cb8:	33 85       	ldd	r19, Z+11	; 0x0b
    2cba:	44 85       	ldd	r20, Z+12	; 0x0c
    2cbc:	55 85       	ldd	r21, Z+13	; 0x0d
    2cbe:	00 e0       	ldi	r16, 0x00	; 0
    2cc0:	be 01       	movw	r22, r28
    2cc2:	6f 5f       	subi	r22, 0xFF	; 255
    2cc4:	7f 4f       	sbci	r23, 0xFF	; 255
    2cc6:	80 85       	ldd	r24, Z+8	; 0x08
    2cc8:	91 85       	ldd	r25, Z+9	; 0x09
    2cca:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xQueueGenericSend>
    2cce:	91 e0       	ldi	r25, 0x01	; 1
    2cd0:	81 11       	cpse	r24, r1
    2cd2:	01 c0       	rjmp	.+2      	; 0x2cd6 <_ZN14frt_text_queue7putcharEc+0x30>
    2cd4:	90 e0       	ldi	r25, 0x00	; 0
    2cd6:	89 2f       	mov	r24, r25
    2cd8:	0f 90       	pop	r0
    2cda:	df 91       	pop	r29
    2cdc:	cf 91       	pop	r28
    2cde:	0f 91       	pop	r16
    2ce0:	08 95       	ret

00002ce2 <_ZN14frt_text_queue14check_for_charEv>:
    2ce2:	fc 01       	movw	r30, r24
    2ce4:	80 85       	ldd	r24, Z+8	; 0x08
    2ce6:	91 85       	ldd	r25, Z+9	; 0x09
    2ce8:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <uxQueueMessagesWaiting>
    2cec:	91 e0       	ldi	r25, 0x01	; 1
    2cee:	81 11       	cpse	r24, r1
    2cf0:	01 c0       	rjmp	.+2      	; 0x2cf4 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2cf2:	90 e0       	ldi	r25, 0x00	; 0
    2cf4:	89 2f       	mov	r24, r25
    2cf6:	08 95       	ret

00002cf8 <_ZN14frt_text_queue7getcharEv>:
    2cf8:	0f 93       	push	r16
    2cfa:	cf 93       	push	r28
    2cfc:	df 93       	push	r29
    2cfe:	1f 92       	push	r1
    2d00:	cd b7       	in	r28, 0x3d	; 61
    2d02:	de b7       	in	r29, 0x3e	; 62
    2d04:	00 e0       	ldi	r16, 0x00	; 0
    2d06:	2f ef       	ldi	r18, 0xFF	; 255
    2d08:	3f ef       	ldi	r19, 0xFF	; 255
    2d0a:	a9 01       	movw	r20, r18
    2d0c:	be 01       	movw	r22, r28
    2d0e:	6f 5f       	subi	r22, 0xFF	; 255
    2d10:	7f 4f       	sbci	r23, 0xFF	; 255
    2d12:	fc 01       	movw	r30, r24
    2d14:	80 85       	ldd	r24, Z+8	; 0x08
    2d16:	91 85       	ldd	r25, Z+9	; 0x09
    2d18:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xQueueGenericReceive>
    2d1c:	81 30       	cpi	r24, 0x01	; 1
    2d1e:	49 f4       	brne	.+18     	; 0x2d32 <_ZN14frt_text_queue7getcharEv+0x3a>
    2d20:	89 81       	ldd	r24, Y+1	; 0x01
    2d22:	99 27       	eor	r25, r25
    2d24:	87 fd       	sbrc	r24, 7
    2d26:	90 95       	com	r25
    2d28:	0f 90       	pop	r0
    2d2a:	df 91       	pop	r29
    2d2c:	cf 91       	pop	r28
    2d2e:	0f 91       	pop	r16
    2d30:	08 95       	ret
    2d32:	8f ef       	ldi	r24, 0xFF	; 255
    2d34:	9f ef       	ldi	r25, 0xFF	; 255
    2d36:	f8 cf       	rjmp	.-16     	; 0x2d28 <_ZN14frt_text_queue7getcharEv+0x30>

00002d38 <__udivmodsi4>:
    2d38:	a1 e2       	ldi	r26, 0x21	; 33
    2d3a:	1a 2e       	mov	r1, r26
    2d3c:	aa 1b       	sub	r26, r26
    2d3e:	bb 1b       	sub	r27, r27
    2d40:	fd 01       	movw	r30, r26
    2d42:	0d c0       	rjmp	.+26     	; 0x2d5e <__udivmodsi4_ep>

00002d44 <__udivmodsi4_loop>:
    2d44:	aa 1f       	adc	r26, r26
    2d46:	bb 1f       	adc	r27, r27
    2d48:	ee 1f       	adc	r30, r30
    2d4a:	ff 1f       	adc	r31, r31
    2d4c:	a2 17       	cp	r26, r18
    2d4e:	b3 07       	cpc	r27, r19
    2d50:	e4 07       	cpc	r30, r20
    2d52:	f5 07       	cpc	r31, r21
    2d54:	20 f0       	brcs	.+8      	; 0x2d5e <__udivmodsi4_ep>
    2d56:	a2 1b       	sub	r26, r18
    2d58:	b3 0b       	sbc	r27, r19
    2d5a:	e4 0b       	sbc	r30, r20
    2d5c:	f5 0b       	sbc	r31, r21

00002d5e <__udivmodsi4_ep>:
    2d5e:	66 1f       	adc	r22, r22
    2d60:	77 1f       	adc	r23, r23
    2d62:	88 1f       	adc	r24, r24
    2d64:	99 1f       	adc	r25, r25
    2d66:	1a 94       	dec	r1
    2d68:	69 f7       	brne	.-38     	; 0x2d44 <__udivmodsi4_loop>
    2d6a:	60 95       	com	r22
    2d6c:	70 95       	com	r23
    2d6e:	80 95       	com	r24
    2d70:	90 95       	com	r25
    2d72:	9b 01       	movw	r18, r22
    2d74:	ac 01       	movw	r20, r24
    2d76:	bd 01       	movw	r22, r26
    2d78:	cf 01       	movw	r24, r30
    2d7a:	08 95       	ret

00002d7c <__tablejump2__>:
    2d7c:	ee 0f       	add	r30, r30
    2d7e:	ff 1f       	adc	r31, r31

00002d80 <__tablejump__>:
    2d80:	05 90       	lpm	r0, Z+
    2d82:	f4 91       	lpm	r31, Z
    2d84:	e0 2d       	mov	r30, r0
    2d86:	09 94       	ijmp

00002d88 <__tablejump_elpm__>:
    2d88:	07 90       	elpm	r0, Z+
    2d8a:	f6 91       	elpm	r31, Z
    2d8c:	e0 2d       	mov	r30, r0
    2d8e:	09 94       	ijmp

00002d90 <memcpy>:
    2d90:	fb 01       	movw	r30, r22
    2d92:	dc 01       	movw	r26, r24
    2d94:	02 c0       	rjmp	.+4      	; 0x2d9a <memcpy+0xa>
    2d96:	01 90       	ld	r0, Z+
    2d98:	0d 92       	st	X+, r0
    2d9a:	41 50       	subi	r20, 0x01	; 1
    2d9c:	50 40       	sbci	r21, 0x00	; 0
    2d9e:	d8 f7       	brcc	.-10     	; 0x2d96 <memcpy+0x6>
    2da0:	08 95       	ret

00002da2 <memset>:
    2da2:	dc 01       	movw	r26, r24
    2da4:	01 c0       	rjmp	.+2      	; 0x2da8 <memset+0x6>
    2da6:	6d 93       	st	X+, r22
    2da8:	41 50       	subi	r20, 0x01	; 1
    2daa:	50 40       	sbci	r21, 0x00	; 0
    2dac:	e0 f7       	brcc	.-8      	; 0x2da6 <memset+0x4>
    2dae:	08 95       	ret

00002db0 <strncpy>:
    2db0:	fb 01       	movw	r30, r22
    2db2:	dc 01       	movw	r26, r24
    2db4:	41 50       	subi	r20, 0x01	; 1
    2db6:	50 40       	sbci	r21, 0x00	; 0
    2db8:	48 f0       	brcs	.+18     	; 0x2dcc <strncpy+0x1c>
    2dba:	01 90       	ld	r0, Z+
    2dbc:	0d 92       	st	X+, r0
    2dbe:	00 20       	and	r0, r0
    2dc0:	c9 f7       	brne	.-14     	; 0x2db4 <strncpy+0x4>
    2dc2:	01 c0       	rjmp	.+2      	; 0x2dc6 <strncpy+0x16>
    2dc4:	1d 92       	st	X+, r1
    2dc6:	41 50       	subi	r20, 0x01	; 1
    2dc8:	50 40       	sbci	r21, 0x00	; 0
    2dca:	e0 f7       	brcc	.-8      	; 0x2dc4 <strncpy+0x14>
    2dcc:	08 95       	ret

00002dce <ultoa>:
    2dce:	fa 01       	movw	r30, r20
    2dd0:	cf 93       	push	r28
    2dd2:	ff 93       	push	r31
    2dd4:	ef 93       	push	r30
    2dd6:	22 30       	cpi	r18, 0x02	; 2
    2dd8:	cc f0       	brlt	.+50     	; 0x2e0c <ultoa+0x3e>
    2dda:	25 32       	cpi	r18, 0x25	; 37
    2ddc:	bc f4       	brge	.+46     	; 0x2e0c <ultoa+0x3e>
    2dde:	c2 2f       	mov	r28, r18
    2de0:	2c 2f       	mov	r18, r28
    2de2:	33 27       	eor	r19, r19
    2de4:	44 27       	eor	r20, r20
    2de6:	55 27       	eor	r21, r21
    2de8:	ff 93       	push	r31
    2dea:	ef 93       	push	r30
    2dec:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <__udivmodsi4>
    2df0:	ef 91       	pop	r30
    2df2:	ff 91       	pop	r31
    2df4:	60 5d       	subi	r22, 0xD0	; 208
    2df6:	6a 33       	cpi	r22, 0x3A	; 58
    2df8:	0c f0       	brlt	.+2      	; 0x2dfc <ultoa+0x2e>
    2dfa:	69 5d       	subi	r22, 0xD9	; 217
    2dfc:	61 93       	st	Z+, r22
    2dfe:	b9 01       	movw	r22, r18
    2e00:	ca 01       	movw	r24, r20
    2e02:	60 50       	subi	r22, 0x00	; 0
    2e04:	70 40       	sbci	r23, 0x00	; 0
    2e06:	80 40       	sbci	r24, 0x00	; 0
    2e08:	90 40       	sbci	r25, 0x00	; 0
    2e0a:	51 f7       	brne	.-44     	; 0x2de0 <ultoa+0x12>
    2e0c:	10 82       	st	Z, r1
    2e0e:	8f 91       	pop	r24
    2e10:	9f 91       	pop	r25
    2e12:	cf 91       	pop	r28
    2e14:	0c 94 22 17 	jmp	0x2e44	; 0x2e44 <strrev>

00002e18 <utoa>:
    2e18:	fb 01       	movw	r30, r22
    2e1a:	9f 01       	movw	r18, r30
    2e1c:	42 30       	cpi	r20, 0x02	; 2
    2e1e:	74 f0       	brlt	.+28     	; 0x2e3c <utoa+0x24>
    2e20:	45 32       	cpi	r20, 0x25	; 37
    2e22:	64 f4       	brge	.+24     	; 0x2e3c <utoa+0x24>
    2e24:	64 2f       	mov	r22, r20
    2e26:	77 27       	eor	r23, r23
    2e28:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__udivmodhi4>
    2e2c:	80 5d       	subi	r24, 0xD0	; 208
    2e2e:	8a 33       	cpi	r24, 0x3A	; 58
    2e30:	0c f0       	brlt	.+2      	; 0x2e34 <utoa+0x1c>
    2e32:	89 5d       	subi	r24, 0xD9	; 217
    2e34:	81 93       	st	Z+, r24
    2e36:	cb 01       	movw	r24, r22
    2e38:	00 97       	sbiw	r24, 0x00	; 0
    2e3a:	a1 f7       	brne	.-24     	; 0x2e24 <utoa+0xc>
    2e3c:	10 82       	st	Z, r1
    2e3e:	c9 01       	movw	r24, r18
    2e40:	0c 94 22 17 	jmp	0x2e44	; 0x2e44 <strrev>

00002e44 <strrev>:
    2e44:	dc 01       	movw	r26, r24
    2e46:	fc 01       	movw	r30, r24
    2e48:	67 2f       	mov	r22, r23
    2e4a:	71 91       	ld	r23, Z+
    2e4c:	77 23       	and	r23, r23
    2e4e:	e1 f7       	brne	.-8      	; 0x2e48 <strrev+0x4>
    2e50:	32 97       	sbiw	r30, 0x02	; 2
    2e52:	04 c0       	rjmp	.+8      	; 0x2e5c <strrev+0x18>
    2e54:	7c 91       	ld	r23, X
    2e56:	6d 93       	st	X+, r22
    2e58:	70 83       	st	Z, r23
    2e5a:	62 91       	ld	r22, -Z
    2e5c:	ae 17       	cp	r26, r30
    2e5e:	bf 07       	cpc	r27, r31
    2e60:	c8 f3       	brcs	.-14     	; 0x2e54 <strrev+0x10>
    2e62:	08 95       	ret

00002e64 <__udivmodhi4>:
    2e64:	aa 1b       	sub	r26, r26
    2e66:	bb 1b       	sub	r27, r27
    2e68:	51 e1       	ldi	r21, 0x11	; 17
    2e6a:	07 c0       	rjmp	.+14     	; 0x2e7a <__udivmodhi4_ep>

00002e6c <__udivmodhi4_loop>:
    2e6c:	aa 1f       	adc	r26, r26
    2e6e:	bb 1f       	adc	r27, r27
    2e70:	a6 17       	cp	r26, r22
    2e72:	b7 07       	cpc	r27, r23
    2e74:	10 f0       	brcs	.+4      	; 0x2e7a <__udivmodhi4_ep>
    2e76:	a6 1b       	sub	r26, r22
    2e78:	b7 0b       	sbc	r27, r23

00002e7a <__udivmodhi4_ep>:
    2e7a:	88 1f       	adc	r24, r24
    2e7c:	99 1f       	adc	r25, r25
    2e7e:	5a 95       	dec	r21
    2e80:	a9 f7       	brne	.-22     	; 0x2e6c <__udivmodhi4_loop>
    2e82:	80 95       	com	r24
    2e84:	90 95       	com	r25
    2e86:	bc 01       	movw	r22, r24
    2e88:	cd 01       	movw	r24, r26
    2e8a:	08 95       	ret

00002e8c <_exit>:
    2e8c:	f8 94       	cli

00002e8e <__stop_program>:
    2e8e:	ff cf       	rjmp	.-2      	; 0x2e8e <__stop_program>
