
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000078  00800100  00002eac  00002f40  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002eac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000b06  00800178  00800178  00002fb8  2**0
                  ALLOC
  3 .stab         0000c8f4  00000000  00000000  00002fb8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000daaa  00000000  00000000  0000f8ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0001d356  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__ctors_end>
       4:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
       8:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
       c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      10:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      14:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      18:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      1c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      20:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      24:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      28:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      2c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      30:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      34:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      38:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      3c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      40:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      44:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      48:	0c 94 6d 07 	jmp	0xeda	; 0xeda <__vector_18>
      4c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      50:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      54:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      58:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      5c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      60:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      64:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      68:	0c 94 cd 09 	jmp	0x139a	; 0x139a <__vector_26>
      6c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      70:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      74:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      78:	0c 94 bf 07 	jmp	0xf7e	; 0xf7e <__vector_30>
      7c:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      80:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      84:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      88:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__bad_interrupt>
      8c:	4a 05       	cpc	r20, r10
      8e:	53 05       	cpc	r21, r3
      90:	56 05       	cpc	r21, r6
      92:	59 05       	cpc	r21, r9
      94:	5c 05       	cpc	r21, r12
      96:	5f 05       	cpc	r21, r15
      98:	61 05       	cpc	r22, r1
      9a:	71 05       	cpc	r23, r1
      9c:	78 05       	cpc	r23, r8
      9e:	4c 05       	cpc	r20, r12
      a0:	50 05       	cpc	r21, r0

000000a2 <_ZZN8frt_task15emergency_resetEvE3__c>:
      a2:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

000000b1 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
      b1:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000000bb <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_2>:
      bb:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
      cb:	61 73 6b 20 00                                      ask .

000000d0 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c>:
      d0:	54 61 73 6b 20 00                                   Task .

000000d6 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_0>:
      d6:	20 63 72 65 61 74 65 64 00                           created.

000000df <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_1>:
      df:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000000ed <_ZZ15print_task_listP8emstreamE3__c_7>:
      ed:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000000f8 <_ZZ15print_task_listP8emstreamE3__c_8>:
      f8:	2f 00                                               /.

000000fa <_ZZ15print_task_listP8emstreamE3__c_9>:
      fa:	09 09 00                                            ...

000000fd <_ZZ15print_task_listP8emstreamE3__c_4>:
      fd:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

0000010e <_ZZ15print_task_listP8emstreamE3__c_5>:
     10e:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

0000011a <_ZZ15print_task_listP8emstreamE3__c_6>:
     11a:	09 2d 2d 2d 2d 00                                   .----.

00000120 <_ZZ15print_task_listP8emstreamE3__c_1>:
     120:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000131 <_ZZ15print_task_listP8emstreamE3__c_2>:
     131:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000013d <_ZZ15print_task_listP8emstreamE3__c_3>:
     13d:	09 52 75 6e 73 00                                   .Runs.

00000143 <_ZZ15print_task_listP8emstreamE3__c>:
     143:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000014e <_ZZ15print_task_listP8emstreamE3__c_0>:
     14e:	09 53 74 61 63 6b 00                                .Stack.

00000155 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     155:	09 00                                               ..

00000157 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     157:	09 00                                               ..

00000159 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     159:	2f 00                                               /.

0000015b <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     15b:	09 00                                               ..

0000015d <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     15d:	09 00 00                                            ...

00000160 <__ctors_start>:
     160:	30 16       	cp	r3, r16

00000162 <__ctors_end>:
     162:	11 24       	eor	r1, r1
     164:	1f be       	out	0x3f, r1	; 63
     166:	cf ef       	ldi	r28, 0xFF	; 255
     168:	d0 e1       	ldi	r29, 0x10	; 16
     16a:	de bf       	out	0x3e, r29	; 62
     16c:	cd bf       	out	0x3d, r28	; 61

0000016e <__do_copy_data>:
     16e:	11 e0       	ldi	r17, 0x01	; 1
     170:	a0 e0       	ldi	r26, 0x00	; 0
     172:	b1 e0       	ldi	r27, 0x01	; 1
     174:	ec ea       	ldi	r30, 0xAC	; 172
     176:	fe e2       	ldi	r31, 0x2E	; 46
     178:	00 e0       	ldi	r16, 0x00	; 0
     17a:	0b bf       	out	0x3b, r16	; 59
     17c:	02 c0       	rjmp	.+4      	; 0x182 <__do_copy_data+0x14>
     17e:	07 90       	elpm	r0, Z+
     180:	0d 92       	st	X+, r0
     182:	a8 37       	cpi	r26, 0x78	; 120
     184:	b1 07       	cpc	r27, r17
     186:	d9 f7       	brne	.-10     	; 0x17e <__do_copy_data+0x10>

00000188 <__do_clear_bss>:
     188:	1c e0       	ldi	r17, 0x0C	; 12
     18a:	a8 e7       	ldi	r26, 0x78	; 120
     18c:	b1 e0       	ldi	r27, 0x01	; 1
     18e:	01 c0       	rjmp	.+2      	; 0x192 <.do_clear_bss_start>

00000190 <.do_clear_bss_loop>:
     190:	1d 92       	st	X+, r1

00000192 <.do_clear_bss_start>:
     192:	ae 37       	cpi	r26, 0x7E	; 126
     194:	b1 07       	cpc	r27, r17
     196:	e1 f7       	brne	.-8      	; 0x190 <.do_clear_bss_loop>

00000198 <__do_global_ctors>:
     198:	11 e0       	ldi	r17, 0x01	; 1
     19a:	c2 e6       	ldi	r28, 0x62	; 98
     19c:	d1 e0       	ldi	r29, 0x01	; 1
     19e:	00 e0       	ldi	r16, 0x00	; 0
     1a0:	06 c0       	rjmp	.+12     	; 0x1ae <__do_global_ctors+0x16>
     1a2:	22 97       	sbiw	r28, 0x02	; 2
     1a4:	01 09       	sbc	r16, r1
     1a6:	fe 01       	movw	r30, r28
     1a8:	0b bf       	out	0x3b, r16	; 59
     1aa:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <__tablejump_elpm__>
     1ae:	c0 36       	cpi	r28, 0x60	; 96
     1b0:	d1 07       	cpc	r29, r17
     1b2:	80 e0       	ldi	r24, 0x00	; 0
     1b4:	08 07       	cpc	r16, r24
     1b6:	a9 f7       	brne	.-22     	; 0x1a2 <__do_global_ctors+0xa>
     1b8:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <main>
     1bc:	0c 94 54 17 	jmp	0x2ea8	; 0x2ea8 <_exit>

000001c0 <__bad_interrupt>:
     1c0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001c4 <_ZN10motor_task3runEv>:
 *  the motor so that it can be controlled from a high-level user interface. This task
 *  can control multiple motors.
 */

void motor_task::run (void)
{
     1c4:	cf 93       	push	r28
     1c6:	df 93       	push	r29
     1c8:	00 d0       	rcall	.+0      	; 0x1ca <_ZN10motor_task3runEv+0x6>
     1ca:	00 d0       	rcall	.+0      	; 0x1cc <_ZN10motor_task3runEv+0x8>
     1cc:	cd b7       	in	r28, 0x3d	; 61
     1ce:	de b7       	in	r29, 0x3e	; 62
     1d0:	3c 01       	movw	r6, r24
  	portTickType previousTicks = xTaskGetTickCount ();
     1d2:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <xTaskGetTickCount>
     1d6:	69 83       	std	Y+1, r22	; 0x01
     1d8:	7a 83       	std	Y+2, r23	; 0x02
     1da:	8b 83       	std	Y+3, r24	; 0x03
     1dc:	9c 83       	std	Y+4, r25	; 0x04
    
	// Motor Drivers: PC0 = mode select A, PC1 = mode select B, PC2 = Output enable
	
	// pan motor
	motor_driver* yaw_motor = new motor_driver (p_serial, &DDRD, &DDRC, &DDRB, &PORTD, &PORTC, PD7, PC3, PC2, PB5, COM1A1, &OCR1A);
     1de:	84 e1       	ldi	r24, 0x14	; 20
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	0e 94 cc 04 	call	0x998	; 0x998 <_Znwj>
     1e6:	2c 01       	movw	r4, r24
     1e8:	f3 01       	movw	r30, r6
     1ea:	66 81       	ldd	r22, Z+6	; 0x06
     1ec:	77 81       	ldd	r23, Z+7	; 0x07
     1ee:	1f 92       	push	r1
     1f0:	8a e4       	ldi	r24, 0x4A	; 74
     1f2:	8f 93       	push	r24
     1f4:	87 e0       	ldi	r24, 0x07	; 7
     1f6:	8f 93       	push	r24
     1f8:	85 e0       	ldi	r24, 0x05	; 5
     1fa:	8f 93       	push	r24
     1fc:	82 e0       	ldi	r24, 0x02	; 2
     1fe:	8f 93       	push	r24
     200:	83 e0       	ldi	r24, 0x03	; 3
     202:	88 2e       	mov	r8, r24
     204:	97 e0       	ldi	r25, 0x07	; 7
     206:	a9 2e       	mov	r10, r25
     208:	25 e3       	ldi	r18, 0x35	; 53
     20a:	c2 2e       	mov	r12, r18
     20c:	d1 2c       	mov	r13, r1
     20e:	32 e3       	ldi	r19, 0x32	; 50
     210:	e3 2e       	mov	r14, r19
     212:	f1 2c       	mov	r15, r1
     214:	07 e3       	ldi	r16, 0x37	; 55
     216:	10 e0       	ldi	r17, 0x00	; 0
     218:	24 e3       	ldi	r18, 0x34	; 52
     21a:	30 e0       	ldi	r19, 0x00	; 0
     21c:	41 e3       	ldi	r20, 0x31	; 49
     21e:	50 e0       	ldi	r21, 0x00	; 0
     220:	c2 01       	movw	r24, r4
     222:	0e 94 40 01 	call	0x280	; 0x280 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj>
     226:	0f 90       	pop	r0
     228:	0f 90       	pop	r0
     22a:	0f 90       	pop	r0
     22c:	0f 90       	pop	r0
     22e:	0f 90       	pop	r0
	// Enable global interrupts
	
	for (;;)
	{	
	  
		yaw_motor -> brake();
     230:	c2 01       	movw	r24, r4
     232:	0e 94 cc 01 	call	0x398	; 0x398 <_ZN12motor_driver5brakeEv>
		
		runs++;
     236:	f3 01       	movw	r30, r6
     238:	86 85       	ldd	r24, Z+14	; 0x0e
     23a:	97 85       	ldd	r25, Z+15	; 0x0f
     23c:	a0 89       	ldd	r26, Z+16	; 0x10
     23e:	b1 89       	ldd	r27, Z+17	; 0x11
     240:	01 96       	adiw	r24, 0x01	; 1
     242:	a1 1d       	adc	r26, r1
     244:	b1 1d       	adc	r27, r1
     246:	86 87       	std	Z+14, r24	; 0x0e
     248:	97 87       	std	Z+15, r25	; 0x0f
     24a:	a0 8b       	std	Z+16, r26	; 0x10
     24c:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     24e:	4a e0       	ldi	r20, 0x0A	; 10
     250:	50 e0       	ldi	r21, 0x00	; 0
     252:	60 e0       	ldi	r22, 0x00	; 0
     254:	70 e0       	ldi	r23, 0x00	; 0
     256:	ce 01       	movw	r24, r28
     258:	01 96       	adiw	r24, 0x01	; 1
     25a:	0e 94 1e 11 	call	0x223c	; 0x223c <vTaskDelayUntil>
     25e:	e8 cf       	rjmp	.-48     	; 0x230 <_ZN10motor_task3runEv+0x6c>

00000260 <_ZN10motor_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

motor_task::motor_task (const char* a_name, 
     260:	0f 93       	push	r16
     262:	1f 93       	push	r17
     264:	cf 93       	push	r28
     266:	df 93       	push	r29
     268:	ec 01       	movw	r28, r24
								 unsigned portBASE_TYPE a_priority, 
								 size_t a_stack_size,
								 emstream* p_ser_dev
								)
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     26a:	0e 94 55 02 	call	0x4aa	; 0x4aa <_ZN8frt_taskC1EPKchjP8emstream>
     26e:	87 e3       	ldi	r24, 0x37	; 55
     270:	91 e0       	ldi	r25, 0x01	; 1
     272:	99 83       	std	Y+1, r25	; 0x01
     274:	88 83       	st	Y, r24
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     276:	df 91       	pop	r29
     278:	cf 91       	pop	r28
     27a:	1f 91       	pop	r17
     27c:	0f 91       	pop	r16
     27e:	08 95       	ret

00000280 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj>:
 *  @param EN output enable and diagnostics
 *  @param OCR the pwm control register 
 */
	//motor_driver* p_motor_1 = new my_motor_driver (p_serial, &DDRD, &DDRC, &DDRB, &PORTD, &PORTC, PD7, PC3, PC2, PB5, COM1B1, &OCR1B);
//Initialize my_motor_driver
motor_driver::motor_driver (emstream* p_serial_port, volatile uint8_t* DDR_en, volatile uint8_t* DDR_dir, volatile uint8_t* DDR_pwm, volatile uint8_t* PORT_en, volatile uint8_t* PORT_dir, uint8_t ENbit, uint8_t INAbit, uint8_t INBbit, uint8_t PWMbit, uint8_t COMtimer, volatile uint16_t* OCRtimer)
     280:	8f 92       	push	r8
     282:	af 92       	push	r10
     284:	bf 92       	push	r11
     286:	cf 92       	push	r12
     288:	df 92       	push	r13
     28a:	ef 92       	push	r14
     28c:	ff 92       	push	r15
     28e:	0f 93       	push	r16
     290:	1f 93       	push	r17
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	cd b7       	in	r28, 0x3d	; 61
     298:	de b7       	in	r29, 0x3e	; 62
     29a:	fc 01       	movw	r30, r24
{
	ptr_to_serial = p_serial_port;
     29c:	71 83       	std	Z+1, r23	; 0x01
     29e:	60 83       	st	Z, r22
	
	DDR_DIR = DDR_dir;
     2a0:	33 83       	std	Z+3, r19	; 0x03
     2a2:	22 83       	std	Z+2, r18	; 0x02
	DDR_EN = DDR_en;
     2a4:	55 83       	std	Z+5, r21	; 0x05
     2a6:	44 83       	std	Z+4, r20	; 0x04
	DDR_PWM = DDR_pwm;
     2a8:	17 83       	std	Z+7, r17	; 0x07
     2aa:	06 83       	std	Z+6, r16	; 0x06
	
	PORT_EN = PORT_en;
     2ac:	f1 86       	std	Z+9, r15	; 0x09
     2ae:	e0 86       	std	Z+8, r14	; 0x08
	PORT_DIR = PORT_dir;
     2b0:	d3 86       	std	Z+11, r13	; 0x0b
     2b2:	c2 86       	std	Z+10, r12	; 0x0a
	
	COMTIMER = COMtimer;
     2b4:	88 89       	ldd	r24, Y+16	; 0x10
     2b6:	84 87       	std	Z+12, r24	; 0x0c
	
	INA = INAbit; 
     2b8:	85 86       	std	Z+13, r8	; 0x0d
	INB = INBbit; 
     2ba:	8e 85       	ldd	r24, Y+14	; 0x0e
     2bc:	86 87       	std	Z+14, r24	; 0x0e
	EN = ENbit;
     2be:	a7 86       	std	Z+15, r10	; 0x0f
	OCR = OCRtimer;
     2c0:	89 89       	ldd	r24, Y+17	; 0x11
     2c2:	9a 89       	ldd	r25, Y+18	; 0x12
     2c4:	91 8b       	std	Z+17, r25	; 0x11
     2c6:	80 8b       	std	Z+16, r24	; 0x10
	PWM = PWMbit;
     2c8:	8f 85       	ldd	r24, Y+15	; 0x0f
     2ca:	82 8b       	std	Z+18, r24	; 0x12
	
	*DDR_EN |= (1 << EN); // Output enable motors 1 and 2
     2cc:	da 01       	movw	r26, r20
     2ce:	2c 91       	ld	r18, X
     2d0:	81 e0       	ldi	r24, 0x01	; 1
     2d2:	90 e0       	ldi	r25, 0x00	; 0
     2d4:	bc 01       	movw	r22, r24
     2d6:	02 c0       	rjmp	.+4      	; 0x2dc <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x5c>
     2d8:	66 0f       	add	r22, r22
     2da:	77 1f       	adc	r23, r23
     2dc:	aa 94       	dec	r10
     2de:	e2 f7       	brpl	.-8      	; 0x2d8 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x58>
     2e0:	26 2b       	or	r18, r22
     2e2:	2c 93       	st	X, r18
	*DDR_DIR |= (1 << INA) | (1 << INB); // Output enable motors 1 and 2
     2e4:	a2 81       	ldd	r26, Z+2	; 0x02
     2e6:	b3 81       	ldd	r27, Z+3	; 0x03
     2e8:	6c 91       	ld	r22, X
     2ea:	ac 01       	movw	r20, r24
     2ec:	05 84       	ldd	r0, Z+13	; 0x0d
     2ee:	02 c0       	rjmp	.+4      	; 0x2f4 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x74>
     2f0:	44 0f       	add	r20, r20
     2f2:	55 1f       	adc	r21, r21
     2f4:	0a 94       	dec	r0
     2f6:	e2 f7       	brpl	.-8      	; 0x2f0 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x70>
     2f8:	9c 01       	movw	r18, r24
     2fa:	06 84       	ldd	r0, Z+14	; 0x0e
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x82>
     2fe:	22 0f       	add	r18, r18
     300:	33 1f       	adc	r19, r19
     302:	0a 94       	dec	r0
     304:	e2 f7       	brpl	.-8      	; 0x2fe <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x7e>
     306:	24 2b       	or	r18, r20
     308:	26 2b       	or	r18, r22
     30a:	2c 93       	st	X, r18
	*DDR_PWM |= (1 << PWM); // Turn on PWM for motors 1 and 2 as outputs
     30c:	a6 81       	ldd	r26, Z+6	; 0x06
     30e:	b7 81       	ldd	r27, Z+7	; 0x07
     310:	4c 91       	ld	r20, X
     312:	9c 01       	movw	r18, r24
     314:	02 88       	ldd	r0, Z+18	; 0x12
     316:	02 c0       	rjmp	.+4      	; 0x31c <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x9c>
     318:	22 0f       	add	r18, r18
     31a:	33 1f       	adc	r19, r19
     31c:	0a 94       	dec	r0
     31e:	e2 f7       	brpl	.-8      	; 0x318 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0x98>
     320:	42 2b       	or	r20, r18
     322:	4c 93       	st	X, r20

	*PORT_EN |= (1 << EN); // Initialize mode for motor
     324:	a0 85       	ldd	r26, Z+8	; 0x08
     326:	b1 85       	ldd	r27, Z+9	; 0x09
     328:	4c 91       	ld	r20, X
     32a:	9c 01       	movw	r18, r24
     32c:	07 84       	ldd	r0, Z+15	; 0x0f
     32e:	02 c0       	rjmp	.+4      	; 0x334 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xb4>
     330:	22 0f       	add	r18, r18
     332:	33 1f       	adc	r19, r19
     334:	0a 94       	dec	r0
     336:	e2 f7       	brpl	.-8      	; 0x330 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xb0>
     338:	42 2b       	or	r20, r18
     33a:	4c 93       	st	X, r20
	*PORT_DIR |= (1 << INA) | (1 << INB);
     33c:	a2 85       	ldd	r26, Z+10	; 0x0a
     33e:	b3 85       	ldd	r27, Z+11	; 0x0b
     340:	6c 91       	ld	r22, X
     342:	ac 01       	movw	r20, r24
     344:	05 84       	ldd	r0, Z+13	; 0x0d
     346:	02 c0       	rjmp	.+4      	; 0x34c <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xcc>
     348:	44 0f       	add	r20, r20
     34a:	55 1f       	adc	r21, r21
     34c:	0a 94       	dec	r0
     34e:	e2 f7       	brpl	.-8      	; 0x348 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xc8>
     350:	9c 01       	movw	r18, r24
     352:	06 84       	ldd	r0, Z+14	; 0x0e
     354:	02 c0       	rjmp	.+4      	; 0x35a <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xda>
     356:	22 0f       	add	r18, r18
     358:	33 1f       	adc	r19, r19
     35a:	0a 94       	dec	r0
     35c:	e2 f7       	brpl	.-8      	; 0x356 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xd6>
     35e:	24 2b       	or	r18, r20
     360:	26 2b       	or	r18, r22
     362:	2c 93       	st	X, r18
	// To set 10-bit fast PWM mode we must set bits WGM30 and WGM32, which are in two
	// different registers (ugh). We use COM3B1 and Com3B0 to set up the PWM so that
	// the pin output will have inverted sense, that is, a 0 is on and a 1 is off; 
	// this is needed because the LED connects from Vcc to the pin. 
	
	TCCR1A |= (1 << WGM10) | (1 << WGM11) | (1 << COMTIMER);
     364:	2f b5       	in	r18, 0x2f	; 47
     366:	23 60       	ori	r18, 0x03	; 3
     368:	04 84       	ldd	r0, Z+12	; 0x0c
     36a:	02 c0       	rjmp	.+4      	; 0x370 <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xf0>
     36c:	88 0f       	add	r24, r24
     36e:	99 1f       	adc	r25, r25
     370:	0a 94       	dec	r0
     372:	e2 f7       	brpl	.-8      	; 0x36c <_ZN12motor_driverC1EP8emstreamPVhS3_S3_S3_S3_hhhhhPVj+0xec>
     374:	28 2b       	or	r18, r24
     376:	2f bd       	out	0x2f, r18	; 47
	
	// The CS11 bit sets the prescaler for this timer/counter to run the
	// timer at F_CPU / 8
	
	TCCR1B |= (1 << WGM12) | (1 << CS11); // 10-bit PWM and prescale to 8	
     378:	8e b5       	in	r24, 0x2e	; 46
     37a:	8a 60       	ori	r24, 0x0A	; 10
     37c:	8e bd       	out	0x2e, r24	; 46
}
     37e:	df 91       	pop	r29
     380:	cf 91       	pop	r28
     382:	1f 91       	pop	r17
     384:	0f 91       	pop	r16
     386:	ff 90       	pop	r15
     388:	ef 90       	pop	r14
     38a:	df 90       	pop	r13
     38c:	cf 90       	pop	r12
     38e:	bf 90       	pop	r11
     390:	af 90       	pop	r10
     392:	8f 90       	pop	r8
     394:	08 95       	ret

00000396 <_ZN12motor_driver9set_powerEd>:
 *   a pwm signal or duty cycle.
 *  @param  power dictates the value of the PWM
 */

void motor_driver::set_power (double power)
{	
     396:	08 95       	ret

00000398 <_ZN12motor_driver5brakeEv>:
/** \brief This function stops the motor.
 *  \details The brake function sets the mode select bits A & B to the same value.    
 */

void motor_driver::brake (void)
{
     398:	fc 01       	movw	r30, r24
    *PORT_DIR |= (1 << INA) | (1 << INB);
     39a:	a2 85       	ldd	r26, Z+10	; 0x0a
     39c:	b3 85       	ldd	r27, Z+11	; 0x0b
     39e:	6c 91       	ld	r22, X
     3a0:	81 e0       	ldi	r24, 0x01	; 1
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	ac 01       	movw	r20, r24
     3a6:	05 84       	ldd	r0, Z+13	; 0x0d
     3a8:	02 c0       	rjmp	.+4      	; 0x3ae <_ZN12motor_driver5brakeEv+0x16>
     3aa:	44 0f       	add	r20, r20
     3ac:	55 1f       	adc	r21, r21
     3ae:	0a 94       	dec	r0
     3b0:	e2 f7       	brpl	.-8      	; 0x3aa <_ZN12motor_driver5brakeEv+0x12>
     3b2:	9c 01       	movw	r18, r24
     3b4:	06 84       	ldd	r0, Z+14	; 0x0e
     3b6:	02 c0       	rjmp	.+4      	; 0x3bc <_ZN12motor_driver5brakeEv+0x24>
     3b8:	22 0f       	add	r18, r18
     3ba:	33 1f       	adc	r19, r19
     3bc:	0a 94       	dec	r0
     3be:	e2 f7       	brpl	.-8      	; 0x3b8 <_ZN12motor_driver5brakeEv+0x20>
     3c0:	24 2b       	or	r18, r20
     3c2:	26 2b       	or	r18, r22
     3c4:	2c 93       	st	X, r18
   *PORT_EN |= (1 << EN); // Initialize mode for motor
     3c6:	a0 85       	ldd	r26, Z+8	; 0x08
     3c8:	b1 85       	ldd	r27, Z+9	; 0x09
     3ca:	2c 91       	ld	r18, X
     3cc:	07 84       	ldd	r0, Z+15	; 0x0f
     3ce:	02 c0       	rjmp	.+4      	; 0x3d4 <_ZN12motor_driver5brakeEv+0x3c>
     3d0:	88 0f       	add	r24, r24
     3d2:	99 1f       	adc	r25, r25
     3d4:	0a 94       	dec	r0
     3d6:	e2 f7       	brpl	.-8      	; 0x3d0 <_ZN12motor_driver5brakeEv+0x38>
     3d8:	28 2b       	or	r18, r24
     3da:	2c 93       	st	X, r18
   *OCR = 10000;
     3dc:	00 88       	ldd	r0, Z+16	; 0x10
     3de:	f1 89       	ldd	r31, Z+17	; 0x11
     3e0:	e0 2d       	mov	r30, r0
     3e2:	80 e1       	ldi	r24, 0x10	; 16
     3e4:	97 e2       	ldi	r25, 0x27	; 39
     3e6:	91 83       	std	Z+1, r25	; 0x01
     3e8:	80 83       	st	Z, r24
     3ea:	08 95       	ret

000003ec <_ZN12motor_driver7move_cwEv>:
//-------------------------------------------------------------------------------------
/** \brief This function sets the position of the motor.
 *  \details The brake function sets the mode select bits A & B to the same value.    
 */
void motor_driver::move_cw (void)
{
     3ec:	fc 01       	movw	r30, r24
     *OCR = 10000;
     3ee:	a0 89       	ldd	r26, Z+16	; 0x10
     3f0:	b1 89       	ldd	r27, Z+17	; 0x11
     3f2:	80 e1       	ldi	r24, 0x10	; 16
     3f4:	97 e2       	ldi	r25, 0x27	; 39
     3f6:	11 96       	adiw	r26, 0x01	; 1
     3f8:	9c 93       	st	X, r25
     3fa:	8e 93       	st	-X, r24
    *PORT_EN |= (1 << EN); // Initialize mode for motor
     3fc:	a0 85       	ldd	r26, Z+8	; 0x08
     3fe:	b1 85       	ldd	r27, Z+9	; 0x09
     400:	4c 91       	ld	r20, X
     402:	81 e0       	ldi	r24, 0x01	; 1
     404:	90 e0       	ldi	r25, 0x00	; 0
     406:	9c 01       	movw	r18, r24
     408:	07 84       	ldd	r0, Z+15	; 0x0f
     40a:	02 c0       	rjmp	.+4      	; 0x410 <_ZN12motor_driver7move_cwEv+0x24>
     40c:	22 0f       	add	r18, r18
     40e:	33 1f       	adc	r19, r19
     410:	0a 94       	dec	r0
     412:	e2 f7       	brpl	.-8      	; 0x40c <_ZN12motor_driver7move_cwEv+0x20>
     414:	42 2b       	or	r20, r18
     416:	4c 93       	st	X, r20
    if(motor_trans)
     418:	23 89       	ldd	r18, Z+19	; 0x13
    {
     *PORT_DIR |= (1 << INA);
     41a:	a2 85       	ldd	r26, Z+10	; 0x0a
     41c:	b3 85       	ldd	r27, Z+11	; 0x0b
     41e:	4c 91       	ld	r20, X
 */
void motor_driver::move_cw (void)
{
     *OCR = 10000;
    *PORT_EN |= (1 << EN); // Initialize mode for motor
    if(motor_trans)
     420:	21 11       	cpse	r18, r1
     422:	18 c0       	rjmp	.+48     	; 0x454 <_ZN12motor_driver7move_cwEv+0x68>
     *PORT_DIR |= (1 << INA);
     *PORT_DIR &= ~(1 << INB);
     motor_trans = false;
    }
    else{
     *PORT_DIR |= (1 << INB);
     424:	9c 01       	movw	r18, r24
     426:	06 84       	ldd	r0, Z+14	; 0x0e
     428:	02 c0       	rjmp	.+4      	; 0x42e <_ZN12motor_driver7move_cwEv+0x42>
     42a:	22 0f       	add	r18, r18
     42c:	33 1f       	adc	r19, r19
     42e:	0a 94       	dec	r0
     430:	e2 f7       	brpl	.-8      	; 0x42a <_ZN12motor_driver7move_cwEv+0x3e>
     432:	42 2b       	or	r20, r18
     434:	4c 93       	st	X, r20
     *PORT_DIR &= ~(1 << INA);
     436:	a2 85       	ldd	r26, Z+10	; 0x0a
     438:	b3 85       	ldd	r27, Z+11	; 0x0b
     43a:	2c 91       	ld	r18, X
     43c:	05 84       	ldd	r0, Z+13	; 0x0d
     43e:	02 c0       	rjmp	.+4      	; 0x444 <_ZN12motor_driver7move_cwEv+0x58>
     440:	88 0f       	add	r24, r24
     442:	99 1f       	adc	r25, r25
     444:	0a 94       	dec	r0
     446:	e2 f7       	brpl	.-8      	; 0x440 <_ZN12motor_driver7move_cwEv+0x54>
     448:	80 95       	com	r24
     44a:	82 23       	and	r24, r18
     44c:	8c 93       	st	X, r24
     motor_trans = true;
     44e:	81 e0       	ldi	r24, 0x01	; 1
     450:	83 8b       	std	Z+19, r24	; 0x13
     452:	08 95       	ret
{
     *OCR = 10000;
    *PORT_EN |= (1 << EN); // Initialize mode for motor
    if(motor_trans)
    {
     *PORT_DIR |= (1 << INA);
     454:	9c 01       	movw	r18, r24
     456:	05 84       	ldd	r0, Z+13	; 0x0d
     458:	02 c0       	rjmp	.+4      	; 0x45e <_ZN12motor_driver7move_cwEv+0x72>
     45a:	22 0f       	add	r18, r18
     45c:	33 1f       	adc	r19, r19
     45e:	0a 94       	dec	r0
     460:	e2 f7       	brpl	.-8      	; 0x45a <_ZN12motor_driver7move_cwEv+0x6e>
     462:	42 2b       	or	r20, r18
     464:	4c 93       	st	X, r20
     *PORT_DIR &= ~(1 << INB);
     466:	a2 85       	ldd	r26, Z+10	; 0x0a
     468:	b3 85       	ldd	r27, Z+11	; 0x0b
     46a:	2c 91       	ld	r18, X
     46c:	06 84       	ldd	r0, Z+14	; 0x0e
     46e:	02 c0       	rjmp	.+4      	; 0x474 <_ZN12motor_driver7move_cwEv+0x88>
     470:	88 0f       	add	r24, r24
     472:	99 1f       	adc	r25, r25
     474:	0a 94       	dec	r0
     476:	e2 f7       	brpl	.-8      	; 0x470 <_ZN12motor_driver7move_cwEv+0x84>
     478:	80 95       	com	r24
     47a:	82 23       	and	r24, r18
     47c:	8c 93       	st	X, r24
     motor_trans = false;
     47e:	13 8a       	std	Z+19, r1	; 0x13
     480:	08 95       	ret

00000482 <_ZN12motor_driver2PIEv>:
	position_error.put(encoder_desired.get() - encoder_position.get());
	
}*/

void motor_driver::PI(void)
{
     482:	08 95       	ret

00000484 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
     484:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
     486:	e8 81       	ld	r30, Y
     488:	f9 81       	ldd	r31, Y+1	; 0x01
     48a:	01 90       	ld	r0, Z+
     48c:	f0 81       	ld	r31, Z
     48e:	e0 2d       	mov	r30, r0
     490:	09 95       	icall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
     492:	1b 82       	std	Y+3, r1	; 0x03
     494:	1a 82       	std	Y+2, r1	; 0x02

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
     496:	6f ef       	ldi	r22, 0xFF	; 255
     498:	7f ef       	ldi	r23, 0xFF	; 255
     49a:	cb 01       	movw	r24, r22
     49c:	0e 94 8d 11 	call	0x231a	; 0x231a <vTaskDelay>
     4a0:	fa cf       	rjmp	.-12     	; 0x496 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000004a2 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
     4a2:	fc 01       	movw	r30, r24
     4a4:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
     4a6:	65 87       	std	Z+13, r22	; 0x0d
     4a8:	08 95       	ret

000004aa <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     4aa:	2f 92       	push	r2
     4ac:	3f 92       	push	r3
     4ae:	4f 92       	push	r4
     4b0:	5f 92       	push	r5
     4b2:	6f 92       	push	r6
     4b4:	7f 92       	push	r7
     4b6:	8f 92       	push	r8
     4b8:	9f 92       	push	r9
     4ba:	af 92       	push	r10
     4bc:	bf 92       	push	r11
     4be:	cf 92       	push	r12
     4c0:	df 92       	push	r13
     4c2:	ef 92       	push	r14
     4c4:	ff 92       	push	r15
     4c6:	0f 93       	push	r16
     4c8:	1f 93       	push	r17
     4ca:	cf 93       	push	r28
     4cc:	df 93       	push	r29
     4ce:	cd b7       	in	r28, 0x3d	; 61
     4d0:	de b7       	in	r29, 0x3e	; 62
     4d2:	2a 97       	sbiw	r28, 0x0a	; 10
     4d4:	0f b6       	in	r0, 0x3f	; 63
     4d6:	f8 94       	cli
     4d8:	de bf       	out	0x3e, r29	; 62
     4da:	0f be       	out	0x3f, r0	; 63
     4dc:	cd bf       	out	0x3d, r28	; 61
     4de:	4c 01       	movw	r8, r24
     4e0:	19 01       	movw	r2, r18
     4e2:	28 01       	movw	r4, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
     4e4:	8f e3       	ldi	r24, 0x3F	; 63
     4e6:	91 e0       	ldi	r25, 0x01	; 1
     4e8:	f4 01       	movw	r30, r8
     4ea:	91 83       	std	Z+1, r25	; 0x01
     4ec:	80 83       	st	Z, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     4ee:	fb 01       	movw	r30, r22
     4f0:	80 81       	ld	r24, Z
     4f2:	88 23       	and	r24, r24
     4f4:	09 f4       	brne	.+2      	; 0x4f8 <_ZN8frt_taskC1EPKchjP8emstream+0x4e>
     4f6:	a5 c0       	rjmp	.+330    	; 0x642 <_ZN8frt_taskC1EPKchjP8emstream+0x198>
     4f8:	9e 01       	movw	r18, r28
     4fa:	2f 5f       	subi	r18, 0xFF	; 255
     4fc:	3f 4f       	sbci	r19, 0xFF	; 255
     4fe:	39 01       	movw	r6, r18
     500:	d9 01       	movw	r26, r18
     502:	31 96       	adiw	r30, 0x01	; 1
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
     504:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
     506:	9f 5f       	subi	r25, 0xFF	; 255
     508:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     50a:	81 91       	ld	r24, Z+
     50c:	88 23       	and	r24, r24
     50e:	09 f4       	brne	.+2      	; 0x512 <_ZN8frt_taskC1EPKchjP8emstream+0x68>
     510:	69 c0       	rjmp	.+210    	; 0x5e4 <_ZN8frt_taskC1EPKchjP8emstream+0x13a>
     512:	99 30       	cpi	r25, 0x09	; 9
     514:	c1 f7       	brne	.-16     	; 0x506 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
     516:	e9 e0       	ldi	r30, 0x09	; 9
     518:	f0 e0       	ldi	r31, 0x00	; 0
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
     51a:	e6 0d       	add	r30, r6
     51c:	f7 1d       	adc	r31, r7
     51e:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
     520:	74 01       	movw	r14, r8
     522:	92 e0       	ldi	r25, 0x02	; 2
     524:	e9 0e       	add	r14, r25
     526:	f1 1c       	adc	r15, r1
     528:	a1 2c       	mov	r10, r1
     52a:	b1 2c       	mov	r11, r1
     52c:	c1 2c       	mov	r12, r1
     52e:	d1 2c       	mov	r13, r1
     530:	04 2f       	mov	r16, r20
     532:	94 01       	movw	r18, r8
     534:	a1 01       	movw	r20, r2
     536:	b3 01       	movw	r22, r6
     538:	8f e5       	ldi	r24, 0x5F	; 95
     53a:	96 e1       	ldi	r25, 0x16	; 22
     53c:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
     540:	f4 01       	movw	r30, r8
     542:	57 82       	std	Z+7, r5	; 0x07
     544:	46 82       	std	Z+6, r4	; 0x06
	total_stack = a_stack_size;
     546:	31 86       	std	Z+9, r3	; 0x09
     548:	20 86       	std	Z+8, r2	; 0x08

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
     54a:	20 91 92 01 	lds	r18, 0x0192
     54e:	30 91 93 01 	lds	r19, 0x0193
     552:	35 83       	std	Z+5, r19	; 0x05
     554:	24 83       	std	Z+4, r18	; 0x04
	last_created_task_pointer = this;
     556:	90 92 93 01 	sts	0x0193, r9
     55a:	80 92 92 01 	sts	0x0192, r8

	// Initialize the finite state machine and its transition logger
	state = 0;
     55e:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
     560:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
     562:	20 90 7c 0c 	lds	r2, 0x0C7C
     566:	30 90 7d 0c 	lds	r3, 0x0C7D
     56a:	ff ef       	ldi	r31, 0xFF	; 255
     56c:	2f 1a       	sub	r2, r31
     56e:	3f 0a       	sbc	r3, r31
     570:	30 92 7d 0c 	sts	0x0C7D, r3
     574:	20 92 7c 0c 	sts	0x0C7C, r2
     578:	f4 01       	movw	r30, r8
     57a:	33 86       	std	Z+11, r3	; 0x0b
     57c:	22 86       	std	Z+10, r2	; 0x0a

	// Initialize the run counter
	runs = 0;
     57e:	16 86       	std	Z+14, r1	; 0x0e
     580:	17 86       	std	Z+15, r1	; 0x0f
     582:	10 8a       	std	Z+16, r1	; 0x10
     584:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
     586:	41 14       	cp	r4, r1
     588:	51 04       	cpc	r5, r1
     58a:	99 f0       	breq	.+38     	; 0x5b2 <_ZN8frt_taskC1EPKchjP8emstream+0x108>
	{
		if (task_status == pdPASS)
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
     58c:	6a e0       	ldi	r22, 0x0A	; 10

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
	{
		if (task_status == pdPASS)
     58e:	81 30       	cpi	r24, 0x01	; 1
     590:	61 f1       	breq	.+88     	; 0x5ea <_ZN8frt_taskC1EPKchjP8emstream+0x140>
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
     592:	c2 01       	movw	r24, r4
     594:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     598:	4c 01       	movw	r8, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     59a:	6b eb       	ldi	r22, 0xBB	; 187
     59c:	70 e0       	ldi	r23, 0x00	; 0
     59e:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     5a2:	b3 01       	movw	r22, r6
     5a4:	c4 01       	movw	r24, r8
     5a6:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     5aa:	66 e0       	ldi	r22, 0x06	; 6
     5ac:	c4 01       	movw	r24, r8
     5ae:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
     5b2:	2a 96       	adiw	r28, 0x0a	; 10
     5b4:	0f b6       	in	r0, 0x3f	; 63
     5b6:	f8 94       	cli
     5b8:	de bf       	out	0x3e, r29	; 62
     5ba:	0f be       	out	0x3f, r0	; 63
     5bc:	cd bf       	out	0x3d, r28	; 61
     5be:	df 91       	pop	r29
     5c0:	cf 91       	pop	r28
     5c2:	1f 91       	pop	r17
     5c4:	0f 91       	pop	r16
     5c6:	ff 90       	pop	r15
     5c8:	ef 90       	pop	r14
     5ca:	df 90       	pop	r13
     5cc:	cf 90       	pop	r12
     5ce:	bf 90       	pop	r11
     5d0:	af 90       	pop	r10
     5d2:	9f 90       	pop	r9
     5d4:	8f 90       	pop	r8
     5d6:	7f 90       	pop	r7
     5d8:	6f 90       	pop	r6
     5da:	5f 90       	pop	r5
     5dc:	4f 90       	pop	r4
     5de:	3f 90       	pop	r3
     5e0:	2f 90       	pop	r2
     5e2:	08 95       	ret
     5e4:	e9 2f       	mov	r30, r25
     5e6:	f0 e0       	ldi	r31, 0x00	; 0
     5e8:	98 cf       	rjmp	.-208    	; 0x51a <_ZN8frt_taskC1EPKchjP8emstream+0x70>
	// successfully
	if (p_serial != NULL)
	{
		if (task_status == pdPASS)
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
     5ea:	c2 01       	movw	r24, r4
     5ec:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     5f0:	7c 01       	movw	r14, r24
     5f2:	60 ed       	ldi	r22, 0xD0	; 208
     5f4:	70 e0       	ldi	r23, 0x00	; 0
     5f6:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     5fa:	b3 01       	movw	r22, r6
     5fc:	c7 01       	movw	r24, r14
     5fe:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     602:	6a e0       	ldi	r22, 0x0A	; 10
     604:	c7 01       	movw	r24, r14
     606:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     60a:	7c 01       	movw	r14, r24
     60c:	66 ed       	ldi	r22, 0xD6	; 214
     60e:	70 e0       	ldi	r23, 0x00	; 0
     610:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
     614:	6a e0       	ldi	r22, 0x0A	; 10
     616:	c7 01       	movw	r24, r14
     618:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     61c:	7c 01       	movw	r14, r24
     61e:	6f ed       	ldi	r22, 0xDF	; 223
     620:	70 e0       	ldi	r23, 0x00	; 0
     622:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     626:	63 e0       	ldi	r22, 0x03	; 3
     628:	c7 01       	movw	r24, r14
     62a:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     62e:	b1 01       	movw	r22, r2
     630:	0e 94 7f 05 	call	0xafe	; 0xafe <_ZN8emstreamlsEj>
     634:	62 e0       	ldi	r22, 0x02	; 2
     636:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     63a:	66 e0       	ldi	r22, 0x06	; 6
     63c:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     640:	b8 cf       	rjmp	.-144    	; 0x5b2 <_ZN8frt_taskC1EPKchjP8emstream+0x108>
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     642:	e0 e0       	ldi	r30, 0x00	; 0
     644:	f0 e0       	ldi	r31, 0x00	; 0
     646:	ce 01       	movw	r24, r28
     648:	01 96       	adiw	r24, 0x01	; 1
     64a:	3c 01       	movw	r6, r24
     64c:	66 cf       	rjmp	.-308    	; 0x51a <_ZN8frt_taskC1EPKchjP8emstream+0x70>

0000064e <_ZN8frt_task15emergency_resetEv>:
/** This method prints an error message and resets the processor. It should only be 
 *  used in cases of things going seriously to heck.
 */

void frt_task::emergency_reset (void)
{
     64e:	ec 01       	movw	r28, r24
		*  terminated character array belonging to the task. 
		*  @return A pointer to the task's name
		*/
		const char* get_name (void)
		{
			return ((const char*)(pcTaskGetTaskName (handle)));
     650:	8a 81       	ldd	r24, Y+2	; 0x02
     652:	9b 81       	ldd	r25, Y+3	; 0x03
     654:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <pcTaskGetTaskName>
     658:	8c 01       	movw	r16, r24
	*p_serial << PMS ("ERROR in task ") << get_name () << PMS ("Resetting") << endl;
     65a:	6a e0       	ldi	r22, 0x0A	; 10
     65c:	8e 81       	ldd	r24, Y+6	; 0x06
     65e:	9f 81       	ldd	r25, Y+7	; 0x07
     660:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     664:	ec 01       	movw	r28, r24
     666:	62 ea       	ldi	r22, 0xA2	; 162
     668:	70 e0       	ldi	r23, 0x00	; 0
     66a:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     66e:	b8 01       	movw	r22, r16
     670:	ce 01       	movw	r24, r28
     672:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     676:	6a e0       	ldi	r22, 0x0A	; 10
     678:	ce 01       	movw	r24, r28
     67a:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     67e:	ec 01       	movw	r28, r24
     680:	61 eb       	ldi	r22, 0xB1	; 177
     682:	70 e0       	ldi	r23, 0x00	; 0
     684:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     688:	66 e0       	ldi	r22, 0x06	; 6
     68a:	ce 01       	movw	r24, r28
     68c:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
	wdt_enable (WDTO_120MS);
     690:	2b e0       	ldi	r18, 0x0B	; 11
     692:	88 e1       	ldi	r24, 0x18	; 24
     694:	90 e0       	ldi	r25, 0x00	; 0
     696:	0f b6       	in	r0, 0x3f	; 63
     698:	f8 94       	cli
     69a:	a8 95       	wdr
     69c:	81 bd       	out	0x21, r24	; 33
     69e:	0f be       	out	0x3f, r0	; 63
     6a0:	21 bd       	out	0x21, r18	; 33
     6a2:	ff cf       	rjmp	.-2      	; 0x6a2 <_ZN8frt_task15emergency_resetEv+0x54>

000006a4 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
     6a4:	8f 92       	push	r8
     6a6:	9f 92       	push	r9
     6a8:	af 92       	push	r10
     6aa:	bf 92       	push	r11
     6ac:	cf 92       	push	r12
     6ae:	df 92       	push	r13
     6b0:	ef 92       	push	r14
     6b2:	ff 92       	push	r15
     6b4:	0f 93       	push	r16
     6b6:	1f 93       	push	r17
     6b8:	cf 93       	push	r28
     6ba:	df 93       	push	r29
     6bc:	ec 01       	movw	r28, r24
     6be:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
     6c0:	8a 81       	ldd	r24, Y+2	; 0x02
     6c2:	9b 81       	ldd	r25, Y+3	; 0x03
     6c4:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <pcTaskGetTaskName>
     6c8:	bc 01       	movw	r22, r24
     6ca:	c8 01       	movw	r24, r16
     6cc:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
     6d0:	d8 01       	movw	r26, r16
     6d2:	ed 91       	ld	r30, X+
     6d4:	fc 91       	ld	r31, X
     6d6:	02 80       	ldd	r0, Z+2	; 0x02
     6d8:	f3 81       	ldd	r31, Z+3	; 0x03
     6da:	e0 2d       	mov	r30, r0
     6dc:	69 e0       	ldi	r22, 0x09	; 9
     6de:	c8 01       	movw	r24, r16
     6e0:	09 95       	icall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
     6e2:	8a 81       	ldd	r24, Y+2	; 0x02
     6e4:	9b 81       	ldd	r25, Y+3	; 0x03
     6e6:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <pcTaskGetTaskName>
     6ea:	fc 01       	movw	r30, r24
     6ec:	01 90       	ld	r0, Z+
     6ee:	00 20       	and	r0, r0
     6f0:	e9 f7       	brne	.-6      	; 0x6ec <_ZN8frt_task12print_statusER8emstream+0x48>
     6f2:	31 97       	sbiw	r30, 0x01	; 1
     6f4:	e8 1b       	sub	r30, r24
     6f6:	f9 0b       	sbc	r31, r25
     6f8:	38 97       	sbiw	r30, 0x08	; 8
     6fa:	48 f4       	brcc	.+18     	; 0x70e <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
     6fc:	d8 01       	movw	r26, r16
     6fe:	ed 91       	ld	r30, X+
     700:	fc 91       	ld	r31, X
     702:	02 80       	ldd	r0, Z+2	; 0x02
     704:	f3 81       	ldd	r31, Z+3	; 0x03
     706:	e0 2d       	mov	r30, r0
     708:	69 e0       	ldi	r22, 0x09	; 9
     70a:	c8 01       	movw	r24, r16
     70c:	09 95       	icall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
     70e:	ce 84       	ldd	r12, Y+14	; 0x0e
     710:	df 84       	ldd	r13, Y+15	; 0x0f
     712:	e8 88       	ldd	r14, Y+16	; 0x10
     714:	f9 88       	ldd	r15, Y+17	; 0x11
 *  declared virtual so that descendents can override it to print additional 
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
     716:	a8 84       	ldd	r10, Y+8	; 0x08
     718:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
     71a:	8a 81       	ldd	r24, Y+2	; 0x02
     71c:	9b 81       	ldd	r25, Y+3	; 0x03
     71e:	0e 94 f6 12 	call	0x25ec	; 0x25ec <uxTaskGetStackHighWaterMark>
     722:	98 2e       	mov	r9, r24
 *  declared virtual so that descendents can override it to print additional 
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
     724:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
     726:	8a 81       	ldd	r24, Y+2	; 0x02
     728:	9b 81       	ldd	r25, Y+3	; 0x03
     72a:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <uxTaskPriorityGet>
     72e:	68 2f       	mov	r22, r24
     730:	c8 01       	movw	r24, r16
     732:	0e 94 01 06 	call	0xc02	; 0xc02 <_ZN8emstreamlsEh>
     736:	6a e0       	ldi	r22, 0x0A	; 10
     738:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     73c:	ec 01       	movw	r28, r24
     73e:	65 e5       	ldi	r22, 0x55	; 85
     740:	71 e0       	ldi	r23, 0x01	; 1
     742:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
			<< get_state ()
     746:	68 2d       	mov	r22, r8
     748:	ce 01       	movw	r24, r28
     74a:	0e 94 01 06 	call	0xc02	; 0xc02 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
     74e:	6a e0       	ldi	r22, 0x0A	; 10
     750:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     754:	ec 01       	movw	r28, r24
     756:	67 e5       	ldi	r22, 0x57	; 87
     758:	71 e0       	ldi	r23, 0x01	; 1
     75a:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     75e:	69 2d       	mov	r22, r9
     760:	ce 01       	movw	r24, r28
     762:	0e 94 01 06 	call	0xc02	; 0xc02 <_ZN8emstreamlsEh>
     766:	6a e0       	ldi	r22, 0x0A	; 10
     768:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     76c:	ec 01       	movw	r28, r24
     76e:	69 e5       	ldi	r22, 0x59	; 89
     770:	71 e0       	ldi	r23, 0x01	; 1
     772:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
     776:	b5 01       	movw	r22, r10
     778:	ce 01       	movw	r24, r28
     77a:	0e 94 7f 05 	call	0xafe	; 0xafe <_ZN8emstreamlsEj>
     77e:	6a e0       	ldi	r22, 0x0A	; 10
     780:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     784:	ec 01       	movw	r28, r24
     786:	6b e5       	ldi	r22, 0x5B	; 91
     788:	71 e0       	ldi	r23, 0x01	; 1
     78a:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
     78e:	6a e0       	ldi	r22, 0x0A	; 10
     790:	ce 01       	movw	r24, r28
     792:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     796:	ec 01       	movw	r28, r24
     798:	6d e5       	ldi	r22, 0x5D	; 93
     79a:	71 e0       	ldi	r23, 0x01	; 1
     79c:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     7a0:	b7 01       	movw	r22, r14
     7a2:	a6 01       	movw	r20, r12
     7a4:	ce 01       	movw	r24, r28
}
     7a6:	df 91       	pop	r29
     7a8:	cf 91       	pop	r28
     7aa:	1f 91       	pop	r17
     7ac:	0f 91       	pop	r16
     7ae:	ff 90       	pop	r15
     7b0:	ef 90       	pop	r14
     7b2:	df 90       	pop	r13
     7b4:	cf 90       	pop	r12
     7b6:	bf 90       	pop	r11
     7b8:	af 90       	pop	r10
     7ba:	9f 90       	pop	r9
     7bc:	8f 90       	pop	r8
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
     7be:	0c 94 b9 05 	jmp	0xb72	; 0xb72 <_ZN8emstreamlsEm>

000007c2 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
     7c2:	0f 93       	push	r16
     7c4:	1f 93       	push	r17
     7c6:	cf 93       	push	r28
     7c8:	df 93       	push	r29
     7ca:	ec 01       	movw	r28, r24
     7cc:	8b 01       	movw	r16, r22
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
	a_task.print_status (ser_dev);
     7ce:	e8 81       	ld	r30, Y
     7d0:	f9 81       	ldd	r31, Y+1	; 0x01
     7d2:	02 80       	ldd	r0, Z+2	; 0x02
     7d4:	f3 81       	ldd	r31, Z+3	; 0x03
     7d6:	e0 2d       	mov	r30, r0
     7d8:	b8 01       	movw	r22, r16
     7da:	ce 01       	movw	r24, r28
     7dc:	09 95       	icall
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
	*ser_device << *this << endl;
     7de:	66 e0       	ldi	r22, 0x06	; 6
     7e0:	c8 01       	movw	r24, r16
     7e2:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
     7e6:	0c 80       	ldd	r0, Y+4	; 0x04
     7e8:	dd 81       	ldd	r29, Y+5	; 0x05
     7ea:	c0 2d       	mov	r28, r0
     7ec:	20 97       	sbiw	r28, 0x00	; 0
     7ee:	79 f7       	brne	.-34     	; 0x7ce <_ZN8frt_task20print_status_in_listEP8emstream+0xc>
	{
		prev_task_pointer->print_status_in_list (ser_device);
	}
}
     7f0:	df 91       	pop	r29
     7f2:	cf 91       	pop	r28
     7f4:	1f 91       	pop	r17
     7f6:	0f 91       	pop	r16
     7f8:	08 95       	ret

000007fa <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
     7fa:	cf 93       	push	r28
     7fc:	df 93       	push	r29
     7fe:	ec 01       	movw	r28, r24
     800:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
     802:	db 01       	movw	r26, r22
     804:	ed 91       	ld	r30, X+
     806:	fc 91       	ld	r31, X
     808:	02 80       	ldd	r0, Z+2	; 0x02
     80a:	f3 81       	ldd	r31, Z+3	; 0x03
     80c:	e0 2d       	mov	r30, r0
     80e:	be 01       	movw	r22, r28
     810:	09 95       	icall
	return (ser_dev);
}
     812:	ce 01       	movw	r24, r28
     814:	df 91       	pop	r29
     816:	cf 91       	pop	r28
     818:	08 95       	ret

0000081a <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
     81a:	0f 93       	push	r16
     81c:	1f 93       	push	r17
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
     824:	6a e0       	ldi	r22, 0x0A	; 10
     826:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     82a:	8c 01       	movw	r16, r24
     82c:	63 e4       	ldi	r22, 0x43	; 67
     82e:	71 e0       	ldi	r23, 0x01	; 1
     830:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
     834:	6a e0       	ldi	r22, 0x0A	; 10
     836:	c8 01       	movw	r24, r16
     838:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     83c:	8c 01       	movw	r16, r24
     83e:	6e e4       	ldi	r22, 0x4E	; 78
     840:	71 e0       	ldi	r23, 0x01	; 1
     842:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
     846:	66 e0       	ldi	r22, 0x06	; 6
     848:	c8 01       	movw	r24, r16
     84a:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
     84e:	6a e0       	ldi	r22, 0x0A	; 10
     850:	ce 01       	movw	r24, r28
     852:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     856:	8c 01       	movw	r16, r24
     858:	60 e2       	ldi	r22, 0x20	; 32
     85a:	71 e0       	ldi	r23, 0x01	; 1
     85c:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
     860:	6a e0       	ldi	r22, 0x0A	; 10
     862:	c8 01       	movw	r24, r16
     864:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     868:	8c 01       	movw	r16, r24
     86a:	61 e3       	ldi	r22, 0x31	; 49
     86c:	71 e0       	ldi	r23, 0x01	; 1
     86e:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
     872:	6a e0       	ldi	r22, 0x0A	; 10
     874:	c8 01       	movw	r24, r16
     876:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     87a:	8c 01       	movw	r16, r24
     87c:	6d e3       	ldi	r22, 0x3D	; 61
     87e:	71 e0       	ldi	r23, 0x01	; 1
     880:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     884:	66 e0       	ldi	r22, 0x06	; 6
     886:	c8 01       	movw	r24, r16
     888:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
     88c:	6a e0       	ldi	r22, 0x0A	; 10
     88e:	ce 01       	movw	r24, r28
     890:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     894:	8c 01       	movw	r16, r24
     896:	6d ef       	ldi	r22, 0xFD	; 253
     898:	70 e0       	ldi	r23, 0x00	; 0
     89a:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
     89e:	6a e0       	ldi	r22, 0x0A	; 10
     8a0:	c8 01       	movw	r24, r16
     8a2:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     8a6:	8c 01       	movw	r16, r24
     8a8:	6e e0       	ldi	r22, 0x0E	; 14
     8aa:	71 e0       	ldi	r23, 0x01	; 1
     8ac:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
     8b0:	6a e0       	ldi	r22, 0x0A	; 10
     8b2:	c8 01       	movw	r24, r16
     8b4:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     8b8:	8c 01       	movw	r16, r24
     8ba:	6a e1       	ldi	r22, 0x1A	; 26
     8bc:	71 e0       	ldi	r23, 0x01	; 1
     8be:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     8c2:	66 e0       	ldi	r22, 0x06	; 6
     8c4:	c8 01       	movw	r24, r16
     8c6:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
     8ca:	80 91 92 01 	lds	r24, 0x0192
     8ce:	90 91 93 01 	lds	r25, 0x0193
     8d2:	00 97       	sbiw	r24, 0x00	; 0
     8d4:	19 f0       	breq	.+6      	; 0x8dc <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
     8d6:	be 01       	movw	r22, r28
     8d8:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
     8dc:	0e 94 97 0f 	call	0x1f2e	; 0x1f2e <xTaskGetIdleTaskHandle>
     8e0:	0e 94 f6 12 	call	0x25ec	; 0x25ec <uxTaskGetStackHighWaterMark>
     8e4:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
     8e6:	6a e0       	ldi	r22, 0x0A	; 10
     8e8:	ce 01       	movw	r24, r28
     8ea:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     8ee:	ec 01       	movw	r28, r24
     8f0:	6d ee       	ldi	r22, 0xED	; 237
     8f2:	70 e0       	ldi	r23, 0x00	; 0
     8f4:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
     8f8:	61 2f       	mov	r22, r17
     8fa:	ce 01       	movw	r24, r28
     8fc:	0e 94 01 06 	call	0xc02	; 0xc02 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
     900:	6a e0       	ldi	r22, 0x0A	; 10
     902:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     906:	ec 01       	movw	r28, r24
     908:	68 ef       	ldi	r22, 0xF8	; 248
     90a:	70 e0       	ldi	r23, 0x00	; 0
     90c:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     910:	64 e6       	ldi	r22, 0x64	; 100
     912:	70 e0       	ldi	r23, 0x00	; 0
     914:	ce 01       	movw	r24, r28
     916:	0e 94 7f 05 	call	0xafe	; 0xafe <_ZN8emstreamlsEj>
     91a:	6a e0       	ldi	r22, 0x0A	; 10
     91c:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>
     920:	ec 01       	movw	r28, r24
     922:	6a ef       	ldi	r22, 0xFA	; 250
     924:	70 e0       	ldi	r23, 0x00	; 0
     926:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
     92a:	66 e0       	ldi	r22, 0x06	; 6
     92c:	ce 01       	movw	r24, r28
}
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	1f 91       	pop	r17
     934:	0f 91       	pop	r16
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
     936:	0c 94 3d 05 	jmp	0xa7a	; 0xa7a <_ZN8emstreamlsE15ser_manipulator>

0000093a <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
     93a:	9f 92       	push	r9
     93c:	af 92       	push	r10
     93e:	bf 92       	push	r11
     940:	cf 92       	push	r12
     942:	df 92       	push	r13
     944:	ef 92       	push	r14
     946:	ff 92       	push	r15
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	ec 01       	movw	r28, r24
     952:	96 2e       	mov	r9, r22
     954:	5a 01       	movw	r10, r20
     956:	68 01       	movw	r12, r16
     958:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
     95a:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstreamC1Ev>
     95e:	27 e4       	ldi	r18, 0x47	; 71
     960:	31 e0       	ldi	r19, 0x01	; 1
     962:	39 83       	std	Y+1, r19	; 0x01
     964:	28 83       	st	Y, r18
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
     966:	bf 86       	std	Y+15, r11	; 0x0f
     968:	ae 86       	std	Y+14, r10	; 0x0e

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
     96a:	40 e0       	ldi	r20, 0x00	; 0
     96c:	61 e0       	ldi	r22, 0x01	; 1
     96e:	89 2d       	mov	r24, r9
     970:	0e 94 c9 0a 	call	0x1592	; 0x1592 <xQueueGenericCreate>
     974:	99 87       	std	Y+9, r25	; 0x09
     976:	88 87       	std	Y+8, r24	; 0x08

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
     978:	ca 86       	std	Y+10, r12	; 0x0a
     97a:	db 86       	std	Y+11, r13	; 0x0b
     97c:	ec 86       	std	Y+12, r14	; 0x0c
     97e:	fd 86       	std	Y+13, r15	; 0x0d
}
     980:	df 91       	pop	r29
     982:	cf 91       	pop	r28
     984:	1f 91       	pop	r17
     986:	0f 91       	pop	r16
     988:	ff 90       	pop	r15
     98a:	ef 90       	pop	r14
     98c:	df 90       	pop	r13
     98e:	cf 90       	pop	r12
     990:	bf 90       	pop	r11
     992:	af 90       	pop	r10
     994:	9f 90       	pop	r9
     996:	08 95       	ret

00000998 <_Znwj>:
	*  @return A pointer to the memory area which has just been allocated
	*/

	void* operator new (size_t size)
	{
		return pvPortMalloc (size);
     998:	0c 94 12 08 	jmp	0x1024	; 0x1024 <pvPortMalloc>

0000099c <_ZdlPv>:
	 *  @param ptr A pointer to the memory area whose contents are to be deleted
	 */

	void operator delete (void *ptr)
	{
		if (ptr) vPortFree (ptr);
     99c:	00 97       	sbiw	r24, 0x00	; 0
     99e:	11 f0       	breq	.+4      	; 0x9a4 <_ZdlPv+0x8>
     9a0:	0c 94 3a 08 	jmp	0x1074	; 0x1074 <vPortFree>
     9a4:	08 95       	ret

000009a6 <_Znaj>:
	 *  @return A pointer to the memory area which has just been allocated
	 */

	void* operator new[] (size_t size)
	{
		return pvPortMalloc (size);
     9a6:	0c 94 12 08 	jmp	0x1024	; 0x1024 <pvPortMalloc>

000009aa <_ZdaPv>:
	 *  @param ptr A pointer to the memory area whose contents are to be deleted
	 */

	void operator delete[] (void *ptr)
	{
		if (ptr) vPortFree (ptr);
     9aa:	00 97       	sbiw	r24, 0x00	; 0
     9ac:	11 f0       	breq	.+4      	; 0x9b2 <_ZdaPv+0x8>
     9ae:	0c 94 3a 08 	jmp	0x1074	; 0x1074 <vPortFree>
     9b2:	08 95       	ret

000009b4 <__cxa_guard_acquire>:
 *  @return Something that's pointed to by g
 */
extern "C"
{
int __cxa_guard_acquire (__guard *g)
    {
     9b4:	fc 01       	movw	r30, r24
    return !*(char *)(g);
     9b6:	81 e0       	ldi	r24, 0x01	; 1
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	20 81       	ld	r18, Z
     9bc:	22 23       	and	r18, r18
     9be:	11 f0       	breq	.+4      	; 0x9c4 <__cxa_guard_acquire+0x10>
     9c0:	80 e0       	ldi	r24, 0x00	; 0
     9c2:	90 e0       	ldi	r25, 0x00	; 0
    }
     9c4:	08 95       	ret

000009c6 <__cxa_guard_release>:
 */
extern "C"
{
void __cxa_guard_release (__guard *g)
    {
    *(char *)g = 1;
     9c6:	21 e0       	ldi	r18, 0x01	; 1
     9c8:	fc 01       	movw	r30, r24
     9ca:	20 83       	st	Z, r18
     9cc:	08 95       	ret

000009ce <__cxa_guard_abort>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
     9ce:	08 95       	ret

000009d0 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
     9d0:	08 95       	ret

000009d2 <_ZN8emstream13ready_to_sendEv>:
 */

bool emstream::ready_to_send (void)
{
	return (true);                          // By default the port's always ready
}
     9d2:	81 e0       	ldi	r24, 0x01	; 1
     9d4:	08 95       	ret

000009d6 <_ZN8emstream7getcharEv>:
 */

int16_t emstream::getchar (void)
{
	return ('\0');                          // Nothing to return, really
}
     9d6:	80 e0       	ldi	r24, 0x00	; 0
     9d8:	90 e0       	ldi	r25, 0x00	; 0
     9da:	08 95       	ret

000009dc <_ZN8emstream14check_for_charEv>:
 */

bool emstream::check_for_char (void)
{
	return (false);
}
     9dc:	80 e0       	ldi	r24, 0x00	; 0
     9de:	08 95       	ret

000009e0 <_ZN8emstream12transmit_nowEv>:
 *  classes which have no buffers, send everything immediately by default, and don't 
 *  need to respond to calls for immediate transmission. 
 */

void emstream::transmit_now (void)
{
     9e0:	08 95       	ret

000009e2 <_ZN8emstream12clear_screenEv>:
 *  when the format modifier 'clrscr' is inserted in an output line. Descendant
 *  classes which send things to displays should respond by clearing themselves.
 */

void emstream::clear_screen (void)
{
     9e2:	08 95       	ret

000009e4 <_ZN8emstreamC1Ev>:
//-------------------------------------------------------------------------------------
/** This constructor sets up the base serial port object. It sets the default base for
 *  the conversion of numbers to text and the default format for converting chars. 
 */

emstream::emstream (void)
     9e4:	fc 01       	movw	r30, r24
     9e6:	87 e5       	ldi	r24, 0x57	; 87
     9e8:	91 e0       	ldi	r25, 0x01	; 1
     9ea:	91 83       	std	Z+1, r25	; 0x01
     9ec:	80 83       	st	Z, r24
{
	base = 10;                              // Numbers are shown as decimal by default
     9ee:	8a e0       	ldi	r24, 0x0A	; 10
     9f0:	82 83       	std	Z+2, r24	; 0x02
	print_ascii = false;                    // Print 8-bit chars as numbers by default
     9f2:	13 82       	std	Z+3, r1	; 0x03
	precision = 3;                          // Print 3 digits after a decimal point
     9f4:	83 e0       	ldi	r24, 0x03	; 3
     9f6:	85 83       	std	Z+5, r24	; 0x05
	pgm_string = false;                     // Print strings from SRAM by default
     9f8:	14 82       	std	Z+4, r1	; 0x04
	p_hex_receiver = NULL;                  // No hex packet receiver has been set up
     9fa:	17 82       	std	Z+7, r1	; 0x07
     9fc:	16 82       	std	Z+6, r1	; 0x06
     9fe:	08 95       	ret

00000a00 <_ZN8emstream4putsEPKc>:
 *  reached.
 *  @param p_string A pointer to the string which is to be printed
 */

void emstream::puts (const char* p_string)
{
     a00:	0f 93       	push	r16
     a02:	1f 93       	push	r17
     a04:	cf 93       	push	r28
     a06:	df 93       	push	r29
     a08:	ec 01       	movw	r28, r24
     a0a:	fb 01       	movw	r30, r22
	char ch;                                // Temporary storage for a character

	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
     a0c:	8c 81       	ldd	r24, Y+4	; 0x04
     a0e:	81 11       	cpse	r24, r1
     a10:	17 c0       	rjmp	.+46     	; 0xa40 <_ZN8emstream4putsEPKc+0x40>
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*p_string)
     a12:	60 81       	ld	r22, Z
     a14:	66 23       	and	r22, r22
     a16:	79 f0       	breq	.+30     	; 0xa36 <_ZN8emstream4putsEPKc+0x36>
     a18:	8f 01       	movw	r16, r30
     a1a:	0f 5f       	subi	r16, 0xFF	; 255
     a1c:	1f 4f       	sbci	r17, 0xFF	; 255
		{
			putchar (*p_string++);
     a1e:	e8 81       	ld	r30, Y
     a20:	f9 81       	ldd	r31, Y+1	; 0x01
     a22:	02 80       	ldd	r0, Z+2	; 0x02
     a24:	f3 81       	ldd	r31, Z+3	; 0x03
     a26:	e0 2d       	mov	r30, r0
     a28:	ce 01       	movw	r24, r28
     a2a:	09 95       	icall
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*p_string)
     a2c:	f8 01       	movw	r30, r16
     a2e:	61 91       	ld	r22, Z+
     a30:	8f 01       	movw	r16, r30
     a32:	61 11       	cpse	r22, r1
     a34:	f4 cf       	rjmp	.-24     	; 0xa1e <_ZN8emstream4putsEPKc+0x1e>
		{
			putchar (*p_string++);
		}
	}
}
     a36:	df 91       	pop	r29
     a38:	cf 91       	pop	r28
     a3a:	1f 91       	pop	r17
     a3c:	0f 91       	pop	r16
     a3e:	08 95       	ret

	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
     a40:	1c 82       	std	Y+4, r1	; 0x04
		while ((ch = pgm_read_byte_near (p_string++)))
     a42:	8b 01       	movw	r16, r22
     a44:	0f 5f       	subi	r16, 0xFF	; 255
     a46:	1f 4f       	sbci	r17, 0xFF	; 255
     a48:	64 91       	lpm	r22, Z
     a4a:	66 23       	and	r22, r22
     a4c:	a1 f3       	breq	.-24     	; 0xa36 <_ZN8emstream4putsEPKc+0x36>
		{
			putchar (ch);
     a4e:	a8 81       	ld	r26, Y
     a50:	b9 81       	ldd	r27, Y+1	; 0x01
     a52:	12 96       	adiw	r26, 0x02	; 2
     a54:	ed 91       	ld	r30, X+
     a56:	fc 91       	ld	r31, X
     a58:	13 97       	sbiw	r26, 0x03	; 3
     a5a:	ce 01       	movw	r24, r28
     a5c:	09 95       	icall
	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
		while ((ch = pgm_read_byte_near (p_string++)))
     a5e:	f8 01       	movw	r30, r16
     a60:	64 91       	lpm	r22, Z
     a62:	0f 5f       	subi	r16, 0xFF	; 255
     a64:	1f 4f       	sbci	r17, 0xFF	; 255
     a66:	61 11       	cpse	r22, r1
     a68:	f2 cf       	rjmp	.-28     	; 0xa4e <_ZN8emstream4putsEPKc+0x4e>
     a6a:	e5 cf       	rjmp	.-54     	; 0xa36 <_ZN8emstream4putsEPKc+0x36>

00000a6c <_Z12setprecisionh>:
 *		a maximum of 7 digits are allowed
 *  @return The serial manipulator called "manip_set_precision"
 */

ser_manipulator setprecision (uint8_t digits)
{
     a6c:	88 30       	cpi	r24, 0x08	; 8
     a6e:	08 f0       	brcs	.+2      	; 0xa72 <_Z12setprecisionh+0x6>
     a70:	87 e0       	ldi	r24, 0x07	; 7
	if (digits > 7)
	{
		digits = 7;
	}
	bts_glob_prec = digits;
     a72:	80 93 00 01 	sts	0x0100, r24

	return (manip_set_precision);
}
     a76:	89 e0       	ldi	r24, 0x09	; 9
     a78:	08 95       	ret

00000a7a <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
     a7a:	cf 93       	push	r28
     a7c:	df 93       	push	r29
     a7e:	ec 01       	movw	r28, r24
	switch (new_manip)
     a80:	46 2f       	mov	r20, r22
     a82:	50 e0       	ldi	r21, 0x00	; 0
     a84:	4b 30       	cpi	r20, 0x0B	; 11
     a86:	51 05       	cpc	r21, r1
     a88:	38 f4       	brcc	.+14     	; 0xa98 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     a8a:	fa 01       	movw	r30, r20
     a8c:	ea 5b       	subi	r30, 0xBA	; 186
     a8e:	ff 4f       	sbci	r31, 0xFF	; 255
     a90:	0c 94 cc 16 	jmp	0x2d98	; 0x2d98 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
     a94:	82 e0       	ldi	r24, 0x02	; 2
     a96:	8a 83       	std	Y+2, r24	; 0x02
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
     a98:	ce 01       	movw	r24, r28
     a9a:	df 91       	pop	r29
     a9c:	cf 91       	pop	r28
     a9e:	08 95       	ret
			break;
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
			break;
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
     aa0:	81 e0       	ldi	r24, 0x01	; 1
     aa2:	8c 83       	std	Y+4, r24	; 0x04
			break;
     aa4:	f9 cf       	rjmp	.-14     	; 0xa98 <_ZN8emstreamlsE15ser_manipulator+0x1e>
	{
		case (bin):                         // Print integers in binary
			base = 2;
			break;
		case (oct):                         // Print integers in octal
			base = 8;
     aa6:	88 e0       	ldi	r24, 0x08	; 8
     aa8:	8a 83       	std	Y+2, r24	; 0x02
			break;
     aaa:	f6 cf       	rjmp	.-20     	; 0xa98 <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (dec):                         // Print integers in decimal
			base = 10;
     aac:	8a e0       	ldi	r24, 0x0A	; 10
     aae:	8a 83       	std	Y+2, r24	; 0x02
			break;
     ab0:	f3 cf       	rjmp	.-26     	; 0xa98 <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
     ab2:	80 e1       	ldi	r24, 0x10	; 16
     ab4:	8a 83       	std	Y+2, r24	; 0x02
			break;
     ab6:	f0 cf       	rjmp	.-32     	; 0xa98 <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
     ab8:	81 e0       	ldi	r24, 0x01	; 1
     aba:	8b 83       	std	Y+3, r24	; 0x03
			break;
     abc:	ed cf       	rjmp	.-38     	; 0xa98 <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
     abe:	1b 82       	std	Y+3, r1	; 0x03
			break;
     ac0:	eb cf       	rjmp	.-42     	; 0xa98 <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
     ac2:	e8 81       	ld	r30, Y
     ac4:	f9 81       	ldd	r31, Y+1	; 0x01
     ac6:	02 80       	ldd	r0, Z+2	; 0x02
     ac8:	f3 81       	ldd	r31, Z+3	; 0x03
     aca:	e0 2d       	mov	r30, r0
     acc:	6d e0       	ldi	r22, 0x0D	; 13
     ace:	09 95       	icall
     ad0:	e8 81       	ld	r30, Y
     ad2:	f9 81       	ldd	r31, Y+1	; 0x01
     ad4:	02 80       	ldd	r0, Z+2	; 0x02
     ad6:	f3 81       	ldd	r31, Z+3	; 0x03
     ad8:	e0 2d       	mov	r30, r0
     ada:	6a e0       	ldi	r22, 0x0A	; 10
     adc:	ce 01       	movw	r24, r28
     ade:	09 95       	icall
			break;
     ae0:	db cf       	rjmp	.-74     	; 0xa98 <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
     ae2:	e8 81       	ld	r30, Y
     ae4:	f9 81       	ldd	r31, Y+1	; 0x01
     ae6:	02 84       	ldd	r0, Z+10	; 0x0a
     ae8:	f3 85       	ldd	r31, Z+11	; 0x0b
     aea:	e0 2d       	mov	r30, r0
     aec:	09 95       	icall
			break;
     aee:	d4 cf       	rjmp	.-88     	; 0xa98 <_ZN8emstreamlsE15ser_manipulator+0x1e>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
     af0:	e8 81       	ld	r30, Y
     af2:	f9 81       	ldd	r31, Y+1	; 0x01
     af4:	00 84       	ldd	r0, Z+8	; 0x08
     af6:	f1 85       	ldd	r31, Z+9	; 0x09
     af8:	e0 2d       	mov	r30, r0
     afa:	09 95       	icall
			break;
     afc:	cd cf       	rjmp	.-102    	; 0xa98 <_ZN8emstreamlsE15ser_manipulator+0x1e>

00000afe <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
     afe:	ff 92       	push	r15
     b00:	0f 93       	push	r16
     b02:	1f 93       	push	r17
     b04:	cf 93       	push	r28
     b06:	df 93       	push	r29
     b08:	cd b7       	in	r28, 0x3d	; 61
     b0a:	de b7       	in	r29, 0x3e	; 62
     b0c:	61 97       	sbiw	r28, 0x11	; 17
     b0e:	0f b6       	in	r0, 0x3f	; 63
     b10:	f8 94       	cli
     b12:	de bf       	out	0x3e, r29	; 62
     b14:	0f be       	out	0x3f, r0	; 63
     b16:	cd bf       	out	0x3d, r28	; 61
     b18:	8c 01       	movw	r16, r24
     b1a:	f6 2e       	mov	r15, r22
     b1c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
     b1e:	f8 01       	movw	r30, r16
     b20:	42 81       	ldd	r20, Z+2	; 0x02
     b22:	40 31       	cpi	r20, 0x10	; 16
     b24:	91 f0       	breq	.+36     	; 0xb4a <_ZN8emstreamlsEj+0x4c>
     b26:	48 30       	cpi	r20, 0x08	; 8
     b28:	81 f0       	breq	.+32     	; 0xb4a <_ZN8emstreamlsEj+0x4c>
     b2a:	42 30       	cpi	r20, 0x02	; 2
     b2c:	71 f0       	breq	.+28     	; 0xb4a <_ZN8emstreamlsEj+0x4c>
		*this << parts.bits[1] << parts.bits[0];
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
     b2e:	50 e0       	ldi	r21, 0x00	; 0
     b30:	be 01       	movw	r22, r28
     b32:	6f 5f       	subi	r22, 0xFF	; 255
     b34:	7f 4f       	sbci	r23, 0xFF	; 255
     b36:	8f 2d       	mov	r24, r15
     b38:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <utoa>
		puts (out_str);
     b3c:	be 01       	movw	r22, r28
     b3e:	6f 5f       	subi	r22, 0xFF	; 255
     b40:	7f 4f       	sbci	r23, 0xFF	; 255
     b42:	c8 01       	movw	r24, r16
     b44:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     b48:	07 c0       	rjmp	.+14     	; 0xb58 <_ZN8emstreamlsEj+0x5a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
     b4a:	69 2f       	mov	r22, r25
     b4c:	c8 01       	movw	r24, r16
     b4e:	0e 94 01 06 	call	0xc02	; 0xc02 <_ZN8emstreamlsEh>
     b52:	6f 2d       	mov	r22, r15
     b54:	0e 94 01 06 	call	0xc02	; 0xc02 <_ZN8emstreamlsEh>
		utoa (num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
     b58:	c8 01       	movw	r24, r16
     b5a:	61 96       	adiw	r28, 0x11	; 17
     b5c:	0f b6       	in	r0, 0x3f	; 63
     b5e:	f8 94       	cli
     b60:	de bf       	out	0x3e, r29	; 62
     b62:	0f be       	out	0x3f, r0	; 63
     b64:	cd bf       	out	0x3d, r28	; 61
     b66:	df 91       	pop	r29
     b68:	cf 91       	pop	r28
     b6a:	1f 91       	pop	r17
     b6c:	0f 91       	pop	r16
     b6e:	ff 90       	pop	r15
     b70:	08 95       	ret

00000b72 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
     b72:	df 92       	push	r13
     b74:	ef 92       	push	r14
     b76:	ff 92       	push	r15
     b78:	0f 93       	push	r16
     b7a:	1f 93       	push	r17
     b7c:	cf 93       	push	r28
     b7e:	df 93       	push	r29
     b80:	cd b7       	in	r28, 0x3d	; 61
     b82:	de b7       	in	r29, 0x3e	; 62
     b84:	a1 97       	sbiw	r28, 0x21	; 33
     b86:	0f b6       	in	r0, 0x3f	; 63
     b88:	f8 94       	cli
     b8a:	de bf       	out	0x3e, r29	; 62
     b8c:	0f be       	out	0x3f, r0	; 63
     b8e:	cd bf       	out	0x3d, r28	; 61
     b90:	8c 01       	movw	r16, r24
     b92:	d4 2e       	mov	r13, r20
     b94:	e5 2e       	mov	r14, r21
     b96:	f6 2e       	mov	r15, r22
     b98:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
     b9a:	f8 01       	movw	r30, r16
     b9c:	22 81       	ldd	r18, Z+2	; 0x02
     b9e:	20 31       	cpi	r18, 0x10	; 16
     ba0:	a1 f0       	breq	.+40     	; 0xbca <_ZN8emstreamlsEm+0x58>
     ba2:	28 30       	cpi	r18, 0x08	; 8
     ba4:	91 f0       	breq	.+36     	; 0xbca <_ZN8emstreamlsEm+0x58>
     ba6:	22 30       	cpi	r18, 0x02	; 2
     ba8:	81 f0       	breq	.+32     	; 0xbca <_ZN8emstreamlsEm+0x58>
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
     baa:	30 e0       	ldi	r19, 0x00	; 0
     bac:	ae 01       	movw	r20, r28
     bae:	4f 5f       	subi	r20, 0xFF	; 255
     bb0:	5f 4f       	sbci	r21, 0xFF	; 255
     bb2:	6d 2d       	mov	r22, r13
     bb4:	7e 2d       	mov	r23, r14
     bb6:	8f 2d       	mov	r24, r15
     bb8:	0e 94 f5 16 	call	0x2dea	; 0x2dea <ultoa>
		puts (out_str);
     bbc:	be 01       	movw	r22, r28
     bbe:	6f 5f       	subi	r22, 0xFF	; 255
     bc0:	7f 4f       	sbci	r23, 0xFF	; 255
     bc2:	c8 01       	movw	r24, r16
     bc4:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
     bc8:	0d c0       	rjmp	.+26     	; 0xbe4 <_ZN8emstreamlsEm+0x72>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
     bca:	69 2f       	mov	r22, r25
     bcc:	c8 01       	movw	r24, r16
     bce:	0e 94 01 06 	call	0xc02	; 0xc02 <_ZN8emstreamlsEh>
     bd2:	6f 2d       	mov	r22, r15
     bd4:	0e 94 01 06 	call	0xc02	; 0xc02 <_ZN8emstreamlsEh>
     bd8:	6e 2d       	mov	r22, r14
     bda:	0e 94 01 06 	call	0xc02	; 0xc02 <_ZN8emstreamlsEh>
     bde:	6d 2d       	mov	r22, r13
     be0:	0e 94 01 06 	call	0xc02	; 0xc02 <_ZN8emstreamlsEh>
		ultoa ((long)num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
     be4:	c8 01       	movw	r24, r16
     be6:	a1 96       	adiw	r28, 0x21	; 33
     be8:	0f b6       	in	r0, 0x3f	; 63
     bea:	f8 94       	cli
     bec:	de bf       	out	0x3e, r29	; 62
     bee:	0f be       	out	0x3f, r0	; 63
     bf0:	cd bf       	out	0x3d, r28	; 61
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	1f 91       	pop	r17
     bf8:	0f 91       	pop	r16
     bfa:	ff 90       	pop	r15
     bfc:	ef 90       	pop	r14
     bfe:	df 90       	pop	r13
     c00:	08 95       	ret

00000c02 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
     c02:	cf 92       	push	r12
     c04:	df 92       	push	r13
     c06:	ef 92       	push	r14
     c08:	ff 92       	push	r15
     c0a:	0f 93       	push	r16
     c0c:	1f 93       	push	r17
     c0e:	cf 93       	push	r28
     c10:	df 93       	push	r29
     c12:	cd b7       	in	r28, 0x3d	; 61
     c14:	de b7       	in	r29, 0x3e	; 62
     c16:	29 97       	sbiw	r28, 0x09	; 9
     c18:	0f b6       	in	r0, 0x3f	; 63
     c1a:	f8 94       	cli
     c1c:	de bf       	out	0x3e, r29	; 62
     c1e:	0f be       	out	0x3f, r0	; 63
     c20:	cd bf       	out	0x3d, r28	; 61
     c22:	8c 01       	movw	r16, r24
     c24:	d6 2e       	mov	r13, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
     c26:	dc 01       	movw	r26, r24
     c28:	13 96       	adiw	r26, 0x03	; 3
     c2a:	8c 91       	ld	r24, X
     c2c:	13 97       	sbiw	r26, 0x03	; 3
     c2e:	81 11       	cpse	r24, r1
     c30:	5d c0       	rjmp	.+186    	; 0xcec <_ZN8emstreamlsEh+0xea>
	{
		putchar (num);
	}
	else if (base == 2)
     c32:	f8 01       	movw	r30, r16
     c34:	42 81       	ldd	r20, Z+2	; 0x02
     c36:	42 30       	cpi	r20, 0x02	; 2
     c38:	d9 f1       	breq	.+118    	; 0xcb0 <_ZN8emstreamlsEh+0xae>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
     c3a:	40 31       	cpi	r20, 0x10	; 16
     c3c:	f1 f0       	breq	.+60     	; 0xc7a <_ZN8emstreamlsEh+0x78>
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
     c3e:	50 e0       	ldi	r21, 0x00	; 0
     c40:	be 01       	movw	r22, r28
     c42:	6f 5f       	subi	r22, 0xFF	; 255
     c44:	7f 4f       	sbci	r23, 0xFF	; 255
     c46:	8d 2d       	mov	r24, r13
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <utoa>
		puts (out_str);
     c4e:	be 01       	movw	r22, r28
     c50:	6f 5f       	subi	r22, 0xFF	; 255
     c52:	7f 4f       	sbci	r23, 0xFF	; 255
     c54:	c8 01       	movw	r24, r16
     c56:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
     c5a:	c8 01       	movw	r24, r16
     c5c:	29 96       	adiw	r28, 0x09	; 9
     c5e:	0f b6       	in	r0, 0x3f	; 63
     c60:	f8 94       	cli
     c62:	de bf       	out	0x3e, r29	; 62
     c64:	0f be       	out	0x3f, r0	; 63
     c66:	cd bf       	out	0x3d, r28	; 61
     c68:	df 91       	pop	r29
     c6a:	cf 91       	pop	r28
     c6c:	1f 91       	pop	r17
     c6e:	0f 91       	pop	r16
     c70:	ff 90       	pop	r15
     c72:	ef 90       	pop	r14
     c74:	df 90       	pop	r13
     c76:	cf 90       	pop	r12
     c78:	08 95       	ret
			else             putchar ('0');
		}
	}
	else if (base == 16)
	{
		temp_char = (num >> 4) & 0x0F;
     c7a:	62 95       	swap	r22
     c7c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     c7e:	01 90       	ld	r0, Z+
     c80:	f0 81       	ld	r31, Z
     c82:	e0 2d       	mov	r30, r0
     c84:	02 80       	ldd	r0, Z+2	; 0x02
     c86:	f3 81       	ldd	r31, Z+3	; 0x03
     c88:	e0 2d       	mov	r30, r0
     c8a:	6a 30       	cpi	r22, 0x0A	; 10
     c8c:	b8 f5       	brcc	.+110    	; 0xcfc <_ZN8emstreamlsEh+0xfa>
     c8e:	60 5d       	subi	r22, 0xD0	; 208
     c90:	c8 01       	movw	r24, r16
     c92:	09 95       	icall
		temp_char = num & 0x0F;
     c94:	6d 2d       	mov	r22, r13
     c96:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     c98:	d8 01       	movw	r26, r16
     c9a:	ed 91       	ld	r30, X+
     c9c:	fc 91       	ld	r31, X
     c9e:	02 80       	ldd	r0, Z+2	; 0x02
     ca0:	f3 81       	ldd	r31, Z+3	; 0x03
     ca2:	e0 2d       	mov	r30, r0
     ca4:	6a 30       	cpi	r22, 0x0A	; 10
     ca6:	60 f1       	brcs	.+88     	; 0xd00 <_ZN8emstreamlsEh+0xfe>
     ca8:	69 5c       	subi	r22, 0xC9	; 201
     caa:	c8 01       	movw	r24, r16
     cac:	09 95       	icall
     cae:	d5 cf       	rjmp	.-86     	; 0xc5a <_ZN8emstreamlsEh+0x58>

	if (print_ascii)
	{
		putchar (num);
	}
	else if (base == 2)
     cb0:	88 e0       	ldi	r24, 0x08	; 8
     cb2:	e8 2e       	mov	r14, r24
     cb4:	f1 2c       	mov	r15, r1
     cb6:	90 e8       	ldi	r25, 0x80	; 128
     cb8:	c9 2e       	mov	r12, r25
     cba:	0a c0       	rjmp	.+20     	; 0xcd0 <_ZN8emstreamlsEh+0xce>
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
     cbc:	61 e3       	ldi	r22, 0x31	; 49
     cbe:	c8 01       	movw	r24, r16
     cc0:	09 95       	icall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
     cc2:	c6 94       	lsr	r12
     cc4:	b1 e0       	ldi	r27, 0x01	; 1
     cc6:	eb 1a       	sub	r14, r27
     cc8:	f1 08       	sbc	r15, r1
     cca:	e1 14       	cp	r14, r1
     ccc:	f1 04       	cpc	r15, r1
     cce:	29 f2       	breq	.-118    	; 0xc5a <_ZN8emstreamlsEh+0x58>
		{
			if (num & bmask) putchar ('1');
     cd0:	8c 2d       	mov	r24, r12
     cd2:	8d 21       	and	r24, r13
     cd4:	d8 01       	movw	r26, r16
     cd6:	ed 91       	ld	r30, X+
     cd8:	fc 91       	ld	r31, X
     cda:	02 80       	ldd	r0, Z+2	; 0x02
     cdc:	f3 81       	ldd	r31, Z+3	; 0x03
     cde:	e0 2d       	mov	r30, r0
     ce0:	81 11       	cpse	r24, r1
     ce2:	ec cf       	rjmp	.-40     	; 0xcbc <_ZN8emstreamlsEh+0xba>
			else             putchar ('0');
     ce4:	60 e3       	ldi	r22, 0x30	; 48
     ce6:	c8 01       	movw	r24, r16
     ce8:	09 95       	icall
     cea:	eb cf       	rjmp	.-42     	; 0xcc2 <_ZN8emstreamlsEh+0xc0>
{
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
	{
		putchar (num);
     cec:	ed 91       	ld	r30, X+
     cee:	fc 91       	ld	r31, X
     cf0:	02 80       	ldd	r0, Z+2	; 0x02
     cf2:	f3 81       	ldd	r31, Z+3	; 0x03
     cf4:	e0 2d       	mov	r30, r0
     cf6:	c8 01       	movw	r24, r16
     cf8:	09 95       	icall
     cfa:	af cf       	rjmp	.-162    	; 0xc5a <_ZN8emstreamlsEh+0x58>
		}
	}
	else if (base == 16)
	{
		temp_char = (num >> 4) & 0x0F;
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     cfc:	69 5c       	subi	r22, 0xC9	; 201
     cfe:	c8 cf       	rjmp	.-112    	; 0xc90 <_ZN8emstreamlsEh+0x8e>
		temp_char = num & 0x0F;
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     d00:	60 5d       	subi	r22, 0xD0	; 208
     d02:	d3 cf       	rjmp	.-90     	; 0xcaa <_ZN8emstreamlsEh+0xa8>

00000d04 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
     d04:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
     d06:	1a 96       	adiw	r26, 0x0a	; 10
     d08:	ed 91       	ld	r30, X+
     d0a:	fc 91       	ld	r31, X
     d0c:	1b 97       	sbiw	r26, 0x0b	; 11
     d0e:	80 81       	ld	r24, Z
     d10:	1e 96       	adiw	r26, 0x0e	; 14
     d12:	9c 91       	ld	r25, X
     d14:	1e 97       	sbiw	r26, 0x0e	; 14
     d16:	89 23       	and	r24, r25
     d18:	59 f4       	brne	.+22     	; 0xd30 <_ZN5rs2327putcharEc+0x2c>
     d1a:	21 e2       	ldi	r18, 0x21	; 33
     d1c:	3e e4       	ldi	r19, 0x4E	; 78
     d1e:	05 c0       	rjmp	.+10     	; 0xd2a <_ZN5rs2327putcharEc+0x26>
     d20:	21 50       	subi	r18, 0x01	; 1
     d22:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
     d24:	21 15       	cp	r18, r1
     d26:	31 05       	cpc	r19, r1
     d28:	81 f0       	breq	.+32     	; 0xd4a <_ZN5rs2327putcharEc+0x46>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
     d2a:	80 81       	ld	r24, Z
     d2c:	89 23       	and	r24, r25
     d2e:	c1 f3       	breq	.-16     	; 0xd20 <_ZN5rs2327putcharEc+0x1c>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
     d30:	80 81       	ld	r24, Z
     d32:	50 96       	adiw	r26, 0x10	; 16
     d34:	9c 91       	ld	r25, X
     d36:	50 97       	sbiw	r26, 0x10	; 16
     d38:	89 2b       	or	r24, r25
     d3a:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
     d3c:	18 96       	adiw	r26, 0x08	; 8
     d3e:	ed 91       	ld	r30, X+
     d40:	fc 91       	ld	r31, X
     d42:	19 97       	sbiw	r26, 0x09	; 9
     d44:	60 83       	st	Z, r22
	return (true);
     d46:	81 e0       	ldi	r24, 0x01	; 1
     d48:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
     d4a:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
     d4c:	08 95       	ret

00000d4e <_ZN5rs2327getcharEv>:
{
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	#ifdef UCSR0A  // If this is a dual-port chip
		if (port_num == 0)
     d4e:	fc 01       	movw	r30, r24
     d50:	81 89       	ldd	r24, Z+17	; 0x11
     d52:	81 11       	cpse	r24, r1
     d54:	1e c0       	rjmp	.+60     	; 0xd92 <_ZN5rs2327getcharEv+0x44>
     d56:	20 91 9c 01 	lds	r18, 0x019C
     d5a:	30 91 9d 01 	lds	r19, 0x019D
		{
			while (rcv0_read_index == rcv0_write_index);
     d5e:	80 91 9a 01 	lds	r24, 0x019A
     d62:	90 91 9b 01 	lds	r25, 0x019B
     d66:	28 17       	cp	r18, r24
     d68:	39 07       	cpc	r19, r25
     d6a:	91 f0       	breq	.+36     	; 0xd90 <_ZN5rs2327getcharEv+0x42>
			recv_char = rcv0_buffer[rcv0_read_index];
     d6c:	e0 91 9e 01 	lds	r30, 0x019E
     d70:	f0 91 9f 01 	lds	r31, 0x019F
     d74:	e2 0f       	add	r30, r18
     d76:	f3 1f       	adc	r31, r19
     d78:	80 81       	ld	r24, Z
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
     d7a:	2f 5f       	subi	r18, 0xFF	; 255
     d7c:	3f 4f       	sbci	r19, 0xFF	; 255
     d7e:	20 32       	cpi	r18, 0x20	; 32
     d80:	31 05       	cpc	r19, r1
     d82:	28 f1       	brcs	.+74     	; 0xdce <_ZN5rs2327getcharEv+0x80>
				rcv0_read_index = 0;
     d84:	10 92 9d 01 	sts	0x019D, r1
     d88:	10 92 9c 01 	sts	0x019C, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
     d8c:	90 e0       	ldi	r25, 0x00	; 0
     d8e:	08 95       	ret
     d90:	ff cf       	rjmp	.-2      	; 0xd90 <_ZN5rs2327getcharEv+0x42>
     d92:	20 91 96 01 	lds	r18, 0x0196
     d96:	30 91 97 01 	lds	r19, 0x0197
				rcv0_read_index = 0;
		}
		else  // This is port 1 of a dual-port chip
		{
		#if defined UCSR1A
			while (rcv1_read_index == rcv1_write_index);
     d9a:	80 91 94 01 	lds	r24, 0x0194
     d9e:	90 91 95 01 	lds	r25, 0x0195
     da2:	28 17       	cp	r18, r24
     da4:	39 07       	cpc	r19, r25
     da6:	91 f0       	breq	.+36     	; 0xdcc <_ZN5rs2327getcharEv+0x7e>
			recv_char = rcv1_buffer[rcv1_read_index];
     da8:	e0 91 98 01 	lds	r30, 0x0198
     dac:	f0 91 99 01 	lds	r31, 0x0199
     db0:	e2 0f       	add	r30, r18
     db2:	f3 1f       	adc	r31, r19
     db4:	80 81       	ld	r24, Z
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
     db6:	2f 5f       	subi	r18, 0xFF	; 255
     db8:	3f 4f       	sbci	r19, 0xFF	; 255
     dba:	20 32       	cpi	r18, 0x20	; 32
     dbc:	31 05       	cpc	r19, r1
     dbe:	68 f0       	brcs	.+26     	; 0xdda <_ZN5rs2327getcharEv+0x8c>
				rcv1_read_index = 0;
     dc0:	10 92 97 01 	sts	0x0197, r1
     dc4:	10 92 96 01 	sts	0x0196, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	08 95       	ret
     dcc:	ff cf       	rjmp	.-2      	; 0xdcc <_ZN5rs2327getcharEv+0x7e>
	#ifdef UCSR0A  // If this is a dual-port chip
		if (port_num == 0)
		{
			while (rcv0_read_index == rcv0_write_index);
			recv_char = rcv0_buffer[rcv0_read_index];
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
     dce:	30 93 9d 01 	sts	0x019D, r19
     dd2:	20 93 9c 01 	sts	0x019C, r18
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
     dd6:	90 e0       	ldi	r25, 0x00	; 0
     dd8:	08 95       	ret
		else  // This is port 1 of a dual-port chip
		{
		#if defined UCSR1A
			while (rcv1_read_index == rcv1_write_index);
			recv_char = rcv1_buffer[rcv1_read_index];
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
     dda:	30 93 97 01 	sts	0x0197, r19
     dde:	20 93 96 01 	sts	0x0196, r18
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
     de2:	90 e0       	ldi	r25, 0x00	; 0
     de4:	08 95       	ret

00000de6 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
     de6:	dc 01       	movw	r26, r24
     de8:	ed 91       	ld	r30, X+
     dea:	fc 91       	ld	r31, X
     dec:	02 80       	ldd	r0, Z+2	; 0x02
     dee:	f3 81       	ldd	r31, Z+3	; 0x03
     df0:	e0 2d       	mov	r30, r0
     df2:	6c e0       	ldi	r22, 0x0C	; 12
     df4:	09 94       	ijmp

00000df6 <_ZN5rs23214check_for_charEv>:
 */

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
     df6:	fc 01       	movw	r30, r24
     df8:	81 89       	ldd	r24, Z+17	; 0x11
     dfa:	88 23       	and	r24, r24
     dfc:	69 f0       	breq	.+26     	; 0xe18 <_ZN5rs23214check_for_charEv+0x22>
			return (rcv0_read_index != rcv0_write_index);
		else
			return (rcv1_read_index != rcv1_write_index);
     dfe:	81 e0       	ldi	r24, 0x01	; 1
     e00:	40 91 96 01 	lds	r20, 0x0196
     e04:	50 91 97 01 	lds	r21, 0x0197
     e08:	20 91 94 01 	lds	r18, 0x0194
     e0c:	30 91 95 01 	lds	r19, 0x0195
     e10:	42 17       	cp	r20, r18
     e12:	53 07       	cpc	r21, r19
     e14:	69 f0       	breq	.+26     	; 0xe30 <_ZN5rs23214check_for_charEv+0x3a>
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
     e16:	08 95       	ret

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
			return (rcv0_read_index != rcv0_write_index);
     e18:	81 e0       	ldi	r24, 0x01	; 1
     e1a:	40 91 9c 01 	lds	r20, 0x019C
     e1e:	50 91 9d 01 	lds	r21, 0x019D
     e22:	20 91 9a 01 	lds	r18, 0x019A
     e26:	30 91 9b 01 	lds	r19, 0x019B
     e2a:	42 17       	cp	r20, r18
     e2c:	53 07       	cpc	r21, r19
     e2e:	99 f7       	brne	.-26     	; 0xe16 <_ZN5rs23214check_for_charEv+0x20>
		else
			return (rcv1_read_index != rcv1_write_index);
     e30:	80 e0       	ldi	r24, 0x00	; 0
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
     e32:	08 95       	ret

00000e34 <_ZN5rs232C1Ejh>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

rs232::rs232 (uint16_t baud_rate, uint8_t port_number)
     e34:	ef 92       	push	r14
     e36:	ff 92       	push	r15
     e38:	1f 93       	push	r17
     e3a:	cf 93       	push	r28
     e3c:	df 93       	push	r29
     e3e:	00 d0       	rcall	.+0      	; 0xe40 <_ZN5rs232C1Ejh+0xc>
     e40:	cd b7       	in	r28, 0x3d	; 61
     e42:	de b7       	in	r29, 0x3e	; 62
     e44:	7c 01       	movw	r14, r24
     e46:	14 2f       	mov	r17, r20
	: emstream (), base232 (baud_rate, port_number)
     e48:	69 83       	std	Y+1, r22	; 0x01
     e4a:	7a 83       	std	Y+2, r23	; 0x02
     e4c:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <_ZN8emstreamC1Ev>
     e50:	41 2f       	mov	r20, r17
     e52:	69 81       	ldd	r22, Y+1	; 0x01
     e54:	7a 81       	ldd	r23, Y+2	; 0x02
     e56:	c7 01       	movw	r24, r14
     e58:	08 96       	adiw	r24, 0x08	; 8
     e5a:	0e 94 9e 13 	call	0x273c	; 0x273c <_ZN7base232C1Ejh>
     e5e:	87 e6       	ldi	r24, 0x67	; 103
     e60:	91 e0       	ldi	r25, 0x01	; 1
     e62:	f7 01       	movw	r30, r14
     e64:	91 83       	std	Z+1, r25	; 0x01
     e66:	80 83       	st	Z, r24
{
	// Save the number of the serial port, 0 or 1
	port_num = port_number;
     e68:	11 8b       	std	Z+17, r17	; 0x11

	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
     e6a:	11 23       	and	r17, r17
     e6c:	e9 f0       	breq	.+58     	; 0xea8 <_ZN5rs232C1Ejh+0x74>
			rcv0_write_index = 0;
		}
		else  // Serial port number 1
		{
		#if defined UCSR1A
			UCSR1B |= (1 << RXCIE1);		// Receive complete interrupt enable
     e6e:	80 91 9a 00 	lds	r24, 0x009A
     e72:	80 68       	ori	r24, 0x80	; 128
     e74:	80 93 9a 00 	sts	0x009A, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv1_buffer = new uint8_t[RSINT_BUF_SIZE];
     e78:	80 e2       	ldi	r24, 0x20	; 32
     e7a:	90 e0       	ldi	r25, 0x00	; 0
     e7c:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <_Znaj>
     e80:	90 93 99 01 	sts	0x0199, r25
     e84:	80 93 98 01 	sts	0x0198, r24
			rcv1_read_index = 0;
     e88:	10 92 97 01 	sts	0x0197, r1
     e8c:	10 92 96 01 	sts	0x0196, r1
			rcv1_write_index = 0;
     e90:	10 92 95 01 	sts	0x0195, r1
     e94:	10 92 94 01 	sts	0x0194, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
     e98:	0f 90       	pop	r0
     e9a:	0f 90       	pop	r0
     e9c:	df 91       	pop	r29
     e9e:	cf 91       	pop	r28
     ea0:	1f 91       	pop	r17
     ea2:	ff 90       	pop	r15
     ea4:	ef 90       	pop	r14
     ea6:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
		{
			UCSR0B |= (1 << RXCIE0);		// Receive complete interrupt enable
     ea8:	57 9a       	sbi	0x0a, 7	; 10

			// Allocate some memory for the receiver buffer and reset the indices
			rcv0_buffer = new uint8_t[RSINT_BUF_SIZE];
     eaa:	80 e2       	ldi	r24, 0x20	; 32
     eac:	90 e0       	ldi	r25, 0x00	; 0
     eae:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <_Znaj>
     eb2:	90 93 9f 01 	sts	0x019F, r25
     eb6:	80 93 9e 01 	sts	0x019E, r24
			rcv0_read_index = 0;
     eba:	10 92 9d 01 	sts	0x019D, r1
     ebe:	10 92 9c 01 	sts	0x019C, r1
			rcv0_write_index = 0;
     ec2:	10 92 9b 01 	sts	0x019B, r1
     ec6:	10 92 9a 01 	sts	0x019A, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
     eca:	0f 90       	pop	r0
     ecc:	0f 90       	pop	r0
     ece:	df 91       	pop	r29
     ed0:	cf 91       	pop	r28
     ed2:	1f 91       	pop	r17
     ed4:	ff 90       	pop	r15
     ed6:	ef 90       	pop	r14
     ed8:	08 95       	ret

00000eda <__vector_18>:
 *  This interrupt service routine runs whenever a character has been received by the
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

ISR (RSI_CHAR_RECV_INT_0)
{
     eda:	1f 92       	push	r1
     edc:	0f 92       	push	r0
     ede:	0f b6       	in	r0, 0x3f	; 63
     ee0:	0f 92       	push	r0
     ee2:	11 24       	eor	r1, r1
     ee4:	0b b6       	in	r0, 0x3b	; 59
     ee6:	0f 92       	push	r0
     ee8:	2f 93       	push	r18
     eea:	3f 93       	push	r19
     eec:	8f 93       	push	r24
     eee:	9f 93       	push	r25
     ef0:	ef 93       	push	r30
     ef2:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	#if defined UCSR0A  // If this is a dual-serial-port chip (ATmega324P, 128, etc.)
		rcv0_buffer[rcv0_write_index] = UDR0;
     ef4:	2c b1       	in	r18, 0x0c	; 12
     ef6:	e0 91 9e 01 	lds	r30, 0x019E
     efa:	f0 91 9f 01 	lds	r31, 0x019F
     efe:	80 91 9a 01 	lds	r24, 0x019A
     f02:	90 91 9b 01 	lds	r25, 0x019B
     f06:	e8 0f       	add	r30, r24
     f08:	f9 1f       	adc	r31, r25
     f0a:	20 83       	st	Z, r18
	#else  // If this chip has only a single serial port (ATmega8, 32, etc.)
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
     f0c:	80 91 9a 01 	lds	r24, 0x019A
     f10:	90 91 9b 01 	lds	r25, 0x019B
     f14:	01 96       	adiw	r24, 0x01	; 1
     f16:	80 32       	cpi	r24, 0x20	; 32
     f18:	91 05       	cpc	r25, r1
     f1a:	c0 f4       	brcc	.+48     	; 0xf4c <__vector_18+0x72>
     f1c:	90 93 9b 01 	sts	0x019B, r25
     f20:	80 93 9a 01 	sts	0x019A, r24
		rcv0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
     f24:	20 91 9c 01 	lds	r18, 0x019C
     f28:	30 91 9d 01 	lds	r19, 0x019D
     f2c:	28 17       	cp	r18, r24
     f2e:	39 07       	cpc	r19, r25
     f30:	d1 f0       	breq	.+52     	; 0xf66 <__vector_18+0x8c>
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
}
     f32:	ff 91       	pop	r31
     f34:	ef 91       	pop	r30
     f36:	9f 91       	pop	r25
     f38:	8f 91       	pop	r24
     f3a:	3f 91       	pop	r19
     f3c:	2f 91       	pop	r18
     f3e:	0f 90       	pop	r0
     f40:	0b be       	out	0x3b, r0	; 59
     f42:	0f 90       	pop	r0
     f44:	0f be       	out	0x3f, r0	; 63
     f46:	0f 90       	pop	r0
     f48:	1f 90       	pop	r1
     f4a:	18 95       	reti
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
		rcv0_write_index = 0;
     f4c:	10 92 9b 01 	sts	0x019B, r1
     f50:	10 92 9a 01 	sts	0x019A, r1
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	90 e0       	ldi	r25, 0x00	; 0

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
     f58:	20 91 9c 01 	lds	r18, 0x019C
     f5c:	30 91 9d 01 	lds	r19, 0x019D
     f60:	28 17       	cp	r18, r24
     f62:	39 07       	cpc	r19, r25
     f64:	31 f7       	brne	.-52     	; 0xf32 <__vector_18+0x58>
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
     f66:	01 96       	adiw	r24, 0x01	; 1
     f68:	90 93 9d 01 	sts	0x019D, r25
     f6c:	80 93 9c 01 	sts	0x019C, r24
     f70:	80 97       	sbiw	r24, 0x20	; 32
     f72:	f8 f2       	brcs	.-66     	; 0xf32 <__vector_18+0x58>
			rcv0_read_index = 0;
     f74:	10 92 9d 01 	sts	0x019D, r1
     f78:	10 92 9c 01 	sts	0x019C, r1
     f7c:	da cf       	rjmp	.-76     	; 0xf32 <__vector_18+0x58>

00000f7e <__vector_30>:
	/** This interrupt service routine runs whenever a character has been received by the
	*  first serial port (number 0).  It saves that character into the receiver buffer.
	*/

	ISR (RSI_CHAR_RECV_INT_1)
	{
     f7e:	1f 92       	push	r1
     f80:	0f 92       	push	r0
     f82:	0f b6       	in	r0, 0x3f	; 63
     f84:	0f 92       	push	r0
     f86:	11 24       	eor	r1, r1
     f88:	0b b6       	in	r0, 0x3b	; 59
     f8a:	0f 92       	push	r0
     f8c:	2f 93       	push	r18
     f8e:	3f 93       	push	r19
     f90:	8f 93       	push	r24
     f92:	9f 93       	push	r25
     f94:	ef 93       	push	r30
     f96:	ff 93       	push	r31
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;
     f98:	20 91 9c 00 	lds	r18, 0x009C
     f9c:	e0 91 98 01 	lds	r30, 0x0198
     fa0:	f0 91 99 01 	lds	r31, 0x0199
     fa4:	80 91 94 01 	lds	r24, 0x0194
     fa8:	90 91 95 01 	lds	r25, 0x0195
     fac:	e8 0f       	add	r30, r24
     fae:	f9 1f       	adc	r31, r25
     fb0:	20 83       	st	Z, r18

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
     fb2:	80 91 94 01 	lds	r24, 0x0194
     fb6:	90 91 95 01 	lds	r25, 0x0195
     fba:	01 96       	adiw	r24, 0x01	; 1
     fbc:	80 32       	cpi	r24, 0x20	; 32
     fbe:	91 05       	cpc	r25, r1
     fc0:	c0 f4       	brcc	.+48     	; 0xff2 <__vector_30+0x74>
     fc2:	90 93 95 01 	sts	0x0195, r25
     fc6:	80 93 94 01 	sts	0x0194, r24
			rcv1_write_index = 0;

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
     fca:	20 91 96 01 	lds	r18, 0x0196
     fce:	30 91 97 01 	lds	r19, 0x0197
     fd2:	28 17       	cp	r18, r24
     fd4:	39 07       	cpc	r19, r25
     fd6:	d1 f0       	breq	.+52     	; 0x100c <__vector_30+0x8e>
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
				rcv1_read_index = 0;
	}
     fd8:	ff 91       	pop	r31
     fda:	ef 91       	pop	r30
     fdc:	9f 91       	pop	r25
     fde:	8f 91       	pop	r24
     fe0:	3f 91       	pop	r19
     fe2:	2f 91       	pop	r18
     fe4:	0f 90       	pop	r0
     fe6:	0b be       	out	0x3b, r0	; 59
     fe8:	0f 90       	pop	r0
     fea:	0f be       	out	0x3f, r0	; 63
     fec:	0f 90       	pop	r0
     fee:	1f 90       	pop	r1
     ff0:	18 95       	reti
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
			rcv1_write_index = 0;
     ff2:	10 92 95 01 	sts	0x0195, r1
     ff6:	10 92 94 01 	sts	0x0194, r1
     ffa:	80 e0       	ldi	r24, 0x00	; 0
     ffc:	90 e0       	ldi	r25, 0x00	; 0

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
     ffe:	20 91 96 01 	lds	r18, 0x0196
    1002:	30 91 97 01 	lds	r19, 0x0197
    1006:	28 17       	cp	r18, r24
    1008:	39 07       	cpc	r19, r25
    100a:	31 f7       	brne	.-52     	; 0xfd8 <__vector_30+0x5a>
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    100c:	01 96       	adiw	r24, 0x01	; 1
    100e:	90 93 97 01 	sts	0x0197, r25
    1012:	80 93 96 01 	sts	0x0196, r24
    1016:	80 97       	sbiw	r24, 0x20	; 32
    1018:	f8 f2       	brcs	.-66     	; 0xfd8 <__vector_30+0x5a>
				rcv1_read_index = 0;
    101a:	10 92 97 01 	sts	0x0197, r1
    101e:	10 92 96 01 	sts	0x0196, r1
    1022:	da cf       	rjmp	.-76     	; 0xfd8 <__vector_30+0x5a>

00001024 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1024:	cf 93       	push	r28
    1026:	df 93       	push	r29
    1028:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    102a:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    102e:	40 91 a0 01 	lds	r20, 0x01A0
    1032:	50 91 a1 01 	lds	r21, 0x01A1
    1036:	9e 01       	movw	r18, r28
    1038:	24 0f       	add	r18, r20
    103a:	35 1f       	adc	r19, r21
    103c:	28 37       	cpi	r18, 0x78	; 120
    103e:	8a e0       	ldi	r24, 0x0A	; 10
    1040:	38 07       	cpc	r19, r24
    1042:	80 f4       	brcc	.+32     	; 0x1064 <pvPortMalloc+0x40>
    1044:	42 17       	cp	r20, r18
    1046:	53 07       	cpc	r21, r19
    1048:	68 f4       	brcc	.+26     	; 0x1064 <pvPortMalloc+0x40>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    104a:	ea 01       	movw	r28, r20
    104c:	ce 55       	subi	r28, 0x5E	; 94
    104e:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
    1050:	30 93 a1 01 	sts	0x01A1, r19
    1054:	20 93 a0 01 	sts	0x01A0, r18
		}	
	}
	xTaskResumeAll();
    1058:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    105c:	ce 01       	movw	r24, r28
    105e:	df 91       	pop	r29
    1060:	cf 91       	pop	r28
    1062:	08 95       	ret
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1064:	c0 e0       	ldi	r28, 0x00	; 0
    1066:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1068:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    106c:	ce 01       	movw	r24, r28
    106e:	df 91       	pop	r29
    1070:	cf 91       	pop	r28
    1072:	08 95       	ret

00001074 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1074:	08 95       	ret

00001076 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1076:	10 92 a1 01 	sts	0x01A1, r1
    107a:	10 92 a0 01 	sts	0x01A0, r1
    107e:	08 95       	ret

00001080 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    1080:	20 91 a0 01 	lds	r18, 0x01A0
    1084:	30 91 a1 01 	lds	r19, 0x01A1
}
    1088:	88 e7       	ldi	r24, 0x78	; 120
    108a:	9a e0       	ldi	r25, 0x0A	; 10
    108c:	82 1b       	sub	r24, r18
    108e:	93 0b       	sbc	r25, r19
    1090:	08 95       	ret

00001092 <pxPortInitialiseStack>:
	// variable here which holds the address of the top of the stack. It will be
	// grabbed by the task's wrapper object just after xTaskCreate() is called so that
	// the task object knows where its stack is. The stack can then be dumped to a
	// serial port (as a hex printout) for debugging purposes. 
	#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
		portStackTopForTask = (size_t)pxTopOfStack;
    1092:	90 93 7d 0c 	sts	0x0C7D, r25
    1096:	80 93 7c 0c 	sts	0x0C7C, r24
	#endif

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    109a:	31 e1       	ldi	r19, 0x11	; 17
    109c:	fc 01       	movw	r30, r24
    109e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    10a0:	31 97       	sbiw	r30, 0x01	; 1
    10a2:	22 e2       	ldi	r18, 0x22	; 34
    10a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    10a6:	fc 01       	movw	r30, r24
    10a8:	32 97       	sbiw	r30, 0x02	; 2
    10aa:	a3 e3       	ldi	r26, 0x33	; 51
    10ac:	a0 83       	st	Z, r26
	pxTopOfStack--;
#else
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    10ae:	fc 01       	movw	r30, r24
    10b0:	33 97       	sbiw	r30, 0x03	; 3
    10b2:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    10b4:	fc 01       	movw	r30, r24
    10b6:	34 97       	sbiw	r30, 0x04	; 4
    10b8:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    10ba:	fc 01       	movw	r30, r24
    10bc:	35 97       	sbiw	r30, 0x05	; 5
    10be:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    10c0:	fc 01       	movw	r30, r24
    10c2:	36 97       	sbiw	r30, 0x06	; 6
    10c4:	60 e8       	ldi	r22, 0x80	; 128
    10c6:	60 83       	st	Z, r22
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
	pxTopOfStack--;
#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    10c8:	fc 01       	movw	r30, r24
    10ca:	37 97       	sbiw	r30, 0x07	; 7
    10cc:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    10ce:	fc 01       	movw	r30, r24
    10d0:	38 97       	sbiw	r30, 0x08	; 8
    10d2:	62 e0       	ldi	r22, 0x02	; 2
    10d4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    10d6:	fc 01       	movw	r30, r24
    10d8:	39 97       	sbiw	r30, 0x09	; 9
    10da:	63 e0       	ldi	r22, 0x03	; 3
    10dc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    10de:	fc 01       	movw	r30, r24
    10e0:	3a 97       	sbiw	r30, 0x0a	; 10
    10e2:	64 e0       	ldi	r22, 0x04	; 4
    10e4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    10e6:	fc 01       	movw	r30, r24
    10e8:	3b 97       	sbiw	r30, 0x0b	; 11
    10ea:	65 e0       	ldi	r22, 0x05	; 5
    10ec:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    10ee:	fc 01       	movw	r30, r24
    10f0:	3c 97       	sbiw	r30, 0x0c	; 12
    10f2:	66 e0       	ldi	r22, 0x06	; 6
    10f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    10f6:	fc 01       	movw	r30, r24
    10f8:	3d 97       	sbiw	r30, 0x0d	; 13
    10fa:	67 e0       	ldi	r22, 0x07	; 7
    10fc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    10fe:	fc 01       	movw	r30, r24
    1100:	3e 97       	sbiw	r30, 0x0e	; 14
    1102:	68 e0       	ldi	r22, 0x08	; 8
    1104:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1106:	fc 01       	movw	r30, r24
    1108:	3f 97       	sbiw	r30, 0x0f	; 15
    110a:	69 e0       	ldi	r22, 0x09	; 9
    110c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    110e:	fc 01       	movw	r30, r24
    1110:	70 97       	sbiw	r30, 0x10	; 16
    1112:	60 e1       	ldi	r22, 0x10	; 16
    1114:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1116:	fc 01       	movw	r30, r24
    1118:	71 97       	sbiw	r30, 0x11	; 17
    111a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    111c:	fc 01       	movw	r30, r24
    111e:	72 97       	sbiw	r30, 0x12	; 18
    1120:	32 e1       	ldi	r19, 0x12	; 18
    1122:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1124:	fc 01       	movw	r30, r24
    1126:	73 97       	sbiw	r30, 0x13	; 19
    1128:	33 e1       	ldi	r19, 0x13	; 19
    112a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    112c:	fc 01       	movw	r30, r24
    112e:	74 97       	sbiw	r30, 0x14	; 20
    1130:	34 e1       	ldi	r19, 0x14	; 20
    1132:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1134:	fc 01       	movw	r30, r24
    1136:	75 97       	sbiw	r30, 0x15	; 21
    1138:	35 e1       	ldi	r19, 0x15	; 21
    113a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    113c:	fc 01       	movw	r30, r24
    113e:	76 97       	sbiw	r30, 0x16	; 22
    1140:	36 e1       	ldi	r19, 0x16	; 22
    1142:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1144:	fc 01       	movw	r30, r24
    1146:	77 97       	sbiw	r30, 0x17	; 23
    1148:	37 e1       	ldi	r19, 0x17	; 23
    114a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    114c:	fc 01       	movw	r30, r24
    114e:	78 97       	sbiw	r30, 0x18	; 24
    1150:	38 e1       	ldi	r19, 0x18	; 24
    1152:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1154:	fc 01       	movw	r30, r24
    1156:	79 97       	sbiw	r30, 0x19	; 25
    1158:	39 e1       	ldi	r19, 0x19	; 25
    115a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    115c:	fc 01       	movw	r30, r24
    115e:	7a 97       	sbiw	r30, 0x1a	; 26
    1160:	30 e2       	ldi	r19, 0x20	; 32
    1162:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1164:	fc 01       	movw	r30, r24
    1166:	7b 97       	sbiw	r30, 0x1b	; 27
    1168:	31 e2       	ldi	r19, 0x21	; 33
    116a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    116c:	fc 01       	movw	r30, r24
    116e:	7c 97       	sbiw	r30, 0x1c	; 28
    1170:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1172:	fc 01       	movw	r30, r24
    1174:	7d 97       	sbiw	r30, 0x1d	; 29
    1176:	23 e2       	ldi	r18, 0x23	; 35
    1178:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    117a:	fc 01       	movw	r30, r24
    117c:	7e 97       	sbiw	r30, 0x1e	; 30
    117e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1180:	fc 01       	movw	r30, r24
    1182:	7f 97       	sbiw	r30, 0x1f	; 31
    1184:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1186:	fc 01       	movw	r30, r24
    1188:	b0 97       	sbiw	r30, 0x20	; 32
    118a:	26 e2       	ldi	r18, 0x26	; 38
    118c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    118e:	fc 01       	movw	r30, r24
    1190:	b1 97       	sbiw	r30, 0x21	; 33
    1192:	27 e2       	ldi	r18, 0x27	; 39
    1194:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1196:	fc 01       	movw	r30, r24
    1198:	b2 97       	sbiw	r30, 0x22	; 34
    119a:	28 e2       	ldi	r18, 0x28	; 40
    119c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    119e:	fc 01       	movw	r30, r24
    11a0:	b3 97       	sbiw	r30, 0x23	; 35
    11a2:	29 e2       	ldi	r18, 0x29	; 41
    11a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    11a6:	fc 01       	movw	r30, r24
    11a8:	b4 97       	sbiw	r30, 0x24	; 36
    11aa:	20 e3       	ldi	r18, 0x30	; 48
    11ac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    11ae:	fc 01       	movw	r30, r24
    11b0:	b5 97       	sbiw	r30, 0x25	; 37
    11b2:	21 e3       	ldi	r18, 0x31	; 49
    11b4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    11b6:	86 97       	sbiw	r24, 0x26	; 38
    11b8:	08 95       	ret

000011ba <xPortStartScheduler>:
		OCR5AL = compare_match.byte[0];         // register, then low byte
		TCCR5B = (1 << CS51) | (1 << WGM52);    // Prescale F_CPU / 8, clear on match
		TIMSK5 |= (1 << OCIE5A);                // Enable the timer interrupt
	#elif (defined TIMER3_COMPA_vect)           // Use Timer 3 on ATmega128/1284
		#define RT_VECT TIMER3_COMPA_vect
		OCR3AH = compare_match.byte[1];         // Set high byte of compare match
    11ba:	87 e0       	ldi	r24, 0x07	; 7
    11bc:	80 93 87 00 	sts	0x0087, r24
		OCR3AL = compare_match.byte[0];         // register, then low byte
    11c0:	8f ec       	ldi	r24, 0xCF	; 207
    11c2:	80 93 86 00 	sts	0x0086, r24
		TCCR3B = (1 << CS31) | (1 << WGM32);    // Prescale F_CPU / 8, clear on match
    11c6:	8a e0       	ldi	r24, 0x0A	; 10
    11c8:	80 93 8a 00 	sts	0x008A, r24
		#ifdef TIMSK3                           // Exists on 640/1280/1281/2560/2561
			TIMSK3 |= (1 << OCIE3A);            // but not on most others
		#elif defined ETIMSK
			ETIMSK |= (1 << OCIE3A);
    11cc:	ed e7       	ldi	r30, 0x7D	; 125
    11ce:	f0 e0       	ldi	r31, 0x00	; 0
    11d0:	80 81       	ld	r24, Z
    11d2:	80 61       	ori	r24, 0x10	; 16
    11d4:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    11d6:	a0 91 1a 0c 	lds	r26, 0x0C1A
    11da:	b0 91 1b 0c 	lds	r27, 0x0C1B
    11de:	cd 91       	ld	r28, X+
    11e0:	cd bf       	out	0x3d, r28	; 61
    11e2:	dd 91       	ld	r29, X+
    11e4:	de bf       	out	0x3e, r29	; 62
    11e6:	ff 91       	pop	r31
    11e8:	ef 91       	pop	r30
    11ea:	df 91       	pop	r29
    11ec:	cf 91       	pop	r28
    11ee:	bf 91       	pop	r27
    11f0:	af 91       	pop	r26
    11f2:	9f 91       	pop	r25
    11f4:	8f 91       	pop	r24
    11f6:	7f 91       	pop	r23
    11f8:	6f 91       	pop	r22
    11fa:	5f 91       	pop	r21
    11fc:	4f 91       	pop	r20
    11fe:	3f 91       	pop	r19
    1200:	2f 91       	pop	r18
    1202:	1f 91       	pop	r17
    1204:	0f 91       	pop	r16
    1206:	ff 90       	pop	r15
    1208:	ef 90       	pop	r14
    120a:	df 90       	pop	r13
    120c:	cf 90       	pop	r12
    120e:	bf 90       	pop	r11
    1210:	af 90       	pop	r10
    1212:	9f 90       	pop	r9
    1214:	8f 90       	pop	r8
    1216:	7f 90       	pop	r7
    1218:	6f 90       	pop	r6
    121a:	5f 90       	pop	r5
    121c:	4f 90       	pop	r4
    121e:	3f 90       	pop	r3
    1220:	2f 90       	pop	r2
    1222:	1f 90       	pop	r1
    1224:	0f 90       	pop	r0
    1226:	0f be       	out	0x3f, r0	; 63
    1228:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    122a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    122c:	81 e0       	ldi	r24, 0x01	; 1
    122e:	08 95       	ret

00001230 <vPortEndScheduler>:

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1230:	08 95       	ret

00001232 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1232:	0f 92       	push	r0
    1234:	0f b6       	in	r0, 0x3f	; 63
    1236:	f8 94       	cli
    1238:	0f 92       	push	r0
    123a:	1f 92       	push	r1
    123c:	11 24       	eor	r1, r1
    123e:	2f 92       	push	r2
    1240:	3f 92       	push	r3
    1242:	4f 92       	push	r4
    1244:	5f 92       	push	r5
    1246:	6f 92       	push	r6
    1248:	7f 92       	push	r7
    124a:	8f 92       	push	r8
    124c:	9f 92       	push	r9
    124e:	af 92       	push	r10
    1250:	bf 92       	push	r11
    1252:	cf 92       	push	r12
    1254:	df 92       	push	r13
    1256:	ef 92       	push	r14
    1258:	ff 92       	push	r15
    125a:	0f 93       	push	r16
    125c:	1f 93       	push	r17
    125e:	2f 93       	push	r18
    1260:	3f 93       	push	r19
    1262:	4f 93       	push	r20
    1264:	5f 93       	push	r21
    1266:	6f 93       	push	r22
    1268:	7f 93       	push	r23
    126a:	8f 93       	push	r24
    126c:	9f 93       	push	r25
    126e:	af 93       	push	r26
    1270:	bf 93       	push	r27
    1272:	cf 93       	push	r28
    1274:	df 93       	push	r29
    1276:	ef 93       	push	r30
    1278:	ff 93       	push	r31
    127a:	a0 91 1a 0c 	lds	r26, 0x0C1A
    127e:	b0 91 1b 0c 	lds	r27, 0x0C1B
    1282:	0d b6       	in	r0, 0x3d	; 61
    1284:	0d 92       	st	X+, r0
    1286:	0e b6       	in	r0, 0x3e	; 62
    1288:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    128a:	0e 94 c2 11 	call	0x2384	; 0x2384 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    128e:	a0 91 1a 0c 	lds	r26, 0x0C1A
    1292:	b0 91 1b 0c 	lds	r27, 0x0C1B
    1296:	cd 91       	ld	r28, X+
    1298:	cd bf       	out	0x3d, r28	; 61
    129a:	dd 91       	ld	r29, X+
    129c:	de bf       	out	0x3e, r29	; 62
    129e:	ff 91       	pop	r31
    12a0:	ef 91       	pop	r30
    12a2:	df 91       	pop	r29
    12a4:	cf 91       	pop	r28
    12a6:	bf 91       	pop	r27
    12a8:	af 91       	pop	r26
    12aa:	9f 91       	pop	r25
    12ac:	8f 91       	pop	r24
    12ae:	7f 91       	pop	r23
    12b0:	6f 91       	pop	r22
    12b2:	5f 91       	pop	r21
    12b4:	4f 91       	pop	r20
    12b6:	3f 91       	pop	r19
    12b8:	2f 91       	pop	r18
    12ba:	1f 91       	pop	r17
    12bc:	0f 91       	pop	r16
    12be:	ff 90       	pop	r15
    12c0:	ef 90       	pop	r14
    12c2:	df 90       	pop	r13
    12c4:	cf 90       	pop	r12
    12c6:	bf 90       	pop	r11
    12c8:	af 90       	pop	r10
    12ca:	9f 90       	pop	r9
    12cc:	8f 90       	pop	r8
    12ce:	7f 90       	pop	r7
    12d0:	6f 90       	pop	r6
    12d2:	5f 90       	pop	r5
    12d4:	4f 90       	pop	r4
    12d6:	3f 90       	pop	r3
    12d8:	2f 90       	pop	r2
    12da:	1f 90       	pop	r1
    12dc:	0f 90       	pop	r0
    12de:	0f be       	out	0x3f, r0	; 63
    12e0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12e2:	08 95       	ret

000012e4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    12e4:	0f 92       	push	r0
    12e6:	0f b6       	in	r0, 0x3f	; 63
    12e8:	f8 94       	cli
    12ea:	0f 92       	push	r0
    12ec:	1f 92       	push	r1
    12ee:	11 24       	eor	r1, r1
    12f0:	2f 92       	push	r2
    12f2:	3f 92       	push	r3
    12f4:	4f 92       	push	r4
    12f6:	5f 92       	push	r5
    12f8:	6f 92       	push	r6
    12fa:	7f 92       	push	r7
    12fc:	8f 92       	push	r8
    12fe:	9f 92       	push	r9
    1300:	af 92       	push	r10
    1302:	bf 92       	push	r11
    1304:	cf 92       	push	r12
    1306:	df 92       	push	r13
    1308:	ef 92       	push	r14
    130a:	ff 92       	push	r15
    130c:	0f 93       	push	r16
    130e:	1f 93       	push	r17
    1310:	2f 93       	push	r18
    1312:	3f 93       	push	r19
    1314:	4f 93       	push	r20
    1316:	5f 93       	push	r21
    1318:	6f 93       	push	r22
    131a:	7f 93       	push	r23
    131c:	8f 93       	push	r24
    131e:	9f 93       	push	r25
    1320:	af 93       	push	r26
    1322:	bf 93       	push	r27
    1324:	cf 93       	push	r28
    1326:	df 93       	push	r29
    1328:	ef 93       	push	r30
    132a:	ff 93       	push	r31
    132c:	a0 91 1a 0c 	lds	r26, 0x0C1A
    1330:	b0 91 1b 0c 	lds	r27, 0x0C1B
    1334:	0d b6       	in	r0, 0x3d	; 61
    1336:	0d 92       	st	X+, r0
    1338:	0e b6       	in	r0, 0x3e	; 62
    133a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    133c:	0e 94 9c 0f 	call	0x1f38	; 0x1f38 <vTaskIncrementTick>
	vTaskSwitchContext();
    1340:	0e 94 c2 11 	call	0x2384	; 0x2384 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1344:	a0 91 1a 0c 	lds	r26, 0x0C1A
    1348:	b0 91 1b 0c 	lds	r27, 0x0C1B
    134c:	cd 91       	ld	r28, X+
    134e:	cd bf       	out	0x3d, r28	; 61
    1350:	dd 91       	ld	r29, X+
    1352:	de bf       	out	0x3e, r29	; 62
    1354:	ff 91       	pop	r31
    1356:	ef 91       	pop	r30
    1358:	df 91       	pop	r29
    135a:	cf 91       	pop	r28
    135c:	bf 91       	pop	r27
    135e:	af 91       	pop	r26
    1360:	9f 91       	pop	r25
    1362:	8f 91       	pop	r24
    1364:	7f 91       	pop	r23
    1366:	6f 91       	pop	r22
    1368:	5f 91       	pop	r21
    136a:	4f 91       	pop	r20
    136c:	3f 91       	pop	r19
    136e:	2f 91       	pop	r18
    1370:	1f 91       	pop	r17
    1372:	0f 91       	pop	r16
    1374:	ff 90       	pop	r15
    1376:	ef 90       	pop	r14
    1378:	df 90       	pop	r13
    137a:	cf 90       	pop	r12
    137c:	bf 90       	pop	r11
    137e:	af 90       	pop	r10
    1380:	9f 90       	pop	r9
    1382:	8f 90       	pop	r8
    1384:	7f 90       	pop	r7
    1386:	6f 90       	pop	r6
    1388:	5f 90       	pop	r5
    138a:	4f 90       	pop	r4
    138c:	3f 90       	pop	r3
    138e:	2f 90       	pop	r2
    1390:	1f 90       	pop	r1
    1392:	0f 90       	pop	r0
    1394:	0f be       	out	0x3f, r0	; 63
    1396:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1398:	08 95       	ret

0000139a <__vector_26>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    139a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    139e:	18 95       	reti

000013a0 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    13a0:	cf 93       	push	r28
    13a2:	df 93       	push	r29
    13a4:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    13a6:	88 a1       	ldd	r24, Y+32	; 0x20
    13a8:	81 11       	cpse	r24, r1
    13aa:	0b c0       	rjmp	.+22     	; 0x13c2 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    13ac:	88 81       	ld	r24, Y
    13ae:	99 81       	ldd	r25, Y+1	; 0x01
    13b0:	89 2b       	or	r24, r25
    13b2:	09 f4       	brne	.+2      	; 0x13b6 <prvCopyDataToQueue+0x16>
    13b4:	46 c0       	rjmp	.+140    	; 0x1442 <prvCopyDataToQueue+0xa2>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    13b6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13b8:	8f 5f       	subi	r24, 0xFF	; 255
    13ba:	8e 8f       	std	Y+30, r24	; 0x1e
}
    13bc:	df 91       	pop	r29
    13be:	cf 91       	pop	r28
    13c0:	08 95       	ret
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    13c2:	41 11       	cpse	r20, r1
    13c4:	1c c0       	rjmp	.+56     	; 0x13fe <prvCopyDataToQueue+0x5e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    13c6:	48 2f       	mov	r20, r24
    13c8:	50 e0       	ldi	r21, 0x00	; 0
    13ca:	8c 81       	ldd	r24, Y+4	; 0x04
    13cc:	9d 81       	ldd	r25, Y+5	; 0x05
    13ce:	0e 94 d6 16 	call	0x2dac	; 0x2dac <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    13d2:	28 a1       	ldd	r18, Y+32	; 0x20
    13d4:	8c 81       	ldd	r24, Y+4	; 0x04
    13d6:	9d 81       	ldd	r25, Y+5	; 0x05
    13d8:	82 0f       	add	r24, r18
    13da:	91 1d       	adc	r25, r1
    13dc:	9d 83       	std	Y+5, r25	; 0x05
    13de:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    13e0:	2a 81       	ldd	r18, Y+2	; 0x02
    13e2:	3b 81       	ldd	r19, Y+3	; 0x03
    13e4:	82 17       	cp	r24, r18
    13e6:	93 07       	cpc	r25, r19
    13e8:	30 f3       	brcs	.-52     	; 0x13b6 <prvCopyDataToQueue+0x16>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    13ea:	88 81       	ld	r24, Y
    13ec:	99 81       	ldd	r25, Y+1	; 0x01
    13ee:	9d 83       	std	Y+5, r25	; 0x05
    13f0:	8c 83       	std	Y+4, r24	; 0x04
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    13f2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13f4:	8f 5f       	subi	r24, 0xFF	; 255
    13f6:	8e 8f       	std	Y+30, r24	; 0x1e
}
    13f8:	df 91       	pop	r29
    13fa:	cf 91       	pop	r28
    13fc:	08 95       	ret
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    13fe:	48 2f       	mov	r20, r24
    1400:	50 e0       	ldi	r21, 0x00	; 0
    1402:	8e 81       	ldd	r24, Y+6	; 0x06
    1404:	9f 81       	ldd	r25, Y+7	; 0x07
    1406:	0e 94 d6 16 	call	0x2dac	; 0x2dac <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    140a:	28 a1       	ldd	r18, Y+32	; 0x20
    140c:	30 e0       	ldi	r19, 0x00	; 0
    140e:	31 95       	neg	r19
    1410:	21 95       	neg	r18
    1412:	31 09       	sbc	r19, r1
    1414:	8e 81       	ldd	r24, Y+6	; 0x06
    1416:	9f 81       	ldd	r25, Y+7	; 0x07
    1418:	82 0f       	add	r24, r18
    141a:	93 1f       	adc	r25, r19
    141c:	9f 83       	std	Y+7, r25	; 0x07
    141e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1420:	48 81       	ld	r20, Y
    1422:	59 81       	ldd	r21, Y+1	; 0x01
    1424:	84 17       	cp	r24, r20
    1426:	95 07       	cpc	r25, r21
    1428:	30 f6       	brcc	.-116    	; 0x13b6 <prvCopyDataToQueue+0x16>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    142a:	8a 81       	ldd	r24, Y+2	; 0x02
    142c:	9b 81       	ldd	r25, Y+3	; 0x03
    142e:	82 0f       	add	r24, r18
    1430:	93 1f       	adc	r25, r19
    1432:	9f 83       	std	Y+7, r25	; 0x07
    1434:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1436:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1438:	8f 5f       	subi	r24, 0xFF	; 255
    143a:	8e 8f       	std	Y+30, r24	; 0x1e
}
    143c:	df 91       	pop	r29
    143e:	cf 91       	pop	r28
    1440:	08 95       	ret
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1442:	8a 81       	ldd	r24, Y+2	; 0x02
    1444:	9b 81       	ldd	r25, Y+3	; 0x03
    1446:	0e 94 67 13 	call	0x26ce	; 0x26ce <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    144a:	1b 82       	std	Y+3, r1	; 0x03
    144c:	1a 82       	std	Y+2, r1	; 0x02
    144e:	b3 cf       	rjmp	.-154    	; 0x13b6 <prvCopyDataToQueue+0x16>

00001450 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1450:	fc 01       	movw	r30, r24
    1452:	cb 01       	movw	r24, r22
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1454:	a0 81       	ld	r26, Z
    1456:	b1 81       	ldd	r27, Z+1	; 0x01
    1458:	10 97       	sbiw	r26, 0x00	; 0
    145a:	99 f0       	breq	.+38     	; 0x1482 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    145c:	40 a1       	ldd	r20, Z+32	; 0x20
    145e:	50 e0       	ldi	r21, 0x00	; 0
    1460:	26 81       	ldd	r18, Z+6	; 0x06
    1462:	37 81       	ldd	r19, Z+7	; 0x07
    1464:	24 0f       	add	r18, r20
    1466:	35 1f       	adc	r19, r21
    1468:	37 83       	std	Z+7, r19	; 0x07
    146a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    146c:	62 81       	ldd	r22, Z+2	; 0x02
    146e:	73 81       	ldd	r23, Z+3	; 0x03
    1470:	26 17       	cp	r18, r22
    1472:	37 07       	cpc	r19, r23
    1474:	18 f0       	brcs	.+6      	; 0x147c <prvCopyDataFromQueue+0x2c>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1476:	b7 83       	std	Z+7, r27	; 0x07
    1478:	a6 83       	std	Z+6, r26	; 0x06
    147a:	9d 01       	movw	r18, r26
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    147c:	b9 01       	movw	r22, r18
    147e:	0c 94 d6 16 	jmp	0x2dac	; 0x2dac <memcpy>
    1482:	08 95       	ret

00001484 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1484:	0f 93       	push	r16
    1486:	1f 93       	push	r17
    1488:	cf 93       	push	r28
    148a:	df 93       	push	r29
    148c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    148e:	0f b6       	in	r0, 0x3f	; 63
    1490:	f8 94       	cli
    1492:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1494:	8a a1       	ldd	r24, Y+34	; 0x22
    1496:	18 16       	cp	r1, r24
    1498:	dc f4       	brge	.+54     	; 0x14d0 <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    149a:	8b 89       	ldd	r24, Y+19	; 0x13
    149c:	88 23       	and	r24, r24
    149e:	c1 f0       	breq	.+48     	; 0x14d0 <prvUnlockQueue+0x4c>
    14a0:	8e 01       	movw	r16, r28
    14a2:	0d 5e       	subi	r16, 0xED	; 237
    14a4:	1f 4f       	sbci	r17, 0xFF	; 255
    14a6:	08 c0       	rjmp	.+16     	; 0x14b8 <prvUnlockQueue+0x34>
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
    14a8:	8a a1       	ldd	r24, Y+34	; 0x22
    14aa:	81 50       	subi	r24, 0x01	; 1
    14ac:	8a a3       	std	Y+34, r24	; 0x22
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    14ae:	18 16       	cp	r1, r24
    14b0:	7c f4       	brge	.+30     	; 0x14d0 <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14b2:	8b 89       	ldd	r24, Y+19	; 0x13
    14b4:	88 23       	and	r24, r24
    14b6:	61 f0       	breq	.+24     	; 0x14d0 <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14b8:	c8 01       	movw	r24, r16
    14ba:	0e 94 31 12 	call	0x2462	; 0x2462 <xTaskRemoveFromEventList>
    14be:	88 23       	and	r24, r24
    14c0:	99 f3       	breq	.-26     	; 0x14a8 <prvUnlockQueue+0x24>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    14c2:	0e 94 f2 12 	call	0x25e4	; 0x25e4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    14c6:	8a a1       	ldd	r24, Y+34	; 0x22
    14c8:	81 50       	subi	r24, 0x01	; 1
    14ca:	8a a3       	std	Y+34, r24	; 0x22
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    14cc:	18 16       	cp	r1, r24
    14ce:	8c f3       	brlt	.-30     	; 0x14b2 <prvUnlockQueue+0x2e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    14d0:	8f ef       	ldi	r24, 0xFF	; 255
    14d2:	8a a3       	std	Y+34, r24	; 0x22
	}
	taskEXIT_CRITICAL();
    14d4:	0f 90       	pop	r0
    14d6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    14d8:	0f b6       	in	r0, 0x3f	; 63
    14da:	f8 94       	cli
    14dc:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    14de:	89 a1       	ldd	r24, Y+33	; 0x21
    14e0:	18 16       	cp	r1, r24
    14e2:	dc f4       	brge	.+54     	; 0x151a <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14e4:	88 85       	ldd	r24, Y+8	; 0x08
    14e6:	88 23       	and	r24, r24
    14e8:	c1 f0       	breq	.+48     	; 0x151a <prvUnlockQueue+0x96>
    14ea:	8e 01       	movw	r16, r28
    14ec:	08 5f       	subi	r16, 0xF8	; 248
    14ee:	1f 4f       	sbci	r17, 0xFF	; 255
    14f0:	08 c0       	rjmp	.+16     	; 0x1502 <prvUnlockQueue+0x7e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
    14f2:	89 a1       	ldd	r24, Y+33	; 0x21
    14f4:	81 50       	subi	r24, 0x01	; 1
    14f6:	89 a3       	std	Y+33, r24	; 0x21
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    14f8:	18 16       	cp	r1, r24
    14fa:	7c f4       	brge	.+30     	; 0x151a <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14fc:	88 85       	ldd	r24, Y+8	; 0x08
    14fe:	88 23       	and	r24, r24
    1500:	61 f0       	breq	.+24     	; 0x151a <prvUnlockQueue+0x96>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1502:	c8 01       	movw	r24, r16
    1504:	0e 94 31 12 	call	0x2462	; 0x2462 <xTaskRemoveFromEventList>
    1508:	88 23       	and	r24, r24
    150a:	99 f3       	breq	.-26     	; 0x14f2 <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
    150c:	0e 94 f2 12 	call	0x25e4	; 0x25e4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1510:	89 a1       	ldd	r24, Y+33	; 0x21
    1512:	81 50       	subi	r24, 0x01	; 1
    1514:	89 a3       	std	Y+33, r24	; 0x21
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1516:	18 16       	cp	r1, r24
    1518:	8c f3       	brlt	.-30     	; 0x14fc <prvUnlockQueue+0x78>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    151a:	8f ef       	ldi	r24, 0xFF	; 255
    151c:	89 a3       	std	Y+33, r24	; 0x21
	}
	taskEXIT_CRITICAL();
    151e:	0f 90       	pop	r0
    1520:	0f be       	out	0x3f, r0	; 63
}
    1522:	df 91       	pop	r29
    1524:	cf 91       	pop	r28
    1526:	1f 91       	pop	r17
    1528:	0f 91       	pop	r16
    152a:	08 95       	ret

0000152c <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    152c:	cf 93       	push	r28
    152e:	df 93       	push	r29
    1530:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );

	/* If the queue being reset has already been used (has not just been
	created), then only reset the queue if its event lists are empty. */
	if( xNewQueue != pdTRUE )
    1532:	61 30       	cpi	r22, 0x01	; 1
    1534:	51 f0       	breq	.+20     	; 0x154a <xQueueGenericReset+0x1e>
	{
		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1536:	9b 89       	ldd	r25, Y+19	; 0x13
		{
			xReturn = pdFAIL;
		}

		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1538:	88 85       	ldd	r24, Y+8	; 0x08
    153a:	88 23       	and	r24, r24
    153c:	21 f0       	breq	.+8      	; 0x1546 <xQueueGenericReset+0x1a>
    153e:	80 e0       	ldi	r24, 0x00	; 0
		vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
		vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
	}

	return xReturn;
}
    1540:	df 91       	pop	r29
    1542:	cf 91       	pop	r28
    1544:	08 95       	ret
		{
			xReturn = pdFAIL;
		}
	}

	if( xReturn == pdPASS )
    1546:	91 11       	cpse	r25, r1
    1548:	fa cf       	rjmp	.-12     	; 0x153e <xQueueGenericReset+0x12>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    154a:	28 81       	ld	r18, Y
    154c:	39 81       	ldd	r19, Y+1	; 0x01
    154e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1550:	68 a1       	ldd	r22, Y+32	; 0x20
    1552:	86 9f       	mul	r24, r22
    1554:	c0 01       	movw	r24, r0
    1556:	11 24       	eor	r1, r1
    1558:	a9 01       	movw	r20, r18
    155a:	48 0f       	add	r20, r24
    155c:	59 1f       	adc	r21, r25
    155e:	5b 83       	std	Y+3, r21	; 0x03
    1560:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1562:	1e 8e       	std	Y+30, r1	; 0x1e
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1564:	3d 83       	std	Y+5, r19	; 0x05
    1566:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1568:	86 1b       	sub	r24, r22
    156a:	91 09       	sbc	r25, r1
    156c:	82 0f       	add	r24, r18
    156e:	93 1f       	adc	r25, r19
    1570:	9f 83       	std	Y+7, r25	; 0x07
    1572:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1574:	8f ef       	ldi	r24, 0xFF	; 255
    1576:	89 a3       	std	Y+33, r24	; 0x21
		pxQueue->xTxLock = queueUNLOCKED;
    1578:	8a a3       	std	Y+34, r24	; 0x22

		/* Ensure the event queues start with the correct state. */
		vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    157a:	ce 01       	movw	r24, r28
    157c:	08 96       	adiw	r24, 0x08	; 8
    157e:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>
		vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1582:	ce 01       	movw	r24, r28
    1584:	43 96       	adiw	r24, 0x13	; 19
    1586:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>
    158a:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    158c:	df 91       	pop	r29
    158e:	cf 91       	pop	r28
    1590:	08 95       	ret

00001592 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    1592:	0f 93       	push	r16
    1594:	1f 93       	push	r17
    1596:	cf 93       	push	r28
    1598:	df 93       	push	r29
    159a:	18 2f       	mov	r17, r24
    159c:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    159e:	88 23       	and	r24, r24
    15a0:	01 f1       	breq	.+64     	; 0x15e2 <xQueueGenericCreate+0x50>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    15a2:	83 e2       	ldi	r24, 0x23	; 35
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	0e 94 12 08 	call	0x1024	; 0x1024 <pvPortMalloc>
    15aa:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    15ac:	00 97       	sbiw	r24, 0x00	; 0
    15ae:	c9 f0       	breq	.+50     	; 0x15e2 <xQueueGenericCreate+0x50>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    15b0:	10 9f       	mul	r17, r16
    15b2:	c0 01       	movw	r24, r0
    15b4:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    15b6:	01 96       	adiw	r24, 0x01	; 1
    15b8:	0e 94 12 08 	call	0x1024	; 0x1024 <pvPortMalloc>
    15bc:	99 83       	std	Y+1, r25	; 0x01
    15be:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    15c0:	89 2b       	or	r24, r25
    15c2:	61 f0       	breq	.+24     	; 0x15dc <xQueueGenericCreate+0x4a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    15c4:	1f 8f       	std	Y+31, r17	; 0x1f
				pxNewQueue->uxItemSize = uxItemSize;
    15c6:	08 a3       	std	Y+32, r16	; 0x20
				xQueueGenericReset( pxNewQueue, pdTRUE );
    15c8:	61 e0       	ldi	r22, 0x01	; 1
    15ca:	ce 01       	movw	r24, r28
    15cc:	0e 94 96 0a 	call	0x152c	; 0x152c <xQueueGenericReset>
	}

	configASSERT( xReturn );

	return xReturn;
}
    15d0:	ce 01       	movw	r24, r28
    15d2:	df 91       	pop	r29
    15d4:	cf 91       	pop	r28
    15d6:	1f 91       	pop	r17
    15d8:	0f 91       	pop	r16
    15da:	08 95       	ret
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    15dc:	ce 01       	movw	r24, r28
    15de:	0e 94 3a 08 	call	0x1074	; 0x1074 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    15e2:	c0 e0       	ldi	r28, 0x00	; 0
    15e4:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    15e6:	ce 01       	movw	r24, r28
    15e8:	df 91       	pop	r29
    15ea:	cf 91       	pop	r28
    15ec:	1f 91       	pop	r17
    15ee:	0f 91       	pop	r16
    15f0:	08 95       	ret

000015f2 <xQueueGetMutexHolder>:
		/* This function is called by xSemaphoreGetMutexHolder(), and should not
		be called directly.  Note:  This is is a good way of determining if the
		calling task is the mutex holder, but not a good way of determining the
		identity of the mutex holder, as the holder may change between the 
		following critical section exiting and the function returning. */
		taskENTER_CRITICAL();
    15f2:	0f b6       	in	r0, 0x3f	; 63
    15f4:	f8 94       	cli
    15f6:	0f 92       	push	r0
		{
			if( xSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
    15f8:	fc 01       	movw	r30, r24
    15fa:	20 81       	ld	r18, Z
    15fc:	31 81       	ldd	r19, Z+1	; 0x01
    15fe:	23 2b       	or	r18, r19
    1600:	29 f4       	brne	.+10     	; 0x160c <xQueueGetMutexHolder+0x1a>
			{
				pxReturn = ( void * ) xSemaphore->pxMutexHolder;
    1602:	82 81       	ldd	r24, Z+2	; 0x02
    1604:	93 81       	ldd	r25, Z+3	; 0x03
			else
			{
				pxReturn = NULL;
			}
		}
		taskEXIT_CRITICAL();
    1606:	0f 90       	pop	r0
    1608:	0f be       	out	0x3f, r0	; 63
		
		return pxReturn;
	}
    160a:	08 95       	ret
			{
				pxReturn = ( void * ) xSemaphore->pxMutexHolder;
			}
			else
			{
				pxReturn = NULL;
    160c:	80 e0       	ldi	r24, 0x00	; 0
    160e:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1610:	0f 90       	pop	r0
    1612:	0f be       	out	0x3f, r0	; 63
		
		return pxReturn;
	}
    1614:	08 95       	ret

00001616 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1616:	6f 92       	push	r6
    1618:	7f 92       	push	r7
    161a:	8f 92       	push	r8
    161c:	9f 92       	push	r9
    161e:	af 92       	push	r10
    1620:	bf 92       	push	r11
    1622:	cf 92       	push	r12
    1624:	df 92       	push	r13
    1626:	ef 92       	push	r14
    1628:	ff 92       	push	r15
    162a:	0f 93       	push	r16
    162c:	cf 93       	push	r28
    162e:	df 93       	push	r29
    1630:	cd b7       	in	r28, 0x3d	; 61
    1632:	de b7       	in	r29, 0x3e	; 62
    1634:	29 97       	sbiw	r28, 0x09	; 9
    1636:	0f b6       	in	r0, 0x3f	; 63
    1638:	f8 94       	cli
    163a:	de bf       	out	0x3e, r29	; 62
    163c:	0f be       	out	0x3f, r0	; 63
    163e:	cd bf       	out	0x3d, r28	; 61
    1640:	5c 01       	movw	r10, r24
    1642:	4b 01       	movw	r8, r22
    1644:	2e 83       	std	Y+6, r18	; 0x06
    1646:	3f 83       	std	Y+7, r19	; 0x07
    1648:	48 87       	std	Y+8, r20	; 0x08
    164a:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    164c:	20 e0       	ldi	r18, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    164e:	3c 01       	movw	r6, r24
    1650:	88 e0       	ldi	r24, 0x08	; 8
    1652:	68 0e       	add	r6, r24
    1654:	71 1c       	adc	r7, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1656:	0f b6       	in	r0, 0x3f	; 63
    1658:	f8 94       	cli
    165a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    165c:	f5 01       	movw	r30, r10
    165e:	96 8d       	ldd	r25, Z+30	; 0x1e
    1660:	87 8d       	ldd	r24, Z+31	; 0x1f
    1662:	98 17       	cp	r25, r24
    1664:	08 f4       	brcc	.+2      	; 0x1668 <xQueueGenericSend+0x52>
    1666:	55 c0       	rjmp	.+170    	; 0x1712 <xQueueGenericSend+0xfc>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1668:	ce 80       	ldd	r12, Y+6	; 0x06
    166a:	df 80       	ldd	r13, Y+7	; 0x07
    166c:	e8 84       	ldd	r14, Y+8	; 0x08
    166e:	f9 84       	ldd	r15, Y+9	; 0x09
    1670:	cd 28       	or	r12, r13
    1672:	ce 28       	or	r12, r14
    1674:	cf 28       	or	r12, r15
    1676:	09 f4       	brne	.+2      	; 0x167a <xQueueGenericSend+0x64>
    1678:	6c c0       	rjmp	.+216    	; 0x1752 <xQueueGenericSend+0x13c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    167a:	22 23       	and	r18, r18
    167c:	61 f1       	breq	.+88     	; 0x16d6 <xQueueGenericSend+0xc0>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    167e:	0f 90       	pop	r0
    1680:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1682:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1686:	0f b6       	in	r0, 0x3f	; 63
    1688:	f8 94       	cli
    168a:	0f 92       	push	r0
    168c:	f5 01       	movw	r30, r10
    168e:	81 a1       	ldd	r24, Z+33	; 0x21
    1690:	8f 3f       	cpi	r24, 0xFF	; 255
    1692:	31 f1       	breq	.+76     	; 0x16e0 <xQueueGenericSend+0xca>
    1694:	f5 01       	movw	r30, r10
    1696:	82 a1       	ldd	r24, Z+34	; 0x22
    1698:	8f 3f       	cpi	r24, 0xFF	; 255
    169a:	39 f1       	breq	.+78     	; 0x16ea <xQueueGenericSend+0xd4>
    169c:	0f 90       	pop	r0
    169e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16a0:	be 01       	movw	r22, r28
    16a2:	6a 5f       	subi	r22, 0xFA	; 250
    16a4:	7f 4f       	sbci	r23, 0xFF	; 255
    16a6:	ce 01       	movw	r24, r28
    16a8:	01 96       	adiw	r24, 0x01	; 1
    16aa:	0e 94 83 12 	call	0x2506	; 0x2506 <xTaskCheckForTimeOut>
    16ae:	81 11       	cpse	r24, r1
    16b0:	54 c0       	rjmp	.+168    	; 0x175a <xQueueGenericSend+0x144>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    16b2:	0f b6       	in	r0, 0x3f	; 63
    16b4:	f8 94       	cli
    16b6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    16b8:	f5 01       	movw	r30, r10
    16ba:	96 8d       	ldd	r25, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    16bc:	0f 90       	pop	r0
    16be:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    16c0:	f5 01       	movw	r30, r10
    16c2:	87 8d       	ldd	r24, Z+31	; 0x1f
    16c4:	98 17       	cp	r25, r24
    16c6:	99 f0       	breq	.+38     	; 0x16ee <xQueueGenericSend+0xd8>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    16c8:	c5 01       	movw	r24, r10
    16ca:	0e 94 42 0a 	call	0x1484	; 0x1484 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    16ce:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskResumeAll>
    16d2:	21 e0       	ldi	r18, 0x01	; 1
    16d4:	c0 cf       	rjmp	.-128    	; 0x1656 <xQueueGenericSend+0x40>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    16d6:	ce 01       	movw	r24, r28
    16d8:	01 96       	adiw	r24, 0x01	; 1
    16da:	0e 94 72 12 	call	0x24e4	; 0x24e4 <vTaskSetTimeOutState>
    16de:	cf cf       	rjmp	.-98     	; 0x167e <xQueueGenericSend+0x68>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    16e0:	11 a2       	std	Z+33, r1	; 0x21
    16e2:	f5 01       	movw	r30, r10
    16e4:	82 a1       	ldd	r24, Z+34	; 0x22
    16e6:	8f 3f       	cpi	r24, 0xFF	; 255
    16e8:	c9 f6       	brne	.-78     	; 0x169c <xQueueGenericSend+0x86>
    16ea:	12 a2       	std	Z+34, r1	; 0x22
    16ec:	d7 cf       	rjmp	.-82     	; 0x169c <xQueueGenericSend+0x86>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    16ee:	4e 81       	ldd	r20, Y+6	; 0x06
    16f0:	5f 81       	ldd	r21, Y+7	; 0x07
    16f2:	68 85       	ldd	r22, Y+8	; 0x08
    16f4:	79 85       	ldd	r23, Y+9	; 0x09
    16f6:	c3 01       	movw	r24, r6
    16f8:	0e 94 0a 12 	call	0x2414	; 0x2414 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    16fc:	c5 01       	movw	r24, r10
    16fe:	0e 94 42 0a 	call	0x1484	; 0x1484 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1702:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskResumeAll>
    1706:	81 11       	cpse	r24, r1
    1708:	e4 cf       	rjmp	.-56     	; 0x16d2 <xQueueGenericSend+0xbc>
				{
					portYIELD_WITHIN_API();
    170a:	0e 94 19 09 	call	0x1232	; 0x1232 <vPortYield>
    170e:	21 e0       	ldi	r18, 0x01	; 1
    1710:	a2 cf       	rjmp	.-188    	; 0x1656 <xQueueGenericSend+0x40>
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1712:	40 2f       	mov	r20, r16
    1714:	b4 01       	movw	r22, r8
    1716:	c5 01       	movw	r24, r10
    1718:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    171c:	f5 01       	movw	r30, r10
    171e:	83 89       	ldd	r24, Z+19	; 0x13
    1720:	81 11       	cpse	r24, r1
    1722:	22 c0       	rjmp	.+68     	; 0x1768 <xQueueGenericSend+0x152>
						takes care of that. */
						portYIELD_WITHIN_API();
					}
				}

				taskEXIT_CRITICAL();
    1724:	0f 90       	pop	r0
    1726:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1728:	81 e0       	ldi	r24, 0x01	; 1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    172a:	29 96       	adiw	r28, 0x09	; 9
    172c:	0f b6       	in	r0, 0x3f	; 63
    172e:	f8 94       	cli
    1730:	de bf       	out	0x3e, r29	; 62
    1732:	0f be       	out	0x3f, r0	; 63
    1734:	cd bf       	out	0x3d, r28	; 61
    1736:	df 91       	pop	r29
    1738:	cf 91       	pop	r28
    173a:	0f 91       	pop	r16
    173c:	ff 90       	pop	r15
    173e:	ef 90       	pop	r14
    1740:	df 90       	pop	r13
    1742:	cf 90       	pop	r12
    1744:	bf 90       	pop	r11
    1746:	af 90       	pop	r10
    1748:	9f 90       	pop	r9
    174a:	8f 90       	pop	r8
    174c:	7f 90       	pop	r7
    174e:	6f 90       	pop	r6
    1750:	08 95       	ret
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1752:	0f 90       	pop	r0
    1754:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1756:	80 e0       	ldi	r24, 0x00	; 0
    1758:	e8 cf       	rjmp	.-48     	; 0x172a <xQueueGenericSend+0x114>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    175a:	c5 01       	movw	r24, r10
    175c:	0e 94 42 0a 	call	0x1484	; 0x1484 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1760:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1764:	80 e0       	ldi	r24, 0x00	; 0
    1766:	e1 cf       	rjmp	.-62     	; 0x172a <xQueueGenericSend+0x114>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1768:	c5 01       	movw	r24, r10
    176a:	43 96       	adiw	r24, 0x13	; 19
    176c:	0e 94 31 12 	call	0x2462	; 0x2462 <xTaskRemoveFromEventList>
    1770:	81 30       	cpi	r24, 0x01	; 1
    1772:	c1 f6       	brne	.-80     	; 0x1724 <xQueueGenericSend+0x10e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1774:	0e 94 19 09 	call	0x1232	; 0x1232 <vPortYield>
    1778:	d5 cf       	rjmp	.-86     	; 0x1724 <xQueueGenericSend+0x10e>

0000177a <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    177a:	0f 93       	push	r16
    177c:	cf 93       	push	r28
    177e:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1780:	83 e2       	ldi	r24, 0x23	; 35
    1782:	90 e0       	ldi	r25, 0x00	; 0
    1784:	0e 94 12 08 	call	0x1024	; 0x1024 <pvPortMalloc>
    1788:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    178a:	00 97       	sbiw	r24, 0x00	; 0
    178c:	01 f1       	breq	.+64     	; 0x17ce <xQueueCreateMutex+0x54>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    178e:	1b 82       	std	Y+3, r1	; 0x03
    1790:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1792:	19 82       	std	Y+1, r1	; 0x01
    1794:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1796:	1d 82       	std	Y+5, r1	; 0x05
    1798:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    179a:	1f 82       	std	Y+7, r1	; 0x07
    179c:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    179e:	1e 8e       	std	Y+30, r1	; 0x1e
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    17a0:	81 e0       	ldi	r24, 0x01	; 1
    17a2:	8f 8f       	std	Y+31, r24	; 0x1f
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    17a4:	18 a2       	std	Y+32, r1	; 0x20
			pxNewQueue->xRxLock = queueUNLOCKED;
    17a6:	8f ef       	ldi	r24, 0xFF	; 255
    17a8:	89 a3       	std	Y+33, r24	; 0x21
			pxNewQueue->xTxLock = queueUNLOCKED;
    17aa:	8a a3       	std	Y+34, r24	; 0x22
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    17ac:	ce 01       	movw	r24, r28
    17ae:	08 96       	adiw	r24, 0x08	; 8
    17b0:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    17b4:	ce 01       	movw	r24, r28
    17b6:	43 96       	adiw	r24, 0x13	; 19
    17b8:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    17bc:	00 e0       	ldi	r16, 0x00	; 0
    17be:	20 e0       	ldi	r18, 0x00	; 0
    17c0:	30 e0       	ldi	r19, 0x00	; 0
    17c2:	a9 01       	movw	r20, r18
    17c4:	60 e0       	ldi	r22, 0x00	; 0
    17c6:	70 e0       	ldi	r23, 0x00	; 0
    17c8:	ce 01       	movw	r24, r28
    17ca:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    17ce:	ce 01       	movw	r24, r28
    17d0:	df 91       	pop	r29
    17d2:	cf 91       	pop	r28
    17d4:	0f 91       	pop	r16
    17d6:	08 95       	ret

000017d8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    17d8:	0f 93       	push	r16
    17da:	1f 93       	push	r17
    17dc:	cf 93       	push	r28
    17de:	df 93       	push	r29
    17e0:	ec 01       	movw	r28, r24
    17e2:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    17e4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    17e6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    17e8:	98 17       	cp	r25, r24
    17ea:	30 f0       	brcs	.+12     	; 0x17f8 <xQueueGenericSendFromISR+0x20>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    17ec:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    17ee:	df 91       	pop	r29
    17f0:	cf 91       	pop	r28
    17f2:	1f 91       	pop	r17
    17f4:	0f 91       	pop	r16
    17f6:	08 95       	ret
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    17f8:	42 2f       	mov	r20, r18
    17fa:	ce 01       	movw	r24, r28
    17fc:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1800:	8a a1       	ldd	r24, Y+34	; 0x22
    1802:	8f 3f       	cpi	r24, 0xFF	; 255
    1804:	41 f0       	breq	.+16     	; 0x1816 <xQueueGenericSendFromISR+0x3e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1806:	8f 5f       	subi	r24, 0xFF	; 255
    1808:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    180a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    180c:	df 91       	pop	r29
    180e:	cf 91       	pop	r28
    1810:	1f 91       	pop	r17
    1812:	0f 91       	pop	r16
    1814:	08 95       	ret

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1816:	8b 89       	ldd	r24, Y+19	; 0x13
    1818:	88 23       	and	r24, r24
    181a:	b9 f3       	breq	.-18     	; 0x180a <xQueueGenericSendFromISR+0x32>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    181c:	ce 01       	movw	r24, r28
    181e:	43 96       	adiw	r24, 0x13	; 19
    1820:	0e 94 31 12 	call	0x2462	; 0x2462 <xTaskRemoveFromEventList>
    1824:	88 23       	and	r24, r24
    1826:	89 f3       	breq	.-30     	; 0x180a <xQueueGenericSendFromISR+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1828:	81 e0       	ldi	r24, 0x01	; 1
    182a:	f8 01       	movw	r30, r16
    182c:	80 83       	st	Z, r24
    182e:	df cf       	rjmp	.-66     	; 0x17ee <xQueueGenericSendFromISR+0x16>

00001830 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1830:	af 92       	push	r10
    1832:	bf 92       	push	r11
    1834:	cf 92       	push	r12
    1836:	df 92       	push	r13
    1838:	ef 92       	push	r14
    183a:	ff 92       	push	r15
    183c:	0f 93       	push	r16
    183e:	cf 93       	push	r28
    1840:	df 93       	push	r29
    1842:	cd b7       	in	r28, 0x3d	; 61
    1844:	de b7       	in	r29, 0x3e	; 62
    1846:	29 97       	sbiw	r28, 0x09	; 9
    1848:	0f b6       	in	r0, 0x3f	; 63
    184a:	f8 94       	cli
    184c:	de bf       	out	0x3e, r29	; 62
    184e:	0f be       	out	0x3f, r0	; 63
    1850:	cd bf       	out	0x3d, r28	; 61
    1852:	7c 01       	movw	r14, r24
    1854:	6b 01       	movw	r12, r22
    1856:	2e 83       	std	Y+6, r18	; 0x06
    1858:	3f 83       	std	Y+7, r19	; 0x07
    185a:	48 87       	std	Y+8, r20	; 0x08
    185c:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    185e:	90 e0       	ldi	r25, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1860:	57 01       	movw	r10, r14
    1862:	83 e1       	ldi	r24, 0x13	; 19
    1864:	a8 0e       	add	r10, r24
    1866:	b1 1c       	adc	r11, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1868:	0f b6       	in	r0, 0x3f	; 63
    186a:	f8 94       	cli
    186c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    186e:	f7 01       	movw	r30, r14
    1870:	86 8d       	ldd	r24, Z+30	; 0x1e
    1872:	81 11       	cpse	r24, r1
    1874:	69 c0       	rjmp	.+210    	; 0x1948 <xQueueGenericReceive+0x118>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1876:	4e 81       	ldd	r20, Y+6	; 0x06
    1878:	5f 81       	ldd	r21, Y+7	; 0x07
    187a:	68 85       	ldd	r22, Y+8	; 0x08
    187c:	79 85       	ldd	r23, Y+9	; 0x09
    187e:	45 2b       	or	r20, r21
    1880:	46 2b       	or	r20, r22
    1882:	47 2b       	or	r20, r23
    1884:	09 f4       	brne	.+2      	; 0x1888 <xQueueGenericReceive+0x58>
    1886:	7d c0       	rjmp	.+250    	; 0x1982 <xQueueGenericReceive+0x152>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1888:	99 23       	and	r25, r25
    188a:	09 f4       	brne	.+2      	; 0x188e <xQueueGenericReceive+0x5e>
    188c:	3e c0       	rjmp	.+124    	; 0x190a <xQueueGenericReceive+0xda>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    188e:	0f 90       	pop	r0
    1890:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1892:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1896:	0f b6       	in	r0, 0x3f	; 63
    1898:	f8 94       	cli
    189a:	0f 92       	push	r0
    189c:	f7 01       	movw	r30, r14
    189e:	81 a1       	ldd	r24, Z+33	; 0x21
    18a0:	8f 3f       	cpi	r24, 0xFF	; 255
    18a2:	09 f4       	brne	.+2      	; 0x18a6 <xQueueGenericReceive+0x76>
    18a4:	3e c0       	rjmp	.+124    	; 0x1922 <xQueueGenericReceive+0xf2>
    18a6:	f7 01       	movw	r30, r14
    18a8:	82 a1       	ldd	r24, Z+34	; 0x22
    18aa:	8f 3f       	cpi	r24, 0xFF	; 255
    18ac:	09 f4       	brne	.+2      	; 0x18b0 <xQueueGenericReceive+0x80>
    18ae:	3f c0       	rjmp	.+126    	; 0x192e <xQueueGenericReceive+0xfe>
    18b0:	0f 90       	pop	r0
    18b2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18b4:	be 01       	movw	r22, r28
    18b6:	6a 5f       	subi	r22, 0xFA	; 250
    18b8:	7f 4f       	sbci	r23, 0xFF	; 255
    18ba:	ce 01       	movw	r24, r28
    18bc:	01 96       	adiw	r24, 0x01	; 1
    18be:	0e 94 83 12 	call	0x2506	; 0x2506 <xTaskCheckForTimeOut>
    18c2:	81 11       	cpse	r24, r1
    18c4:	71 c0       	rjmp	.+226    	; 0x19a8 <xQueueGenericReceive+0x178>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    18c6:	0f b6       	in	r0, 0x3f	; 63
    18c8:	f8 94       	cli
    18ca:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    18cc:	f7 01       	movw	r30, r14
    18ce:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    18d0:	0f 90       	pop	r0
    18d2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18d4:	81 11       	cpse	r24, r1
    18d6:	1e c0       	rjmp	.+60     	; 0x1914 <xQueueGenericReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    18d8:	f7 01       	movw	r30, r14
    18da:	80 81       	ld	r24, Z
    18dc:	91 81       	ldd	r25, Z+1	; 0x01
    18de:	89 2b       	or	r24, r25
    18e0:	41 f1       	breq	.+80     	; 0x1932 <xQueueGenericReceive+0x102>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18e2:	4e 81       	ldd	r20, Y+6	; 0x06
    18e4:	5f 81       	ldd	r21, Y+7	; 0x07
    18e6:	68 85       	ldd	r22, Y+8	; 0x08
    18e8:	79 85       	ldd	r23, Y+9	; 0x09
    18ea:	c5 01       	movw	r24, r10
    18ec:	0e 94 0a 12 	call	0x2414	; 0x2414 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18f0:	c7 01       	movw	r24, r14
    18f2:	0e 94 42 0a 	call	0x1484	; 0x1484 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18f6:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskResumeAll>
    18fa:	88 23       	and	r24, r24
    18fc:	11 f0       	breq	.+4      	; 0x1902 <xQueueGenericReceive+0xd2>
    18fe:	91 e0       	ldi	r25, 0x01	; 1
    1900:	b3 cf       	rjmp	.-154    	; 0x1868 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1902:	0e 94 19 09 	call	0x1232	; 0x1232 <vPortYield>
    1906:	91 e0       	ldi	r25, 0x01	; 1
    1908:	af cf       	rjmp	.-162    	; 0x1868 <xQueueGenericReceive+0x38>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    190a:	ce 01       	movw	r24, r28
    190c:	01 96       	adiw	r24, 0x01	; 1
    190e:	0e 94 72 12 	call	0x24e4	; 0x24e4 <vTaskSetTimeOutState>
    1912:	bd cf       	rjmp	.-134    	; 0x188e <xQueueGenericReceive+0x5e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1914:	c7 01       	movw	r24, r14
    1916:	0e 94 42 0a 	call	0x1484	; 0x1484 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    191a:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskResumeAll>
    191e:	91 e0       	ldi	r25, 0x01	; 1
    1920:	a3 cf       	rjmp	.-186    	; 0x1868 <xQueueGenericReceive+0x38>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    1922:	11 a2       	std	Z+33, r1	; 0x21
    1924:	f7 01       	movw	r30, r14
    1926:	82 a1       	ldd	r24, Z+34	; 0x22
    1928:	8f 3f       	cpi	r24, 0xFF	; 255
    192a:	09 f0       	breq	.+2      	; 0x192e <xQueueGenericReceive+0xfe>
    192c:	c1 cf       	rjmp	.-126    	; 0x18b0 <xQueueGenericReceive+0x80>
    192e:	12 a2       	std	Z+34, r1	; 0x22
    1930:	bf cf       	rjmp	.-130    	; 0x18b0 <xQueueGenericReceive+0x80>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						portENTER_CRITICAL();
    1932:	0f b6       	in	r0, 0x3f	; 63
    1934:	f8 94       	cli
    1936:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1938:	f7 01       	movw	r30, r14
    193a:	82 81       	ldd	r24, Z+2	; 0x02
    193c:	93 81       	ldd	r25, Z+3	; 0x03
    193e:	0e 94 14 13 	call	0x2628	; 0x2628 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1942:	0f 90       	pop	r0
    1944:	0f be       	out	0x3f, r0	; 63
    1946:	cd cf       	rjmp	.-102    	; 0x18e2 <xQueueGenericReceive+0xb2>
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1948:	a6 80       	ldd	r10, Z+6	; 0x06
    194a:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    194c:	b6 01       	movw	r22, r12
    194e:	c7 01       	movw	r24, r14
    1950:	0e 94 28 0a 	call	0x1450	; 0x1450 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1954:	f7 01       	movw	r30, r14
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1956:	01 11       	cpse	r16, r1
    1958:	2e c0       	rjmp	.+92     	; 0x19b6 <xQueueGenericReceive+0x186>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    195a:	86 8d       	ldd	r24, Z+30	; 0x1e
    195c:	81 50       	subi	r24, 0x01	; 1
    195e:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1960:	80 81       	ld	r24, Z
    1962:	91 81       	ldd	r25, Z+1	; 0x01
    1964:	89 2b       	or	r24, r25
    1966:	b9 f1       	breq	.+110    	; 0x19d6 <xQueueGenericReceive+0x1a6>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1968:	f7 01       	movw	r30, r14
    196a:	80 85       	ldd	r24, Z+8	; 0x08
    196c:	88 23       	and	r24, r24
    196e:	41 f1       	breq	.+80     	; 0x19c0 <xQueueGenericReceive+0x190>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1970:	c7 01       	movw	r24, r14
    1972:	08 96       	adiw	r24, 0x08	; 8
    1974:	0e 94 31 12 	call	0x2462	; 0x2462 <xTaskRemoveFromEventList>
    1978:	81 30       	cpi	r24, 0x01	; 1
    197a:	11 f5       	brne	.+68     	; 0x19c0 <xQueueGenericReceive+0x190>
						{
							portYIELD_WITHIN_API();
    197c:	0e 94 19 09 	call	0x1232	; 0x1232 <vPortYield>
    1980:	1f c0       	rjmp	.+62     	; 0x19c0 <xQueueGenericReceive+0x190>
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1982:	0f 90       	pop	r0
    1984:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1986:	80 e0       	ldi	r24, 0x00	; 0
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    1988:	29 96       	adiw	r28, 0x09	; 9
    198a:	0f b6       	in	r0, 0x3f	; 63
    198c:	f8 94       	cli
    198e:	de bf       	out	0x3e, r29	; 62
    1990:	0f be       	out	0x3f, r0	; 63
    1992:	cd bf       	out	0x3d, r28	; 61
    1994:	df 91       	pop	r29
    1996:	cf 91       	pop	r28
    1998:	0f 91       	pop	r16
    199a:	ff 90       	pop	r15
    199c:	ef 90       	pop	r14
    199e:	df 90       	pop	r13
    19a0:	cf 90       	pop	r12
    19a2:	bf 90       	pop	r11
    19a4:	af 90       	pop	r10
    19a6:	08 95       	ret
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    19a8:	c7 01       	movw	r24, r14
    19aa:	0e 94 42 0a 	call	0x1484	; 0x1484 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19ae:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    19b2:	80 e0       	ldi	r24, 0x00	; 0
    19b4:	e9 cf       	rjmp	.-46     	; 0x1988 <xQueueGenericReceive+0x158>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    19b6:	b7 82       	std	Z+7, r11	; 0x07
    19b8:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19ba:	83 89       	ldd	r24, Z+19	; 0x13
    19bc:	81 11       	cpse	r24, r1
    19be:	04 c0       	rjmp	.+8      	; 0x19c8 <xQueueGenericReceive+0x198>
						}
					}

				}

				taskEXIT_CRITICAL();
    19c0:	0f 90       	pop	r0
    19c2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    19c4:	81 e0       	ldi	r24, 0x01	; 1
    19c6:	e0 cf       	rjmp	.-64     	; 0x1988 <xQueueGenericReceive+0x158>
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19c8:	c7 01       	movw	r24, r14
    19ca:	43 96       	adiw	r24, 0x13	; 19
    19cc:	0e 94 31 12 	call	0x2462	; 0x2462 <xTaskRemoveFromEventList>
    19d0:	88 23       	and	r24, r24
    19d2:	b1 f3       	breq	.-20     	; 0x19c0 <xQueueGenericReceive+0x190>
    19d4:	d3 cf       	rjmp	.-90     	; 0x197c <xQueueGenericReceive+0x14c>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    19d6:	0e 94 0f 13 	call	0x261e	; 0x261e <xTaskGetCurrentTaskHandle>
    19da:	f7 01       	movw	r30, r14
    19dc:	93 83       	std	Z+3, r25	; 0x03
    19de:	82 83       	std	Z+2, r24	; 0x02
    19e0:	c3 cf       	rjmp	.-122    	; 0x1968 <xQueueGenericReceive+0x138>

000019e2 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    19e2:	0f 93       	push	r16
    19e4:	1f 93       	push	r17
    19e6:	cf 93       	push	r28
    19e8:	df 93       	push	r29
    19ea:	00 d0       	rcall	.+0      	; 0x19ec <xQueueReceiveFromISR+0xa>
    19ec:	cd b7       	in	r28, 0x3d	; 61
    19ee:	de b7       	in	r29, 0x3e	; 62
    19f0:	8c 01       	movw	r16, r24
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    19f2:	fc 01       	movw	r30, r24
    19f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    19f6:	81 11       	cpse	r24, r1
    19f8:	08 c0       	rjmp	.+16     	; 0x1a0a <xQueueReceiveFromISR+0x28>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    19fa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19fc:	0f 90       	pop	r0
    19fe:	0f 90       	pop	r0
    1a00:	df 91       	pop	r29
    1a02:	cf 91       	pop	r28
    1a04:	1f 91       	pop	r17
    1a06:	0f 91       	pop	r16
    1a08:	08 95       	ret
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a0a:	c8 01       	movw	r24, r16
    1a0c:	49 83       	std	Y+1, r20	; 0x01
    1a0e:	5a 83       	std	Y+2, r21	; 0x02
    1a10:	0e 94 28 0a 	call	0x1450	; 0x1450 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1a14:	f8 01       	movw	r30, r16
    1a16:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a18:	81 50       	subi	r24, 0x01	; 1
    1a1a:	86 8f       	std	Z+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1a1c:	81 a1       	ldd	r24, Z+33	; 0x21
    1a1e:	49 81       	ldd	r20, Y+1	; 0x01
    1a20:	5a 81       	ldd	r21, Y+2	; 0x02
    1a22:	8f 3f       	cpi	r24, 0xFF	; 255
    1a24:	59 f0       	breq	.+22     	; 0x1a3c <xQueueReceiveFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1a26:	8f 5f       	subi	r24, 0xFF	; 255
    1a28:	f8 01       	movw	r30, r16
    1a2a:	81 a3       	std	Z+33, r24	; 0x21
			}

			xReturn = pdPASS;
    1a2c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a2e:	0f 90       	pop	r0
    1a30:	0f 90       	pop	r0
    1a32:	df 91       	pop	r29
    1a34:	cf 91       	pop	r28
    1a36:	1f 91       	pop	r17
    1a38:	0f 91       	pop	r16
    1a3a:	08 95       	ret
			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a3c:	80 85       	ldd	r24, Z+8	; 0x08
    1a3e:	88 23       	and	r24, r24
    1a40:	a9 f3       	breq	.-22     	; 0x1a2c <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a42:	c8 01       	movw	r24, r16
    1a44:	08 96       	adiw	r24, 0x08	; 8
    1a46:	49 83       	std	Y+1, r20	; 0x01
    1a48:	5a 83       	std	Y+2, r21	; 0x02
    1a4a:	0e 94 31 12 	call	0x2462	; 0x2462 <xTaskRemoveFromEventList>
    1a4e:	49 81       	ldd	r20, Y+1	; 0x01
    1a50:	5a 81       	ldd	r21, Y+2	; 0x02
    1a52:	88 23       	and	r24, r24
    1a54:	59 f3       	breq	.-42     	; 0x1a2c <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1a56:	81 e0       	ldi	r24, 0x01	; 1
    1a58:	fa 01       	movw	r30, r20
    1a5a:	80 83       	st	Z, r24
    1a5c:	cf cf       	rjmp	.-98     	; 0x19fc <xQueueReceiveFromISR+0x1a>

00001a5e <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a5e:	0f b6       	in	r0, 0x3f	; 63
    1a60:	f8 94       	cli
    1a62:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1a64:	fc 01       	movw	r30, r24
    1a66:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1a68:	0f 90       	pop	r0
    1a6a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1a6c:	08 95       	ret

00001a6e <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1a6e:	fc 01       	movw	r30, r24
    1a70:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    1a72:	08 95       	ret

00001a74 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1a74:	cf 93       	push	r28
    1a76:	df 93       	push	r29
    1a78:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1a7a:	88 81       	ld	r24, Y
    1a7c:	99 81       	ldd	r25, Y+1	; 0x01
    1a7e:	0e 94 3a 08 	call	0x1074	; 0x1074 <vPortFree>
	vPortFree( pxQueue );
    1a82:	ce 01       	movw	r24, r28
}
    1a84:	df 91       	pop	r29
    1a86:	cf 91       	pop	r28
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
	vPortFree( pxQueue );
    1a88:	0c 94 3a 08 	jmp	0x1074	; 0x1074 <vPortFree>

00001a8c <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1a8c:	fc 01       	movw	r30, r24
    1a8e:	96 8d       	ldd	r25, Z+30	; 0x1e
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	91 11       	cpse	r25, r1
    1a94:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1a96:	08 95       	ret

00001a98 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1a98:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1a9a:	26 8d       	ldd	r18, Z+30	; 0x1e
    1a9c:	81 e0       	ldi	r24, 0x01	; 1
    1a9e:	97 8d       	ldd	r25, Z+31	; 0x1f
    1aa0:	29 13       	cpse	r18, r25
    1aa2:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1aa4:	08 95       	ret

00001aa6 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1aa6:	80 91 50 0c 	lds	r24, 0x0C50
    1aaa:	82 30       	cpi	r24, 0x02	; 2
    1aac:	e0 f3       	brcs	.-8      	; 0x1aa6 <prvIdleTask>
			{
				taskYIELD();
    1aae:	0e 94 19 09 	call	0x1232	; 0x1232 <vPortYield>
    1ab2:	f9 cf       	rjmp	.-14     	; 0x1aa6 <prvIdleTask>

00001ab4 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1ab4:	cf 92       	push	r12
    1ab6:	df 92       	push	r13
    1ab8:	ef 92       	push	r14
    1aba:	ff 92       	push	r15
    1abc:	6b 01       	movw	r12, r22
    1abe:	7c 01       	movw	r14, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1ac0:	e0 91 1a 0c 	lds	r30, 0x0C1A
    1ac4:	f0 91 1b 0c 	lds	r31, 0x0C1B
    1ac8:	62 83       	std	Z+2, r22	; 0x02
    1aca:	73 83       	std	Z+3, r23	; 0x03
    1acc:	84 83       	std	Z+4, r24	; 0x04
    1ace:	95 83       	std	Z+5, r25	; 0x05

	if( xTimeToWake < xTickCount )
    1ad0:	80 91 24 0c 	lds	r24, 0x0C24
    1ad4:	90 91 25 0c 	lds	r25, 0x0C25
    1ad8:	a0 91 26 0c 	lds	r26, 0x0C26
    1adc:	b0 91 27 0c 	lds	r27, 0x0C27
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ae0:	60 91 1a 0c 	lds	r22, 0x0C1A
    1ae4:	70 91 1b 0c 	lds	r23, 0x0C1B
static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
    1ae8:	c8 16       	cp	r12, r24
    1aea:	d9 06       	cpc	r13, r25
    1aec:	ea 06       	cpc	r14, r26
    1aee:	fb 06       	cpc	r15, r27
    1af0:	10 f1       	brcs	.+68     	; 0x1b36 <prvAddCurrentTaskToDelayedList+0x82>
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1af2:	80 91 38 0c 	lds	r24, 0x0C38
    1af6:	90 91 39 0c 	lds	r25, 0x0C39
    1afa:	6e 5f       	subi	r22, 0xFE	; 254
    1afc:	7f 4f       	sbci	r23, 0xFF	; 255
    1afe:	0e 94 66 14 	call	0x28cc	; 0x28cc <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1b02:	80 91 01 01 	lds	r24, 0x0101
    1b06:	90 91 02 01 	lds	r25, 0x0102
    1b0a:	a0 91 03 01 	lds	r26, 0x0103
    1b0e:	b0 91 04 01 	lds	r27, 0x0104
    1b12:	c8 16       	cp	r12, r24
    1b14:	d9 06       	cpc	r13, r25
    1b16:	ea 06       	cpc	r14, r26
    1b18:	fb 06       	cpc	r15, r27
    1b1a:	40 f4       	brcc	.+16     	; 0x1b2c <prvAddCurrentTaskToDelayedList+0x78>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1b1c:	c0 92 01 01 	sts	0x0101, r12
    1b20:	d0 92 02 01 	sts	0x0102, r13
    1b24:	e0 92 03 01 	sts	0x0103, r14
    1b28:	f0 92 04 01 	sts	0x0104, r15
		}
	}
}
    1b2c:	ff 90       	pop	r15
    1b2e:	ef 90       	pop	r14
    1b30:	df 90       	pop	r13
    1b32:	cf 90       	pop	r12
    1b34:	08 95       	ret
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b36:	80 91 36 0c 	lds	r24, 0x0C36
    1b3a:	90 91 37 0c 	lds	r25, 0x0C37
    1b3e:	6e 5f       	subi	r22, 0xFE	; 254
    1b40:	7f 4f       	sbci	r23, 0xFF	; 255
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
    1b42:	ff 90       	pop	r15
    1b44:	ef 90       	pop	r14
    1b46:	df 90       	pop	r13
    1b48:	cf 90       	pop	r12
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b4a:	0c 94 66 14 	jmp	0x28cc	; 0x28cc <vListInsert>

00001b4e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1b4e:	5f 92       	push	r5
    1b50:	6f 92       	push	r6
    1b52:	7f 92       	push	r7
    1b54:	8f 92       	push	r8
    1b56:	9f 92       	push	r9
    1b58:	af 92       	push	r10
    1b5a:	bf 92       	push	r11
    1b5c:	cf 92       	push	r12
    1b5e:	df 92       	push	r13
    1b60:	ef 92       	push	r14
    1b62:	ff 92       	push	r15
    1b64:	0f 93       	push	r16
    1b66:	1f 93       	push	r17
    1b68:	cf 93       	push	r28
    1b6a:	df 93       	push	r29
    1b6c:	5c 01       	movw	r10, r24
    1b6e:	4b 01       	movw	r8, r22
    1b70:	ea 01       	movw	r28, r20
    1b72:	39 01       	movw	r6, r18
    1b74:	50 2e       	mov	r5, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1b76:	88 e2       	ldi	r24, 0x28	; 40
    1b78:	90 e0       	ldi	r25, 0x00	; 0
    1b7a:	0e 94 12 08 	call	0x1024	; 0x1024 <pvPortMalloc>
    1b7e:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1b80:	00 97       	sbiw	r24, 0x00	; 0
    1b82:	09 f4       	brne	.+2      	; 0x1b86 <xTaskGenericCreate+0x38>
    1b84:	ea c0       	rjmp	.+468    	; 0x1d5a <xTaskGenericCreate+0x20c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1b86:	c1 14       	cp	r12, r1
    1b88:	d1 04       	cpc	r13, r1
    1b8a:	09 f4       	brne	.+2      	; 0x1b8e <xTaskGenericCreate+0x40>
    1b8c:	da c0       	rjmp	.+436    	; 0x1d42 <xTaskGenericCreate+0x1f4>
    1b8e:	fc 01       	movw	r30, r24
    1b90:	d4 8e       	std	Z+28, r13	; 0x1c
    1b92:	c3 8e       	std	Z+27, r12	; 0x1b
    1b94:	c6 01       	movw	r24, r12
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1b96:	ae 01       	movw	r20, r28
    1b98:	61 e1       	ldi	r22, 0x11	; 17
    1b9a:	70 e0       	ldi	r23, 0x00	; 0
    1b9c:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1ba0:	21 97       	sbiw	r28, 0x01	; 1
    1ba2:	f8 01       	movw	r30, r16
    1ba4:	c3 8c       	ldd	r12, Z+27	; 0x1b
    1ba6:	d4 8c       	ldd	r13, Z+28	; 0x1c
    1ba8:	cc 0e       	add	r12, r28
    1baa:	dd 1e       	adc	r13, r29
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1bac:	4a e0       	ldi	r20, 0x0A	; 10
    1bae:	50 e0       	ldi	r21, 0x00	; 0
    1bb0:	b4 01       	movw	r22, r8
    1bb2:	c8 01       	movw	r24, r16
    1bb4:	4d 96       	adiw	r24, 0x1d	; 29
    1bb6:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1bba:	f8 01       	movw	r30, r16
    1bbc:	16 a2       	std	Z+38, r1	; 0x26
    1bbe:	95 2c       	mov	r9, r5
    1bc0:	f3 e0       	ldi	r31, 0x03	; 3
    1bc2:	f5 15       	cp	r31, r5
    1bc4:	08 f4       	brcc	.+2      	; 0x1bc8 <xTaskGenericCreate+0x7a>
    1bc6:	84 c0       	rjmp	.+264    	; 0x1cd0 <xTaskGenericCreate+0x182>
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1bc8:	f8 01       	movw	r30, r16
    1bca:	92 8e       	std	Z+26, r9	; 0x1a
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    1bcc:	97 a2       	std	Z+39, r9	; 0x27
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1bce:	e8 01       	movw	r28, r16
    1bd0:	22 96       	adiw	r28, 0x02	; 2
    1bd2:	ce 01       	movw	r24, r28
    1bd4:	0e 94 3f 14 	call	0x287e	; 0x287e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1bd8:	c8 01       	movw	r24, r16
    1bda:	0e 96       	adiw	r24, 0x0e	; 14
    1bdc:	0e 94 3f 14 	call	0x287e	; 0x287e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1be0:	f8 01       	movw	r30, r16
    1be2:	13 87       	std	Z+11, r17	; 0x0b
    1be4:	02 87       	std	Z+10, r16	; 0x0a

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1be6:	84 e0       	ldi	r24, 0x04	; 4
    1be8:	90 e0       	ldi	r25, 0x00	; 0
    1bea:	a0 e0       	ldi	r26, 0x00	; 0
    1bec:	b0 e0       	ldi	r27, 0x00	; 0
    1bee:	89 19       	sub	r24, r9
    1bf0:	91 09       	sbc	r25, r1
    1bf2:	a1 09       	sbc	r26, r1
    1bf4:	b1 09       	sbc	r27, r1
    1bf6:	86 87       	std	Z+14, r24	; 0x0e
    1bf8:	97 87       	std	Z+15, r25	; 0x0f
    1bfa:	a0 8b       	std	Z+16, r26	; 0x10
    1bfc:	b1 8b       	std	Z+17, r27	; 0x11
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1bfe:	17 8b       	std	Z+23, r17	; 0x17
    1c00:	06 8b       	std	Z+22, r16	; 0x16
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1c02:	a3 01       	movw	r20, r6
    1c04:	b5 01       	movw	r22, r10
    1c06:	c6 01       	movw	r24, r12
    1c08:	0e 94 49 08 	call	0x1092	; 0x1092 <pxPortInitialiseStack>
    1c0c:	f8 01       	movw	r30, r16
    1c0e:	91 83       	std	Z+1, r25	; 0x01
    1c10:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1c12:	e1 14       	cp	r14, r1
    1c14:	f1 04       	cpc	r15, r1
    1c16:	19 f0       	breq	.+6      	; 0x1c1e <xTaskGenericCreate+0xd0>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1c18:	f7 01       	movw	r30, r14
    1c1a:	11 83       	std	Z+1, r17	; 0x01
    1c1c:	00 83       	st	Z, r16
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1c1e:	0f b6       	in	r0, 0x3f	; 63
    1c20:	f8 94       	cli
    1c22:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1c24:	80 91 28 0c 	lds	r24, 0x0C28
    1c28:	8f 5f       	subi	r24, 0xFF	; 255
    1c2a:	80 93 28 0c 	sts	0x0C28, r24
			if( pxCurrentTCB == NULL )
    1c2e:	80 91 1a 0c 	lds	r24, 0x0C1A
    1c32:	90 91 1b 0c 	lds	r25, 0x0C1B
    1c36:	89 2b       	or	r24, r25
    1c38:	09 f4       	brne	.+2      	; 0x1c3c <xTaskGenericCreate+0xee>
    1c3a:	51 c0       	rjmp	.+162    	; 0x1cde <xTaskGenericCreate+0x190>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1c3c:	80 91 21 0c 	lds	r24, 0x0C21
    1c40:	81 11       	cpse	r24, r1
    1c42:	0b c0       	rjmp	.+22     	; 0x1c5a <xTaskGenericCreate+0x10c>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1c44:	e0 91 1a 0c 	lds	r30, 0x0C1A
    1c48:	f0 91 1b 0c 	lds	r31, 0x0C1B
    1c4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c4e:	58 16       	cp	r5, r24
    1c50:	20 f0       	brcs	.+8      	; 0x1c5a <xTaskGenericCreate+0x10c>
					{
						pxCurrentTCB = pxNewTCB;
    1c52:	10 93 1b 0c 	sts	0x0C1B, r17
    1c56:	00 93 1a 0c 	sts	0x0C1A, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1c5a:	f8 01       	movw	r30, r16
    1c5c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c5e:	90 91 23 0c 	lds	r25, 0x0C23
    1c62:	98 17       	cp	r25, r24
    1c64:	10 f4       	brcc	.+4      	; 0x1c6a <xTaskGenericCreate+0x11c>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1c66:	80 93 23 0c 	sts	0x0C23, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1c6a:	90 91 1c 0c 	lds	r25, 0x0C1C
    1c6e:	9f 5f       	subi	r25, 0xFF	; 255
    1c70:	90 93 1c 0c 	sts	0x0C1C, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    1c74:	90 91 22 0c 	lds	r25, 0x0C22
    1c78:	98 17       	cp	r25, r24
    1c7a:	38 f1       	brcs	.+78     	; 0x1cca <xTaskGenericCreate+0x17c>
    1c7c:	fb e0       	ldi	r31, 0x0B	; 11
    1c7e:	8f 9f       	mul	r24, r31
    1c80:	c0 01       	movw	r24, r0
    1c82:	11 24       	eor	r1, r1
    1c84:	be 01       	movw	r22, r28
    1c86:	80 5b       	subi	r24, 0xB0	; 176
    1c88:	93 4f       	sbci	r25, 0xF3	; 243
    1c8a:	0e 94 43 14 	call	0x2886	; 0x2886 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1c8e:	0f 90       	pop	r0
    1c90:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1c92:	80 91 21 0c 	lds	r24, 0x0C21
    1c96:	88 23       	and	r24, r24
    1c98:	39 f0       	breq	.+14     	; 0x1ca8 <xTaskGenericCreate+0x15a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1c9a:	e0 91 1a 0c 	lds	r30, 0x0C1A
    1c9e:	f0 91 1b 0c 	lds	r31, 0x0C1B
    1ca2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ca4:	85 15       	cp	r24, r5
    1ca6:	b8 f0       	brcs	.+46     	; 0x1cd6 <xTaskGenericCreate+0x188>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1ca8:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1caa:	df 91       	pop	r29
    1cac:	cf 91       	pop	r28
    1cae:	1f 91       	pop	r17
    1cb0:	0f 91       	pop	r16
    1cb2:	ff 90       	pop	r15
    1cb4:	ef 90       	pop	r14
    1cb6:	df 90       	pop	r13
    1cb8:	cf 90       	pop	r12
    1cba:	bf 90       	pop	r11
    1cbc:	af 90       	pop	r10
    1cbe:	9f 90       	pop	r9
    1cc0:	8f 90       	pop	r8
    1cc2:	7f 90       	pop	r7
    1cc4:	6f 90       	pop	r6
    1cc6:	5f 90       	pop	r5
    1cc8:	08 95       	ret
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );
    1cca:	80 93 22 0c 	sts	0x0C22, r24
    1cce:	d6 cf       	rjmp	.-84     	; 0x1c7c <xTaskGenericCreate+0x12e>
    1cd0:	83 e0       	ldi	r24, 0x03	; 3
    1cd2:	98 2e       	mov	r9, r24
    1cd4:	79 cf       	rjmp	.-270    	; 0x1bc8 <xTaskGenericCreate+0x7a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				portYIELD_WITHIN_API();
    1cd6:	0e 94 19 09 	call	0x1232	; 0x1232 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1cda:	81 e0       	ldi	r24, 0x01	; 1
    1cdc:	e6 cf       	rjmp	.-52     	; 0x1caa <xTaskGenericCreate+0x15c>
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1cde:	10 93 1b 0c 	sts	0x0C1B, r17
    1ce2:	00 93 1a 0c 	sts	0x0C1A, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1ce6:	80 91 28 0c 	lds	r24, 0x0C28
    1cea:	81 30       	cpi	r24, 0x01	; 1
    1cec:	09 f0       	breq	.+2      	; 0x1cf0 <xTaskGenericCreate+0x1a2>
    1cee:	b5 cf       	rjmp	.-150    	; 0x1c5a <xTaskGenericCreate+0x10c>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1cf0:	80 e5       	ldi	r24, 0x50	; 80
    1cf2:	9c e0       	ldi	r25, 0x0C	; 12
    1cf4:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>
    1cf8:	8b e5       	ldi	r24, 0x5B	; 91
    1cfa:	9c e0       	ldi	r25, 0x0C	; 12
    1cfc:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>
    1d00:	86 e6       	ldi	r24, 0x66	; 102
    1d02:	9c e0       	ldi	r25, 0x0C	; 12
    1d04:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>
    1d08:	81 e7       	ldi	r24, 0x71	; 113
    1d0a:	9c e0       	ldi	r25, 0x0C	; 12
    1d0c:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1d10:	85 e4       	ldi	r24, 0x45	; 69
    1d12:	9c e0       	ldi	r25, 0x0C	; 12
    1d14:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1d18:	8a e3       	ldi	r24, 0x3A	; 58
    1d1a:	9c e0       	ldi	r25, 0x0C	; 12
    1d1c:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1d20:	8b e2       	ldi	r24, 0x2B	; 43
    1d22:	9c e0       	ldi	r25, 0x0C	; 12
    1d24:	0e 94 2e 14 	call	0x285c	; 0x285c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1d28:	85 e4       	ldi	r24, 0x45	; 69
    1d2a:	9c e0       	ldi	r25, 0x0C	; 12
    1d2c:	90 93 39 0c 	sts	0x0C39, r25
    1d30:	80 93 38 0c 	sts	0x0C38, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1d34:	8a e3       	ldi	r24, 0x3A	; 58
    1d36:	9c e0       	ldi	r25, 0x0C	; 12
    1d38:	90 93 37 0c 	sts	0x0C37, r25
    1d3c:	80 93 36 0c 	sts	0x0C36, r24
    1d40:	8c cf       	rjmp	.-232    	; 0x1c5a <xTaskGenericCreate+0x10c>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1d42:	ce 01       	movw	r24, r28
    1d44:	0e 94 12 08 	call	0x1024	; 0x1024 <pvPortMalloc>
    1d48:	f8 01       	movw	r30, r16
    1d4a:	94 8f       	std	Z+28, r25	; 0x1c
    1d4c:	83 8f       	std	Z+27, r24	; 0x1b

		if( pxNewTCB->pxStack == NULL )
    1d4e:	00 97       	sbiw	r24, 0x00	; 0
    1d50:	09 f0       	breq	.+2      	; 0x1d54 <xTaskGenericCreate+0x206>
    1d52:	21 cf       	rjmp	.-446    	; 0x1b96 <xTaskGenericCreate+0x48>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1d54:	c8 01       	movw	r24, r16
    1d56:	0e 94 3a 08 	call	0x1074	; 0x1074 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d5a:	8f ef       	ldi	r24, 0xFF	; 255
    1d5c:	a6 cf       	rjmp	.-180    	; 0x1caa <xTaskGenericCreate+0x15c>

00001d5e <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
    1d5e:	0f b6       	in	r0, 0x3f	; 63
    1d60:	f8 94       	cli
    1d62:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1d64:	00 97       	sbiw	r24, 0x00	; 0
    1d66:	29 f0       	breq	.+10     	; 0x1d72 <uxTaskPriorityGet+0x14>
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1d68:	0f 90       	pop	r0
    1d6a:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1d6c:	fc 01       	movw	r30, r24
    1d6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d70:	08 95       	ret

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1d72:	80 91 1a 0c 	lds	r24, 0x0C1A
    1d76:	90 91 1b 0c 	lds	r25, 0x0C1B
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1d7a:	0f 90       	pop	r0
    1d7c:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1d7e:	fc 01       	movw	r30, r24
    1d80:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d82:	08 95       	ret

00001d84 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    1d84:	ef 92       	push	r14
    1d86:	ff 92       	push	r15
    1d88:	1f 93       	push	r17
    1d8a:	cf 93       	push	r28
    1d8c:	df 93       	push	r29
    1d8e:	ec 01       	movw	r28, r24
    1d90:	e6 2f       	mov	r30, r22
    1d92:	64 30       	cpi	r22, 0x04	; 4
    1d94:	08 f0       	brcs	.+2      	; 0x1d98 <vTaskPrioritySet+0x14>
    1d96:	e3 e0       	ldi	r30, 0x03	; 3
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
		}

		taskENTER_CRITICAL();
    1d98:	0f b6       	in	r0, 0x3f	; 63
    1d9a:	f8 94       	cli
    1d9c:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    1d9e:	80 91 1a 0c 	lds	r24, 0x0C1A
    1da2:	90 91 1b 0c 	lds	r25, 0x0C1B
    1da6:	c8 17       	cp	r28, r24
    1da8:	d9 07       	cpc	r29, r25
    1daa:	d9 f1       	breq	.+118    	; 0x1e22 <vTaskPrioritySet+0x9e>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1dac:	20 97       	sbiw	r28, 0x00	; 0
    1dae:	c9 f1       	breq	.+114    	; 0x1e22 <vTaskPrioritySet+0x9e>
    1db0:	9e 01       	movw	r18, r28

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
    1db2:	8f a1       	ldd	r24, Y+39	; 0x27
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    1db4:	8e 17       	cp	r24, r30
    1db6:	11 f1       	breq	.+68     	; 0x1dfc <vTaskPrioritySet+0x78>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
				{
					if( pxTask != NULL )
    1db8:	11 e0       	ldi	r17, 0x01	; 1

			if( uxCurrentPriority != uxNewPriority )
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    1dba:	8e 17       	cp	r24, r30
    1dbc:	38 f5       	brcc	.+78     	; 0x1e0c <vTaskPrioritySet+0x88>
				{
					if( pxTask != NULL )
    1dbe:	23 2b       	or	r18, r19
    1dc0:	39 f1       	breq	.+78     	; 0x1e10 <vTaskPrioritySet+0x8c>

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1dc2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1dc4:	89 17       	cp	r24, r25
    1dc6:	41 f1       	breq	.+80     	; 0x1e18 <vTaskPrioritySet+0x94>
					{
						pxTCB->uxPriority = uxNewPriority;
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    1dc8:	ef a3       	std	Y+39, r30	; 0x27
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    1dca:	44 e0       	ldi	r20, 0x04	; 4
    1dcc:	50 e0       	ldi	r21, 0x00	; 0
    1dce:	60 e0       	ldi	r22, 0x00	; 0
    1dd0:	70 e0       	ldi	r23, 0x00	; 0
    1dd2:	4e 1b       	sub	r20, r30
    1dd4:	51 09       	sbc	r21, r1
    1dd6:	61 09       	sbc	r22, r1
    1dd8:	71 09       	sbc	r23, r1
    1dda:	4e 87       	std	Y+14, r20	; 0x0e
    1ddc:	5f 87       	std	Y+15, r21	; 0x0f
    1dde:	68 8b       	std	Y+16, r22	; 0x10
    1de0:	79 8b       	std	Y+17, r23	; 0x11

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    1de2:	2b e0       	ldi	r18, 0x0B	; 11
    1de4:	82 9f       	mul	r24, r18
    1de6:	c0 01       	movw	r24, r0
    1de8:	11 24       	eor	r1, r1
    1dea:	80 5b       	subi	r24, 0xB0	; 176
    1dec:	93 4f       	sbci	r25, 0xF3	; 243
    1dee:	2c 85       	ldd	r18, Y+12	; 0x0c
    1df0:	3d 85       	ldd	r19, Y+13	; 0x0d
    1df2:	28 17       	cp	r18, r24
    1df4:	39 07       	cpc	r19, r25
    1df6:	e1 f0       	breq	.+56     	; 0x1e30 <vTaskPrioritySet+0xac>
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
				}

				if( xYieldRequired == pdTRUE )
    1df8:	11 30       	cpi	r17, 0x01	; 1
    1dfa:	81 f0       	breq	.+32     	; 0x1e1c <vTaskPrioritySet+0x98>
				{
					portYIELD_WITHIN_API();
				}
			}
		}
		taskEXIT_CRITICAL();
    1dfc:	0f 90       	pop	r0
    1dfe:	0f be       	out	0x3f, r0	; 63
	}
    1e00:	df 91       	pop	r29
    1e02:	cf 91       	pop	r28
    1e04:	1f 91       	pop	r17
    1e06:	ff 90       	pop	r15
    1e08:	ef 90       	pop	r14
    1e0a:	08 95       	ret
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
					}
				}
				else if( pxTask == NULL )
    1e0c:	23 2b       	or	r18, r19
    1e0e:	c9 f2       	breq	.-78     	; 0x1dc2 <vTaskPrioritySet+0x3e>
    1e10:	10 e0       	ldi	r17, 0x00	; 0

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1e12:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e14:	89 13       	cpse	r24, r25
    1e16:	d8 cf       	rjmp	.-80     	; 0x1dc8 <vTaskPrioritySet+0x44>
					{
						pxTCB->uxPriority = uxNewPriority;
    1e18:	ea 8f       	std	Y+26, r30	; 0x1a
    1e1a:	d6 cf       	rjmp	.-84     	; 0x1dc8 <vTaskPrioritySet+0x44>
					prvAddTaskToReadyQueue( pxTCB );
				}

				if( xYieldRequired == pdTRUE )
				{
					portYIELD_WITHIN_API();
    1e1c:	0e 94 19 09 	call	0x1232	; 0x1232 <vPortYield>
    1e20:	ed cf       	rjmp	.-38     	; 0x1dfc <vTaskPrioritySet+0x78>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1e22:	c0 91 1a 0c 	lds	r28, 0x0C1A
    1e26:	d0 91 1b 0c 	lds	r29, 0x0C1B
    1e2a:	20 e0       	ldi	r18, 0x00	; 0
    1e2c:	30 e0       	ldi	r19, 0x00	; 0
    1e2e:	c1 cf       	rjmp	.-126    	; 0x1db2 <vTaskPrioritySet+0x2e>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    1e30:	7e 01       	movw	r14, r28
    1e32:	82 e0       	ldi	r24, 0x02	; 2
    1e34:	e8 0e       	add	r14, r24
    1e36:	f1 1c       	adc	r15, r1
    1e38:	c7 01       	movw	r24, r14
    1e3a:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1e3e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e40:	90 91 22 0c 	lds	r25, 0x0C22
    1e44:	98 17       	cp	r25, r24
    1e46:	10 f4       	brcc	.+4      	; 0x1e4c <vTaskPrioritySet+0xc8>
    1e48:	80 93 22 0c 	sts	0x0C22, r24
    1e4c:	2b e0       	ldi	r18, 0x0B	; 11
    1e4e:	82 9f       	mul	r24, r18
    1e50:	c0 01       	movw	r24, r0
    1e52:	11 24       	eor	r1, r1
    1e54:	b7 01       	movw	r22, r14
    1e56:	80 5b       	subi	r24, 0xB0	; 176
    1e58:	93 4f       	sbci	r25, 0xF3	; 243
    1e5a:	0e 94 43 14 	call	0x2886	; 0x2886 <vListInsertEnd>
    1e5e:	cc cf       	rjmp	.-104    	; 0x1df8 <vTaskPrioritySet+0x74>

00001e60 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1e60:	af 92       	push	r10
    1e62:	bf 92       	push	r11
    1e64:	cf 92       	push	r12
    1e66:	df 92       	push	r13
    1e68:	ef 92       	push	r14
    1e6a:	ff 92       	push	r15
    1e6c:	0f 93       	push	r16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
    1e6e:	a1 2c       	mov	r10, r1
    1e70:	b1 2c       	mov	r11, r1
    1e72:	c1 2c       	mov	r12, r1
    1e74:	d1 2c       	mov	r13, r1
    1e76:	99 e2       	ldi	r25, 0x29	; 41
    1e78:	e9 2e       	mov	r14, r25
    1e7a:	9c e0       	ldi	r25, 0x0C	; 12
    1e7c:	f9 2e       	mov	r15, r25
    1e7e:	00 e0       	ldi	r16, 0x00	; 0
    1e80:	20 e0       	ldi	r18, 0x00	; 0
    1e82:	30 e0       	ldi	r19, 0x00	; 0
    1e84:	44 e6       	ldi	r20, 0x64	; 100
    1e86:	50 e0       	ldi	r21, 0x00	; 0
    1e88:	63 e7       	ldi	r22, 0x73	; 115
    1e8a:	71 e0       	ldi	r23, 0x01	; 1
    1e8c:	83 e5       	ldi	r24, 0x53	; 83
    1e8e:	9d e0       	ldi	r25, 0x0D	; 13
    1e90:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1e94:	81 30       	cpi	r24, 0x01	; 1
    1e96:	41 f0       	breq	.+16     	; 0x1ea8 <vTaskStartScheduler+0x48>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1e98:	0f 91       	pop	r16
    1e9a:	ff 90       	pop	r15
    1e9c:	ef 90       	pop	r14
    1e9e:	df 90       	pop	r13
    1ea0:	cf 90       	pop	r12
    1ea2:	bf 90       	pop	r11
    1ea4:	af 90       	pop	r10
    1ea6:	08 95       	ret
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1ea8:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1eaa:	80 93 21 0c 	sts	0x0C21, r24
		xTickCount = ( portTickType ) 0U;
    1eae:	10 92 24 0c 	sts	0x0C24, r1
    1eb2:	10 92 25 0c 	sts	0x0C25, r1
    1eb6:	10 92 26 0c 	sts	0x0C26, r1
    1eba:	10 92 27 0c 	sts	0x0C27, r1
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1ebe:	0f 91       	pop	r16
    1ec0:	ff 90       	pop	r15
    1ec2:	ef 90       	pop	r14
    1ec4:	df 90       	pop	r13
    1ec6:	cf 90       	pop	r12
    1ec8:	bf 90       	pop	r11
    1eca:	af 90       	pop	r10
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1ecc:	0c 94 dd 08 	jmp	0x11ba	; 0x11ba <xPortStartScheduler>

00001ed0 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1ed0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1ed2:	10 92 21 0c 	sts	0x0C21, r1
	vPortEndScheduler();
    1ed6:	0c 94 18 09 	jmp	0x1230	; 0x1230 <vPortEndScheduler>

00001eda <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1eda:	80 91 20 0c 	lds	r24, 0x0C20
    1ede:	8f 5f       	subi	r24, 0xFF	; 255
    1ee0:	80 93 20 0c 	sts	0x0C20, r24
    1ee4:	08 95       	ret

00001ee6 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1ee6:	0f b6       	in	r0, 0x3f	; 63
    1ee8:	f8 94       	cli
    1eea:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1eec:	60 91 24 0c 	lds	r22, 0x0C24
    1ef0:	70 91 25 0c 	lds	r23, 0x0C25
    1ef4:	80 91 26 0c 	lds	r24, 0x0C26
    1ef8:	90 91 27 0c 	lds	r25, 0x0C27
	}
	taskEXIT_CRITICAL();
    1efc:	0f 90       	pop	r0
    1efe:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1f00:	08 95       	ret

00001f02 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1f02:	60 91 24 0c 	lds	r22, 0x0C24
    1f06:	70 91 25 0c 	lds	r23, 0x0C25
    1f0a:	80 91 26 0c 	lds	r24, 0x0C26
    1f0e:	90 91 27 0c 	lds	r25, 0x0C27
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1f12:	08 95       	ret

00001f14 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1f14:	80 91 28 0c 	lds	r24, 0x0C28
}
    1f18:	08 95       	ret

00001f1a <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1f1a:	00 97       	sbiw	r24, 0x00	; 0
    1f1c:	11 f0       	breq	.+4      	; 0x1f22 <pcTaskGetTaskName+0x8>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1f1e:	4d 96       	adiw	r24, 0x1d	; 29
    1f20:	08 95       	ret
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1f22:	80 91 1a 0c 	lds	r24, 0x0C1A
    1f26:	90 91 1b 0c 	lds	r25, 0x0C1B
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1f2a:	4d 96       	adiw	r24, 0x1d	; 29
    1f2c:	08 95       	ret

00001f2e <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    1f2e:	80 91 29 0c 	lds	r24, 0x0C29
    1f32:	90 91 2a 0c 	lds	r25, 0x0C2A
    1f36:	08 95       	ret

00001f38 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1f38:	ff 92       	push	r15
    1f3a:	0f 93       	push	r16
    1f3c:	1f 93       	push	r17
    1f3e:	cf 93       	push	r28
    1f40:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1f42:	80 91 20 0c 	lds	r24, 0x0C20
    1f46:	81 11       	cpse	r24, r1
    1f48:	ac c0       	rjmp	.+344    	; 0x20a2 <vTaskIncrementTick+0x16a>
	{
		++xTickCount;
    1f4a:	80 91 24 0c 	lds	r24, 0x0C24
    1f4e:	90 91 25 0c 	lds	r25, 0x0C25
    1f52:	a0 91 26 0c 	lds	r26, 0x0C26
    1f56:	b0 91 27 0c 	lds	r27, 0x0C27
    1f5a:	01 96       	adiw	r24, 0x01	; 1
    1f5c:	a1 1d       	adc	r26, r1
    1f5e:	b1 1d       	adc	r27, r1
    1f60:	80 93 24 0c 	sts	0x0C24, r24
    1f64:	90 93 25 0c 	sts	0x0C25, r25
    1f68:	a0 93 26 0c 	sts	0x0C26, r26
    1f6c:	b0 93 27 0c 	sts	0x0C27, r27
		if( xTickCount == ( portTickType ) 0U )
    1f70:	80 91 24 0c 	lds	r24, 0x0C24
    1f74:	90 91 25 0c 	lds	r25, 0x0C25
    1f78:	a0 91 26 0c 	lds	r26, 0x0C26
    1f7c:	b0 91 27 0c 	lds	r27, 0x0C27
    1f80:	89 2b       	or	r24, r25
    1f82:	8a 2b       	or	r24, r26
    1f84:	8b 2b       	or	r24, r27
    1f86:	09 f4       	brne	.+2      	; 0x1f8a <vTaskIncrementTick+0x52>
    1f88:	97 c0       	rjmp	.+302    	; 0x20b8 <vTaskIncrementTick+0x180>
    1f8a:	80 91 01 01 	lds	r24, 0x0101
    1f8e:	90 91 02 01 	lds	r25, 0x0102
    1f92:	a0 91 03 01 	lds	r26, 0x0103
    1f96:	b0 91 04 01 	lds	r27, 0x0104
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1f9a:	40 91 24 0c 	lds	r20, 0x0C24
    1f9e:	50 91 25 0c 	lds	r21, 0x0C25
    1fa2:	60 91 26 0c 	lds	r22, 0x0C26
    1fa6:	70 91 27 0c 	lds	r23, 0x0C27
    1faa:	48 17       	cp	r20, r24
    1fac:	59 07       	cpc	r21, r25
    1fae:	6a 07       	cpc	r22, r26
    1fb0:	7b 07       	cpc	r23, r27
    1fb2:	08 f4       	brcc	.+2      	; 0x1fb6 <vTaskIncrementTick+0x7e>
    1fb4:	7b c0       	rjmp	.+246    	; 0x20ac <vTaskIncrementTick+0x174>
    1fb6:	e0 91 38 0c 	lds	r30, 0x0C38
    1fba:	f0 91 39 0c 	lds	r31, 0x0C39
    1fbe:	80 81       	ld	r24, Z
    1fc0:	88 23       	and	r24, r24
    1fc2:	09 f4       	brne	.+2      	; 0x1fc6 <vTaskIncrementTick+0x8e>
    1fc4:	5d c0       	rjmp	.+186    	; 0x2080 <vTaskIncrementTick+0x148>
    1fc6:	e0 91 38 0c 	lds	r30, 0x0C38
    1fca:	f0 91 39 0c 	lds	r31, 0x0C39
    1fce:	07 80       	ldd	r0, Z+7	; 0x07
    1fd0:	f0 85       	ldd	r31, Z+8	; 0x08
    1fd2:	e0 2d       	mov	r30, r0
    1fd4:	c0 85       	ldd	r28, Z+8	; 0x08
    1fd6:	d1 85       	ldd	r29, Z+9	; 0x09
    1fd8:	8a 81       	ldd	r24, Y+2	; 0x02
    1fda:	9b 81       	ldd	r25, Y+3	; 0x03
    1fdc:	ac 81       	ldd	r26, Y+4	; 0x04
    1fde:	bd 81       	ldd	r27, Y+5	; 0x05
    1fe0:	40 91 24 0c 	lds	r20, 0x0C24
    1fe4:	50 91 25 0c 	lds	r21, 0x0C25
    1fe8:	60 91 26 0c 	lds	r22, 0x0C26
    1fec:	70 91 27 0c 	lds	r23, 0x0C27
    1ff0:	48 17       	cp	r20, r24
    1ff2:	59 07       	cpc	r21, r25
    1ff4:	6a 07       	cpc	r22, r26
    1ff6:	7b 07       	cpc	r23, r27
    1ff8:	08 f4       	brcc	.+2      	; 0x1ffc <vTaskIncrementTick+0xc4>
    1ffa:	a1 c0       	rjmp	.+322    	; 0x213e <vTaskIncrementTick+0x206>
    1ffc:	2b e0       	ldi	r18, 0x0B	; 11
    1ffe:	f2 2e       	mov	r15, r18
    2000:	1b c0       	rjmp	.+54     	; 0x2038 <vTaskIncrementTick+0x100>
    2002:	e0 91 38 0c 	lds	r30, 0x0C38
    2006:	f0 91 39 0c 	lds	r31, 0x0C39
    200a:	07 80       	ldd	r0, Z+7	; 0x07
    200c:	f0 85       	ldd	r31, Z+8	; 0x08
    200e:	e0 2d       	mov	r30, r0
    2010:	c0 85       	ldd	r28, Z+8	; 0x08
    2012:	d1 85       	ldd	r29, Z+9	; 0x09
    2014:	8a 81       	ldd	r24, Y+2	; 0x02
    2016:	9b 81       	ldd	r25, Y+3	; 0x03
    2018:	ac 81       	ldd	r26, Y+4	; 0x04
    201a:	bd 81       	ldd	r27, Y+5	; 0x05
    201c:	40 91 24 0c 	lds	r20, 0x0C24
    2020:	50 91 25 0c 	lds	r21, 0x0C25
    2024:	60 91 26 0c 	lds	r22, 0x0C26
    2028:	70 91 27 0c 	lds	r23, 0x0C27
    202c:	48 17       	cp	r20, r24
    202e:	59 07       	cpc	r21, r25
    2030:	6a 07       	cpc	r22, r26
    2032:	7b 07       	cpc	r23, r27
    2034:	08 f4       	brcc	.+2      	; 0x2038 <vTaskIncrementTick+0x100>
    2036:	83 c0       	rjmp	.+262    	; 0x213e <vTaskIncrementTick+0x206>
    2038:	8e 01       	movw	r16, r28
    203a:	0e 5f       	subi	r16, 0xFE	; 254
    203c:	1f 4f       	sbci	r17, 0xFF	; 255
    203e:	c8 01       	movw	r24, r16
    2040:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>
    2044:	88 8d       	ldd	r24, Y+24	; 0x18
    2046:	99 8d       	ldd	r25, Y+25	; 0x19
    2048:	89 2b       	or	r24, r25
    204a:	21 f0       	breq	.+8      	; 0x2054 <vTaskIncrementTick+0x11c>
    204c:	ce 01       	movw	r24, r28
    204e:	0e 96       	adiw	r24, 0x0e	; 14
    2050:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>
    2054:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2056:	90 91 22 0c 	lds	r25, 0x0C22
    205a:	98 17       	cp	r25, r24
    205c:	10 f4       	brcc	.+4      	; 0x2062 <vTaskIncrementTick+0x12a>
    205e:	80 93 22 0c 	sts	0x0C22, r24
    2062:	f8 9e       	mul	r15, r24
    2064:	c0 01       	movw	r24, r0
    2066:	11 24       	eor	r1, r1
    2068:	b8 01       	movw	r22, r16
    206a:	80 5b       	subi	r24, 0xB0	; 176
    206c:	93 4f       	sbci	r25, 0xF3	; 243
    206e:	0e 94 43 14 	call	0x2886	; 0x2886 <vListInsertEnd>
    2072:	e0 91 38 0c 	lds	r30, 0x0C38
    2076:	f0 91 39 0c 	lds	r31, 0x0C39
    207a:	80 81       	ld	r24, Z
    207c:	81 11       	cpse	r24, r1
    207e:	c1 cf       	rjmp	.-126    	; 0x2002 <vTaskIncrementTick+0xca>
    2080:	8f ef       	ldi	r24, 0xFF	; 255
    2082:	9f ef       	ldi	r25, 0xFF	; 255
    2084:	dc 01       	movw	r26, r24
    2086:	80 93 01 01 	sts	0x0101, r24
    208a:	90 93 02 01 	sts	0x0102, r25
    208e:	a0 93 03 01 	sts	0x0103, r26
    2092:	b0 93 04 01 	sts	0x0104, r27
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2096:	df 91       	pop	r29
    2098:	cf 91       	pop	r28
    209a:	1f 91       	pop	r17
    209c:	0f 91       	pop	r16
    209e:	ff 90       	pop	r15
    20a0:	08 95       	ret
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
    20a2:	80 91 1f 0c 	lds	r24, 0x0C1F
    20a6:	8f 5f       	subi	r24, 0xFF	; 255
    20a8:	80 93 1f 0c 	sts	0x0C1F, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    20ac:	df 91       	pop	r29
    20ae:	cf 91       	pop	r28
    20b0:	1f 91       	pop	r17
    20b2:	0f 91       	pop	r16
    20b4:	ff 90       	pop	r15
    20b6:	08 95       	ret
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    20b8:	80 91 38 0c 	lds	r24, 0x0C38
    20bc:	90 91 39 0c 	lds	r25, 0x0C39
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    20c0:	20 91 36 0c 	lds	r18, 0x0C36
    20c4:	30 91 37 0c 	lds	r19, 0x0C37
    20c8:	30 93 39 0c 	sts	0x0C39, r19
    20cc:	20 93 38 0c 	sts	0x0C38, r18
			pxOverflowDelayedTaskList = pxTemp;
    20d0:	90 93 37 0c 	sts	0x0C37, r25
    20d4:	80 93 36 0c 	sts	0x0C36, r24
			xNumOfOverflows++;
    20d8:	80 91 1d 0c 	lds	r24, 0x0C1D
    20dc:	8f 5f       	subi	r24, 0xFF	; 255
    20de:	80 93 1d 0c 	sts	0x0C1D, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    20e2:	e0 91 38 0c 	lds	r30, 0x0C38
    20e6:	f0 91 39 0c 	lds	r31, 0x0C39
    20ea:	80 81       	ld	r24, Z
    20ec:	81 11       	cpse	r24, r1
    20ee:	0c c0       	rjmp	.+24     	; 0x2108 <vTaskIncrementTick+0x1d0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    20f0:	8f ef       	ldi	r24, 0xFF	; 255
    20f2:	9f ef       	ldi	r25, 0xFF	; 255
    20f4:	dc 01       	movw	r26, r24
    20f6:	80 93 01 01 	sts	0x0101, r24
    20fa:	90 93 02 01 	sts	0x0102, r25
    20fe:	a0 93 03 01 	sts	0x0103, r26
    2102:	b0 93 04 01 	sts	0x0104, r27
    2106:	49 cf       	rjmp	.-366    	; 0x1f9a <vTaskIncrementTick+0x62>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2108:	e0 91 38 0c 	lds	r30, 0x0C38
    210c:	f0 91 39 0c 	lds	r31, 0x0C39
    2110:	07 80       	ldd	r0, Z+7	; 0x07
    2112:	f0 85       	ldd	r31, Z+8	; 0x08
    2114:	e0 2d       	mov	r30, r0
    2116:	00 84       	ldd	r0, Z+8	; 0x08
    2118:	f1 85       	ldd	r31, Z+9	; 0x09
    211a:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    211c:	52 81       	ldd	r21, Z+2	; 0x02
    211e:	43 81       	ldd	r20, Z+3	; 0x03
    2120:	34 81       	ldd	r19, Z+4	; 0x04
    2122:	25 81       	ldd	r18, Z+5	; 0x05
    2124:	50 93 01 01 	sts	0x0101, r21
    2128:	40 93 02 01 	sts	0x0102, r20
    212c:	30 93 03 01 	sts	0x0103, r19
    2130:	20 93 04 01 	sts	0x0104, r18
    2134:	85 2f       	mov	r24, r21
    2136:	94 2f       	mov	r25, r20
    2138:	a3 2f       	mov	r26, r19
    213a:	b2 2f       	mov	r27, r18
    213c:	2e cf       	rjmp	.-420    	; 0x1f9a <vTaskIncrementTick+0x62>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    213e:	80 93 01 01 	sts	0x0101, r24
    2142:	90 93 02 01 	sts	0x0102, r25
    2146:	a0 93 03 01 	sts	0x0103, r26
    214a:	b0 93 04 01 	sts	0x0104, r27
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    214e:	df 91       	pop	r29
    2150:	cf 91       	pop	r28
    2152:	1f 91       	pop	r17
    2154:	0f 91       	pop	r16
    2156:	ff 90       	pop	r15
    2158:	08 95       	ret

0000215a <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    215a:	ef 92       	push	r14
    215c:	ff 92       	push	r15
    215e:	0f 93       	push	r16
    2160:	1f 93       	push	r17
    2162:	cf 93       	push	r28
    2164:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2166:	0f b6       	in	r0, 0x3f	; 63
    2168:	f8 94       	cli
    216a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    216c:	80 91 20 0c 	lds	r24, 0x0C20
    2170:	81 50       	subi	r24, 0x01	; 1
    2172:	80 93 20 0c 	sts	0x0C20, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2176:	80 91 20 0c 	lds	r24, 0x0C20
    217a:	81 11       	cpse	r24, r1
    217c:	44 c0       	rjmp	.+136    	; 0x2206 <xTaskResumeAll+0xac>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    217e:	80 91 28 0c 	lds	r24, 0x0C28
    2182:	88 23       	and	r24, r24
    2184:	09 f4       	brne	.+2      	; 0x2188 <xTaskResumeAll+0x2e>
    2186:	3f c0       	rjmp	.+126    	; 0x2206 <xTaskResumeAll+0xac>
    2188:	e1 2c       	mov	r14, r1
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    218a:	3b e0       	ldi	r19, 0x0B	; 11
    218c:	f3 2e       	mov	r15, r19
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    218e:	80 91 2b 0c 	lds	r24, 0x0C2B
    2192:	88 23       	and	r24, r24
    2194:	69 f1       	breq	.+90     	; 0x21f0 <xTaskResumeAll+0x96>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2196:	e0 91 32 0c 	lds	r30, 0x0C32
    219a:	f0 91 33 0c 	lds	r31, 0x0C33
    219e:	c0 85       	ldd	r28, Z+8	; 0x08
    21a0:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    21a2:	ce 01       	movw	r24, r28
    21a4:	0e 96       	adiw	r24, 0x0e	; 14
    21a6:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    21aa:	8e 01       	movw	r16, r28
    21ac:	0e 5f       	subi	r16, 0xFE	; 254
    21ae:	1f 4f       	sbci	r17, 0xFF	; 255
    21b0:	c8 01       	movw	r24, r16
    21b2:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    21b6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    21b8:	90 91 22 0c 	lds	r25, 0x0C22
    21bc:	98 17       	cp	r25, r24
    21be:	10 f4       	brcc	.+4      	; 0x21c4 <xTaskResumeAll+0x6a>
    21c0:	80 93 22 0c 	sts	0x0C22, r24
    21c4:	f8 9e       	mul	r15, r24
    21c6:	c0 01       	movw	r24, r0
    21c8:	11 24       	eor	r1, r1
    21ca:	b8 01       	movw	r22, r16
    21cc:	80 5b       	subi	r24, 0xB0	; 176
    21ce:	93 4f       	sbci	r25, 0xF3	; 243
    21d0:	0e 94 43 14 	call	0x2886	; 0x2886 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    21d4:	e0 91 1a 0c 	lds	r30, 0x0C1A
    21d8:	f0 91 1b 0c 	lds	r31, 0x0C1B
    21dc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    21de:	82 8d       	ldd	r24, Z+26	; 0x1a
    21e0:	98 17       	cp	r25, r24
    21e2:	a8 f2       	brcs	.-86     	; 0x218e <xTaskResumeAll+0x34>
					{
						xYieldRequired = pdTRUE;
    21e4:	ee 24       	eor	r14, r14
    21e6:	e3 94       	inc	r14
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    21e8:	80 91 2b 0c 	lds	r24, 0x0C2B
    21ec:	81 11       	cpse	r24, r1
    21ee:	d3 cf       	rjmp	.-90     	; 0x2196 <xTaskResumeAll+0x3c>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    21f0:	80 91 1f 0c 	lds	r24, 0x0C1F
    21f4:	81 11       	cpse	r24, r1
    21f6:	18 c0       	rjmp	.+48     	; 0x2228 <xTaskResumeAll+0xce>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    21f8:	81 e0       	ldi	r24, 0x01	; 1
    21fa:	e8 16       	cp	r14, r24
    21fc:	c9 f0       	breq	.+50     	; 0x2230 <xTaskResumeAll+0xd6>
    21fe:	80 91 1e 0c 	lds	r24, 0x0C1E
    2202:	81 30       	cpi	r24, 0x01	; 1
    2204:	a9 f0       	breq	.+42     	; 0x2230 <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2206:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2208:	0f 90       	pop	r0
    220a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    220c:	df 91       	pop	r29
    220e:	cf 91       	pop	r28
    2210:	1f 91       	pop	r17
    2212:	0f 91       	pop	r16
    2214:	ff 90       	pop	r15
    2216:	ef 90       	pop	r14
    2218:	08 95       	ret
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    221a:	0e 94 9c 0f 	call	0x1f38	; 0x1f38 <vTaskIncrementTick>
						--uxMissedTicks;
    221e:	80 91 1f 0c 	lds	r24, 0x0C1F
    2222:	81 50       	subi	r24, 0x01	; 1
    2224:	80 93 1f 0c 	sts	0x0C1F, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2228:	80 91 1f 0c 	lds	r24, 0x0C1F
    222c:	81 11       	cpse	r24, r1
    222e:	f5 cf       	rjmp	.-22     	; 0x221a <xTaskResumeAll+0xc0>
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2230:	10 92 1e 0c 	sts	0x0C1E, r1
					portYIELD_WITHIN_API();
    2234:	0e 94 19 09 	call	0x1232	; 0x1232 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2238:	81 e0       	ldi	r24, 0x01	; 1
    223a:	e6 cf       	rjmp	.-52     	; 0x2208 <xTaskResumeAll+0xae>

0000223c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    223c:	cf 92       	push	r12
    223e:	df 92       	push	r13
    2240:	ef 92       	push	r14
    2242:	ff 92       	push	r15
    2244:	0f 93       	push	r16
    2246:	1f 93       	push	r17
    2248:	cf 93       	push	r28
    224a:	df 93       	push	r29
    224c:	00 d0       	rcall	.+0      	; 0x224e <vTaskDelayUntil+0x12>
    224e:	00 d0       	rcall	.+0      	; 0x2250 <vTaskDelayUntil+0x14>
    2250:	cd b7       	in	r28, 0x3d	; 61
    2252:	de b7       	in	r29, 0x3e	; 62

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2254:	20 91 20 0c 	lds	r18, 0x0C20
    2258:	2f 5f       	subi	r18, 0xFF	; 255
    225a:	20 93 20 0c 	sts	0x0C20, r18
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    225e:	fc 01       	movw	r30, r24
    2260:	00 81       	ld	r16, Z
    2262:	11 81       	ldd	r17, Z+1	; 0x01
    2264:	22 81       	ldd	r18, Z+2	; 0x02
    2266:	33 81       	ldd	r19, Z+3	; 0x03
    2268:	40 0f       	add	r20, r16
    226a:	51 1f       	adc	r21, r17
    226c:	62 1f       	adc	r22, r18
    226e:	73 1f       	adc	r23, r19

			if( xTickCount < *pxPreviousWakeTime )
    2270:	c0 90 24 0c 	lds	r12, 0x0C24
    2274:	d0 90 25 0c 	lds	r13, 0x0C25
    2278:	e0 90 26 0c 	lds	r14, 0x0C26
    227c:	f0 90 27 0c 	lds	r15, 0x0C27
    2280:	c0 16       	cp	r12, r16
    2282:	d1 06       	cpc	r13, r17
    2284:	e2 06       	cpc	r14, r18
    2286:	f3 06       	cpc	r15, r19
    2288:	e8 f4       	brcc	.+58     	; 0x22c4 <vTaskDelayUntil+0x88>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    228a:	40 17       	cp	r20, r16
    228c:	51 07       	cpc	r21, r17
    228e:	62 07       	cpc	r22, r18
    2290:	73 07       	cpc	r23, r19
    2292:	e8 f0       	brcs	.+58     	; 0x22ce <vTaskDelayUntil+0x92>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2294:	fc 01       	movw	r30, r24
    2296:	40 83       	st	Z, r20
    2298:	51 83       	std	Z+1, r21	; 0x01
    229a:	62 83       	std	Z+2, r22	; 0x02
    229c:	73 83       	std	Z+3, r23	; 0x03
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
				prvAddCurrentTaskToDelayedList( xTimeToWake );
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    229e:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    22a2:	81 11       	cpse	r24, r1
    22a4:	02 c0       	rjmp	.+4      	; 0x22aa <vTaskDelayUntil+0x6e>
		{
			portYIELD_WITHIN_API();
    22a6:	0e 94 19 09 	call	0x1232	; 0x1232 <vPortYield>
		}
	}
    22aa:	0f 90       	pop	r0
    22ac:	0f 90       	pop	r0
    22ae:	0f 90       	pop	r0
    22b0:	0f 90       	pop	r0
    22b2:	df 91       	pop	r29
    22b4:	cf 91       	pop	r28
    22b6:	1f 91       	pop	r17
    22b8:	0f 91       	pop	r16
    22ba:	ff 90       	pop	r15
    22bc:	ef 90       	pop	r14
    22be:	df 90       	pop	r13
    22c0:	cf 90       	pop	r12
    22c2:	08 95       	ret
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    22c4:	40 17       	cp	r20, r16
    22c6:	51 07       	cpc	r21, r17
    22c8:	62 07       	cpc	r22, r18
    22ca:	73 07       	cpc	r23, r19
    22cc:	68 f0       	brcs	.+26     	; 0x22e8 <vTaskDelayUntil+0xac>
    22ce:	00 91 24 0c 	lds	r16, 0x0C24
    22d2:	10 91 25 0c 	lds	r17, 0x0C25
    22d6:	20 91 26 0c 	lds	r18, 0x0C26
    22da:	30 91 27 0c 	lds	r19, 0x0C27
    22de:	04 17       	cp	r16, r20
    22e0:	15 07       	cpc	r17, r21
    22e2:	26 07       	cpc	r18, r22
    22e4:	37 07       	cpc	r19, r23
    22e6:	b0 f6       	brcc	.-84     	; 0x2294 <vTaskDelayUntil+0x58>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22e8:	fc 01       	movw	r30, r24
    22ea:	40 83       	st	Z, r20
    22ec:	51 83       	std	Z+1, r21	; 0x01
    22ee:	62 83       	std	Z+2, r22	; 0x02
    22f0:	73 83       	std	Z+3, r23	; 0x03
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    22f2:	80 91 1a 0c 	lds	r24, 0x0C1A
    22f6:	90 91 1b 0c 	lds	r25, 0x0C1B
    22fa:	02 96       	adiw	r24, 0x02	; 2
    22fc:	49 83       	std	Y+1, r20	; 0x01
    22fe:	5a 83       	std	Y+2, r21	; 0x02
    2300:	6b 83       	std	Y+3, r22	; 0x03
    2302:	7c 83       	std	Y+4, r23	; 0x04
    2304:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2308:	49 81       	ldd	r20, Y+1	; 0x01
    230a:	5a 81       	ldd	r21, Y+2	; 0x02
    230c:	6b 81       	ldd	r22, Y+3	; 0x03
    230e:	7c 81       	ldd	r23, Y+4	; 0x04
    2310:	cb 01       	movw	r24, r22
    2312:	ba 01       	movw	r22, r20
    2314:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <prvAddCurrentTaskToDelayedList>
    2318:	c2 cf       	rjmp	.-124    	; 0x229e <vTaskDelayUntil+0x62>

0000231a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    231a:	cf 92       	push	r12
    231c:	df 92       	push	r13
    231e:	ef 92       	push	r14
    2320:	ff 92       	push	r15
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2322:	61 15       	cp	r22, r1
    2324:	71 05       	cpc	r23, r1
    2326:	81 05       	cpc	r24, r1
    2328:	91 05       	cpc	r25, r1
    232a:	39 f4       	brne	.+14     	; 0x233a <vTaskDelay+0x20>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    232c:	0e 94 19 09 	call	0x1232	; 0x1232 <vPortYield>
		}
	}
    2330:	ff 90       	pop	r15
    2332:	ef 90       	pop	r14
    2334:	df 90       	pop	r13
    2336:	cf 90       	pop	r12
    2338:	08 95       	ret

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    233a:	20 91 20 0c 	lds	r18, 0x0C20
    233e:	2f 5f       	subi	r18, 0xFF	; 255
    2340:	20 93 20 0c 	sts	0x0C20, r18
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2344:	c0 90 24 0c 	lds	r12, 0x0C24
    2348:	d0 90 25 0c 	lds	r13, 0x0C25
    234c:	e0 90 26 0c 	lds	r14, 0x0C26
    2350:	f0 90 27 0c 	lds	r15, 0x0C27
    2354:	c6 0e       	add	r12, r22
    2356:	d7 1e       	adc	r13, r23
    2358:	e8 1e       	adc	r14, r24
    235a:	f9 1e       	adc	r15, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    235c:	80 91 1a 0c 	lds	r24, 0x0C1A
    2360:	90 91 1b 0c 	lds	r25, 0x0C1B
    2364:	02 96       	adiw	r24, 0x02	; 2
    2366:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    236a:	c7 01       	movw	r24, r14
    236c:	b6 01       	movw	r22, r12
    236e:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2372:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2376:	88 23       	and	r24, r24
    2378:	c9 f2       	breq	.-78     	; 0x232c <vTaskDelay+0x12>
		{
			portYIELD_WITHIN_API();
		}
	}
    237a:	ff 90       	pop	r15
    237c:	ef 90       	pop	r14
    237e:	df 90       	pop	r13
    2380:	cf 90       	pop	r12
    2382:	08 95       	ret

00002384 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2384:	80 91 20 0c 	lds	r24, 0x0C20
    2388:	81 11       	cpse	r24, r1
    238a:	39 c0       	rjmp	.+114    	; 0x23fe <vTaskSwitchContext+0x7a>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    238c:	e0 91 22 0c 	lds	r30, 0x0C22
    2390:	8b e0       	ldi	r24, 0x0B	; 11
    2392:	e8 9f       	mul	r30, r24
    2394:	f0 01       	movw	r30, r0
    2396:	11 24       	eor	r1, r1
    2398:	e0 5b       	subi	r30, 0xB0	; 176
    239a:	f3 4f       	sbci	r31, 0xF3	; 243
    239c:	80 81       	ld	r24, Z
    239e:	81 11       	cpse	r24, r1
    23a0:	10 c0       	rjmp	.+32     	; 0x23c2 <vTaskSwitchContext+0x3e>
    23a2:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    23a4:	80 91 22 0c 	lds	r24, 0x0C22
    23a8:	81 50       	subi	r24, 0x01	; 1
    23aa:	80 93 22 0c 	sts	0x0C22, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    23ae:	e0 91 22 0c 	lds	r30, 0x0C22
    23b2:	9e 9f       	mul	r25, r30
    23b4:	f0 01       	movw	r30, r0
    23b6:	11 24       	eor	r1, r1
    23b8:	e0 5b       	subi	r30, 0xB0	; 176
    23ba:	f3 4f       	sbci	r31, 0xF3	; 243
    23bc:	80 81       	ld	r24, Z
    23be:	88 23       	and	r24, r24
    23c0:	89 f3       	breq	.-30     	; 0x23a4 <vTaskSwitchContext+0x20>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    23c2:	e0 91 22 0c 	lds	r30, 0x0C22
    23c6:	8b e0       	ldi	r24, 0x0B	; 11
    23c8:	e8 9f       	mul	r30, r24
    23ca:	f0 01       	movw	r30, r0
    23cc:	11 24       	eor	r1, r1
    23ce:	e0 5b       	subi	r30, 0xB0	; 176
    23d0:	f3 4f       	sbci	r31, 0xF3	; 243
    23d2:	a1 81       	ldd	r26, Z+1	; 0x01
    23d4:	b2 81       	ldd	r27, Z+2	; 0x02
    23d6:	14 96       	adiw	r26, 0x04	; 4
    23d8:	0d 90       	ld	r0, X+
    23da:	bc 91       	ld	r27, X
    23dc:	a0 2d       	mov	r26, r0
    23de:	b2 83       	std	Z+2, r27	; 0x02
    23e0:	a1 83       	std	Z+1, r26	; 0x01
    23e2:	cf 01       	movw	r24, r30
    23e4:	03 96       	adiw	r24, 0x03	; 3
    23e6:	a8 17       	cp	r26, r24
    23e8:	b9 07       	cpc	r27, r25
    23ea:	69 f0       	breq	.+26     	; 0x2406 <vTaskSwitchContext+0x82>
    23ec:	18 96       	adiw	r26, 0x08	; 8
    23ee:	8d 91       	ld	r24, X+
    23f0:	9c 91       	ld	r25, X
    23f2:	19 97       	sbiw	r26, 0x09	; 9
    23f4:	90 93 1b 0c 	sts	0x0C1B, r25
    23f8:	80 93 1a 0c 	sts	0x0C1A, r24
    23fc:	08 95       	ret
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    23fe:	81 e0       	ldi	r24, 0x01	; 1
    2400:	80 93 1e 0c 	sts	0x0C1E, r24
    2404:	08 95       	ret
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2406:	14 96       	adiw	r26, 0x04	; 4
    2408:	0d 90       	ld	r0, X+
    240a:	bc 91       	ld	r27, X
    240c:	a0 2d       	mov	r26, r0
    240e:	b2 83       	std	Z+2, r27	; 0x02
    2410:	a1 83       	std	Z+1, r26	; 0x01
    2412:	ec cf       	rjmp	.-40     	; 0x23ec <vTaskSwitchContext+0x68>

00002414 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2414:	cf 92       	push	r12
    2416:	df 92       	push	r13
    2418:	ef 92       	push	r14
    241a:	ff 92       	push	r15
    241c:	6a 01       	movw	r12, r20
    241e:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2420:	60 91 1a 0c 	lds	r22, 0x0C1A
    2424:	70 91 1b 0c 	lds	r23, 0x0C1B
    2428:	62 5f       	subi	r22, 0xF2	; 242
    242a:	7f 4f       	sbci	r23, 0xFF	; 255
    242c:	0e 94 66 14 	call	0x28cc	; 0x28cc <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2430:	80 91 1a 0c 	lds	r24, 0x0C1A
    2434:	90 91 1b 0c 	lds	r25, 0x0C1B
    2438:	02 96       	adiw	r24, 0x02	; 2
    243a:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    243e:	60 91 24 0c 	lds	r22, 0x0C24
    2442:	70 91 25 0c 	lds	r23, 0x0C25
    2446:	80 91 26 0c 	lds	r24, 0x0C26
    244a:	90 91 27 0c 	lds	r25, 0x0C27
    244e:	6c 0d       	add	r22, r12
    2450:	7d 1d       	adc	r23, r13
    2452:	8e 1d       	adc	r24, r14
    2454:	9f 1d       	adc	r25, r15
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    2456:	ff 90       	pop	r15
    2458:	ef 90       	pop	r14
    245a:	df 90       	pop	r13
    245c:	cf 90       	pop	r12
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    245e:	0c 94 5a 0d 	jmp	0x1ab4	; 0x1ab4 <prvAddCurrentTaskToDelayedList>

00002462 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2462:	0f 93       	push	r16
    2464:	1f 93       	push	r17
    2466:	cf 93       	push	r28
    2468:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    246a:	dc 01       	movw	r26, r24
    246c:	17 96       	adiw	r26, 0x07	; 7
    246e:	ed 91       	ld	r30, X+
    2470:	fc 91       	ld	r31, X
    2472:	18 97       	sbiw	r26, 0x08	; 8
    2474:	c0 85       	ldd	r28, Z+8	; 0x08
    2476:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2478:	8e 01       	movw	r16, r28
    247a:	02 5f       	subi	r16, 0xF2	; 242
    247c:	1f 4f       	sbci	r17, 0xFF	; 255
    247e:	c8 01       	movw	r24, r16
    2480:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2484:	80 91 20 0c 	lds	r24, 0x0C20
    2488:	81 11       	cpse	r24, r1
    248a:	23 c0       	rjmp	.+70     	; 0x24d2 <xTaskRemoveFromEventList+0x70>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    248c:	8e 01       	movw	r16, r28
    248e:	0e 5f       	subi	r16, 0xFE	; 254
    2490:	1f 4f       	sbci	r17, 0xFF	; 255
    2492:	c8 01       	movw	r24, r16
    2494:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2498:	8a 8d       	ldd	r24, Y+26	; 0x1a
    249a:	90 91 22 0c 	lds	r25, 0x0C22
    249e:	98 17       	cp	r25, r24
    24a0:	f0 f0       	brcs	.+60     	; 0x24de <xTaskRemoveFromEventList+0x7c>
    24a2:	bb e0       	ldi	r27, 0x0B	; 11
    24a4:	8b 9f       	mul	r24, r27
    24a6:	c0 01       	movw	r24, r0
    24a8:	11 24       	eor	r1, r1
    24aa:	b8 01       	movw	r22, r16
    24ac:	80 5b       	subi	r24, 0xB0	; 176
    24ae:	93 4f       	sbci	r25, 0xF3	; 243
    24b0:	0e 94 43 14 	call	0x2886	; 0x2886 <vListInsertEnd>
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    24b4:	e0 91 1a 0c 	lds	r30, 0x0C1A
    24b8:	f0 91 1b 0c 	lds	r31, 0x0C1B
    24bc:	81 e0       	ldi	r24, 0x01	; 1
    24be:	2a 8d       	ldd	r18, Y+26	; 0x1a
    24c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    24c2:	29 17       	cp	r18, r25
    24c4:	08 f4       	brcc	.+2      	; 0x24c8 <xTaskRemoveFromEventList+0x66>
    24c6:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    24c8:	df 91       	pop	r29
    24ca:	cf 91       	pop	r28
    24cc:	1f 91       	pop	r17
    24ce:	0f 91       	pop	r16
    24d0:	08 95       	ret
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    24d2:	b8 01       	movw	r22, r16
    24d4:	8b e2       	ldi	r24, 0x2B	; 43
    24d6:	9c e0       	ldi	r25, 0x0C	; 12
    24d8:	0e 94 43 14 	call	0x2886	; 0x2886 <vListInsertEnd>
    24dc:	eb cf       	rjmp	.-42     	; 0x24b4 <xTaskRemoveFromEventList+0x52>
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    24de:	80 93 22 0c 	sts	0x0C22, r24
    24e2:	df cf       	rjmp	.-66     	; 0x24a2 <xTaskRemoveFromEventList+0x40>

000024e4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    24e4:	20 91 1d 0c 	lds	r18, 0x0C1D
    24e8:	fc 01       	movw	r30, r24
    24ea:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    24ec:	40 91 24 0c 	lds	r20, 0x0C24
    24f0:	50 91 25 0c 	lds	r21, 0x0C25
    24f4:	60 91 26 0c 	lds	r22, 0x0C26
    24f8:	70 91 27 0c 	lds	r23, 0x0C27
    24fc:	41 83       	std	Z+1, r20	; 0x01
    24fe:	52 83       	std	Z+2, r21	; 0x02
    2500:	63 83       	std	Z+3, r22	; 0x03
    2502:	74 83       	std	Z+4, r23	; 0x04
    2504:	08 95       	ret

00002506 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2506:	cf 92       	push	r12
    2508:	df 92       	push	r13
    250a:	ef 92       	push	r14
    250c:	ff 92       	push	r15
    250e:	0f 93       	push	r16
    2510:	1f 93       	push	r17
    2512:	fc 01       	movw	r30, r24
    2514:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2516:	0f b6       	in	r0, 0x3f	; 63
    2518:	f8 94       	cli
    251a:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    251c:	80 91 1d 0c 	lds	r24, 0x0C1D
    2520:	90 81       	ld	r25, Z
    2522:	98 17       	cp	r25, r24
    2524:	09 f4       	brne	.+2      	; 0x2528 <xTaskCheckForTimeOut+0x22>
    2526:	59 c0       	rjmp	.+178    	; 0x25da <xTaskCheckForTimeOut+0xd4>
    2528:	41 81       	ldd	r20, Z+1	; 0x01
    252a:	52 81       	ldd	r21, Z+2	; 0x02
    252c:	63 81       	ldd	r22, Z+3	; 0x03
    252e:	74 81       	ldd	r23, Z+4	; 0x04
    2530:	00 91 24 0c 	lds	r16, 0x0C24
    2534:	10 91 25 0c 	lds	r17, 0x0C25
    2538:	20 91 26 0c 	lds	r18, 0x0C26
    253c:	30 91 27 0c 	lds	r19, 0x0C27
    2540:	04 17       	cp	r16, r20
    2542:	15 07       	cpc	r17, r21
    2544:	26 07       	cpc	r18, r22
    2546:	37 07       	cpc	r19, r23
    2548:	f0 f5       	brcc	.+124    	; 0x25c6 <xTaskCheckForTimeOut+0xc0>
    254a:	8a 01       	movw	r16, r20
    254c:	9b 01       	movw	r18, r22
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    254e:	40 91 24 0c 	lds	r20, 0x0C24
    2552:	50 91 25 0c 	lds	r21, 0x0C25
    2556:	60 91 26 0c 	lds	r22, 0x0C26
    255a:	70 91 27 0c 	lds	r23, 0x0C27
    255e:	cd 90       	ld	r12, X+
    2560:	dd 90       	ld	r13, X+
    2562:	ed 90       	ld	r14, X+
    2564:	fc 90       	ld	r15, X
    2566:	13 97       	sbiw	r26, 0x03	; 3
    2568:	40 1b       	sub	r20, r16
    256a:	51 0b       	sbc	r21, r17
    256c:	62 0b       	sbc	r22, r18
    256e:	73 0b       	sbc	r23, r19
    2570:	4c 15       	cp	r20, r12
    2572:	5d 05       	cpc	r21, r13
    2574:	6e 05       	cpc	r22, r14
    2576:	7f 05       	cpc	r23, r15
    2578:	30 f5       	brcc	.+76     	; 0x25c6 <xTaskCheckForTimeOut+0xc0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    257a:	40 91 24 0c 	lds	r20, 0x0C24
    257e:	50 91 25 0c 	lds	r21, 0x0C25
    2582:	60 91 26 0c 	lds	r22, 0x0C26
    2586:	70 91 27 0c 	lds	r23, 0x0C27
    258a:	c4 1a       	sub	r12, r20
    258c:	d5 0a       	sbc	r13, r21
    258e:	e6 0a       	sbc	r14, r22
    2590:	f7 0a       	sbc	r15, r23
    2592:	c0 0e       	add	r12, r16
    2594:	d1 1e       	adc	r13, r17
    2596:	e2 1e       	adc	r14, r18
    2598:	f3 1e       	adc	r15, r19
    259a:	cd 92       	st	X+, r12
    259c:	dd 92       	st	X+, r13
    259e:	ed 92       	st	X+, r14
    25a0:	fc 92       	st	X, r15
    25a2:	13 97       	sbiw	r26, 0x03	; 3
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    25a4:	80 91 1d 0c 	lds	r24, 0x0C1D
    25a8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    25aa:	80 91 24 0c 	lds	r24, 0x0C24
    25ae:	90 91 25 0c 	lds	r25, 0x0C25
    25b2:	a0 91 26 0c 	lds	r26, 0x0C26
    25b6:	b0 91 27 0c 	lds	r27, 0x0C27
    25ba:	81 83       	std	Z+1, r24	; 0x01
    25bc:	92 83       	std	Z+2, r25	; 0x02
    25be:	a3 83       	std	Z+3, r26	; 0x03
    25c0:	b4 83       	std	Z+4, r27	; 0x04
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
    25c2:	80 e0       	ldi	r24, 0x00	; 0
    25c4:	01 c0       	rjmp	.+2      	; 0x25c8 <xTaskCheckForTimeOut+0xc2>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    25c6:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    25c8:	0f 90       	pop	r0
    25ca:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    25cc:	1f 91       	pop	r17
    25ce:	0f 91       	pop	r16
    25d0:	ff 90       	pop	r15
    25d2:	ef 90       	pop	r14
    25d4:	df 90       	pop	r13
    25d6:	cf 90       	pop	r12
    25d8:	08 95       	ret
    25da:	01 81       	ldd	r16, Z+1	; 0x01
    25dc:	12 81       	ldd	r17, Z+2	; 0x02
    25de:	23 81       	ldd	r18, Z+3	; 0x03
    25e0:	34 81       	ldd	r19, Z+4	; 0x04
    25e2:	b5 cf       	rjmp	.-150    	; 0x254e <xTaskCheckForTimeOut+0x48>

000025e4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    25e4:	81 e0       	ldi	r24, 0x01	; 1
    25e6:	80 93 1e 0c 	sts	0x0C1E, r24
    25ea:	08 95       	ret

000025ec <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    25ec:	00 97       	sbiw	r24, 0x00	; 0
    25ee:	81 f0       	breq	.+32     	; 0x2610 <uxTaskGetStackHighWaterMark+0x24>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    25f0:	dc 01       	movw	r26, r24
    25f2:	5b 96       	adiw	r26, 0x1b	; 27
    25f4:	ed 91       	ld	r30, X+
    25f6:	fc 91       	ld	r31, X
    25f8:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    25fa:	80 81       	ld	r24, Z
    25fc:	81 31       	cpi	r24, 0x11	; 17
    25fe:	69 f4       	brne	.+26     	; 0x261a <uxTaskGetStackHighWaterMark+0x2e>
    2600:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2602:	80 e0       	ldi	r24, 0x00	; 0
    2604:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2606:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2608:	21 91       	ld	r18, Z+
    260a:	21 31       	cpi	r18, 0x11	; 17
    260c:	e1 f3       	breq	.-8      	; 0x2606 <uxTaskGetStackHighWaterMark+0x1a>
    260e:	08 95       	ret
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2610:	80 91 1a 0c 	lds	r24, 0x0C1A
    2614:	90 91 1b 0c 	lds	r25, 0x0C1B
    2618:	eb cf       	rjmp	.-42     	; 0x25f0 <uxTaskGetStackHighWaterMark+0x4>

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    261a:	80 e0       	ldi	r24, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    261c:	08 95       	ret

0000261e <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    261e:	80 91 1a 0c 	lds	r24, 0x0C1A
    2622:	90 91 1b 0c 	lds	r25, 0x0C1B

		return xReturn;
	}
    2626:	08 95       	ret

00002628 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2628:	0f 93       	push	r16
    262a:	1f 93       	push	r17
    262c:	cf 93       	push	r28
    262e:	df 93       	push	r29
    2630:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2632:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2634:	e0 91 1a 0c 	lds	r30, 0x0C1A
    2638:	f0 91 1b 0c 	lds	r31, 0x0C1B
    263c:	92 8d       	ldd	r25, Z+26	; 0x1a
    263e:	89 17       	cp	r24, r25
    2640:	10 f5       	brcc	.+68     	; 0x2686 <vTaskPriorityInherit+0x5e>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2642:	e0 91 1a 0c 	lds	r30, 0x0C1A
    2646:	f0 91 1b 0c 	lds	r31, 0x0C1B
    264a:	92 8d       	ldd	r25, Z+26	; 0x1a
    264c:	44 e0       	ldi	r20, 0x04	; 4
    264e:	50 e0       	ldi	r21, 0x00	; 0
    2650:	60 e0       	ldi	r22, 0x00	; 0
    2652:	70 e0       	ldi	r23, 0x00	; 0
    2654:	49 1b       	sub	r20, r25
    2656:	51 09       	sbc	r21, r1
    2658:	61 09       	sbc	r22, r1
    265a:	71 09       	sbc	r23, r1
    265c:	4e 87       	std	Y+14, r20	; 0x0e
    265e:	5f 87       	std	Y+15, r21	; 0x0f
    2660:	68 8b       	std	Y+16, r22	; 0x10
    2662:	79 8b       	std	Y+17, r23	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2664:	2b e0       	ldi	r18, 0x0B	; 11
    2666:	82 9f       	mul	r24, r18
    2668:	c0 01       	movw	r24, r0
    266a:	11 24       	eor	r1, r1
    266c:	80 5b       	subi	r24, 0xB0	; 176
    266e:	93 4f       	sbci	r25, 0xF3	; 243
    2670:	2c 85       	ldd	r18, Y+12	; 0x0c
    2672:	3d 85       	ldd	r19, Y+13	; 0x0d
    2674:	28 17       	cp	r18, r24
    2676:	39 07       	cpc	r19, r25
    2678:	59 f0       	breq	.+22     	; 0x2690 <vTaskPriorityInherit+0x68>
				prvAddTaskToReadyQueue( pxTCB );
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    267a:	e0 91 1a 0c 	lds	r30, 0x0C1A
    267e:	f0 91 1b 0c 	lds	r31, 0x0C1B
    2682:	82 8d       	ldd	r24, Z+26	; 0x1a
    2684:	8a 8f       	std	Y+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2686:	df 91       	pop	r29
    2688:	cf 91       	pop	r28
    268a:	1f 91       	pop	r17
    268c:	0f 91       	pop	r16
    268e:	08 95       	ret

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2690:	8e 01       	movw	r16, r28
    2692:	0e 5f       	subi	r16, 0xFE	; 254
    2694:	1f 4f       	sbci	r17, 0xFF	; 255
    2696:	c8 01       	movw	r24, r16
    2698:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    269c:	e0 91 1a 0c 	lds	r30, 0x0C1A
    26a0:	f0 91 1b 0c 	lds	r31, 0x0C1B
    26a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    26a6:	8a 8f       	std	Y+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    26a8:	90 91 22 0c 	lds	r25, 0x0C22
    26ac:	98 17       	cp	r25, r24
    26ae:	10 f4       	brcc	.+4      	; 0x26b4 <vTaskPriorityInherit+0x8c>
    26b0:	80 93 22 0c 	sts	0x0C22, r24
    26b4:	2b e0       	ldi	r18, 0x0B	; 11
    26b6:	82 9f       	mul	r24, r18
    26b8:	c0 01       	movw	r24, r0
    26ba:	11 24       	eor	r1, r1
    26bc:	b8 01       	movw	r22, r16
    26be:	80 5b       	subi	r24, 0xB0	; 176
    26c0:	93 4f       	sbci	r25, 0xF3	; 243
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    26c2:	df 91       	pop	r29
    26c4:	cf 91       	pop	r28
    26c6:	1f 91       	pop	r17
    26c8:	0f 91       	pop	r16
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
				prvAddTaskToReadyQueue( pxTCB );
    26ca:	0c 94 43 14 	jmp	0x2886	; 0x2886 <vListInsertEnd>

000026ce <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    26ce:	0f 93       	push	r16
    26d0:	1f 93       	push	r17
    26d2:	cf 93       	push	r28
    26d4:	df 93       	push	r29
    26d6:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    26d8:	00 97       	sbiw	r24, 0x00	; 0
    26da:	59 f1       	breq	.+86     	; 0x2732 <vTaskPriorityDisinherit+0x64>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    26dc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    26de:	8f a1       	ldd	r24, Y+39	; 0x27
    26e0:	98 17       	cp	r25, r24
    26e2:	39 f1       	breq	.+78     	; 0x2732 <vTaskPriorityDisinherit+0x64>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    26e4:	8e 01       	movw	r16, r28
    26e6:	0e 5f       	subi	r16, 0xFE	; 254
    26e8:	1f 4f       	sbci	r17, 0xFF	; 255
    26ea:	c8 01       	movw	r24, r16
    26ec:	0e 94 b9 14 	call	0x2972	; 0x2972 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    26f0:	8f a1       	ldd	r24, Y+39	; 0x27
    26f2:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    26f4:	44 e0       	ldi	r20, 0x04	; 4
    26f6:	50 e0       	ldi	r21, 0x00	; 0
    26f8:	60 e0       	ldi	r22, 0x00	; 0
    26fa:	70 e0       	ldi	r23, 0x00	; 0
    26fc:	48 1b       	sub	r20, r24
    26fe:	51 09       	sbc	r21, r1
    2700:	61 09       	sbc	r22, r1
    2702:	71 09       	sbc	r23, r1
    2704:	4e 87       	std	Y+14, r20	; 0x0e
    2706:	5f 87       	std	Y+15, r21	; 0x0f
    2708:	68 8b       	std	Y+16, r22	; 0x10
    270a:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    270c:	90 91 22 0c 	lds	r25, 0x0C22
    2710:	98 17       	cp	r25, r24
    2712:	10 f4       	brcc	.+4      	; 0x2718 <vTaskPriorityDisinherit+0x4a>
    2714:	80 93 22 0c 	sts	0x0C22, r24
    2718:	2b e0       	ldi	r18, 0x0B	; 11
    271a:	82 9f       	mul	r24, r18
    271c:	c0 01       	movw	r24, r0
    271e:	11 24       	eor	r1, r1
    2720:	b8 01       	movw	r22, r16
    2722:	80 5b       	subi	r24, 0xB0	; 176
    2724:	93 4f       	sbci	r25, 0xF3	; 243
			}
		}
	}
    2726:	df 91       	pop	r29
    2728:	cf 91       	pop	r28
    272a:	1f 91       	pop	r17
    272c:	0f 91       	pop	r16
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
    272e:	0c 94 43 14 	jmp	0x2886	; 0x2886 <vListInsertEnd>
			}
		}
	}
    2732:	df 91       	pop	r29
    2734:	cf 91       	pop	r28
    2736:	1f 91       	pop	r17
    2738:	0f 91       	pop	r16
    273a:	08 95       	ret

0000273c <_ZN7base232C1Ejh>:
 *                     1 only exists on some processors). The default is port 0 
 */

// This section compiles for the AVR microcontroller
#ifdef __AVR
base232::base232 (unsigned int baud_rate, unsigned char port_number)
    273c:	cf 93       	push	r28
    273e:	df 93       	push	r29
    2740:	ec 01       	movw	r28, r24
{
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
    2742:	44 23       	and	r20, r20
    2744:	09 f4       	brne	.+2      	; 0x2748 <_ZN7base232C1Ejh+0xc>
    2746:	41 c0       	rjmp	.+130    	; 0x27ca <_ZN7base232C1Ejh+0x8e>
			mask_TXC = (1 << TXC0);
		}
		else	// The port number isn't 0, so it presumably must be serial port 1
		{
		#if defined UCSR1A
			p_UDR = &UDR1;
    2748:	8c e9       	ldi	r24, 0x9C	; 156
    274a:	90 e0       	ldi	r25, 0x00	; 0
    274c:	99 83       	std	Y+1, r25	; 0x01
    274e:	88 83       	st	Y, r24
			p_USR = &UCSR1A;
    2750:	8b e9       	ldi	r24, 0x9B	; 155
    2752:	90 e0       	ldi	r25, 0x00	; 0
    2754:	9b 83       	std	Y+3, r25	; 0x03
    2756:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR1B;
    2758:	8a e9       	ldi	r24, 0x9A	; 154
    275a:	90 e0       	ldi	r25, 0x00	; 0
    275c:	9d 83       	std	Y+5, r25	; 0x05
    275e:	8c 83       	std	Y+4, r24	; 0x04
			UCSR1B = (1 << RXEN1) | (1 << TXEN1);
    2760:	88 e1       	ldi	r24, 0x18	; 24
    2762:	80 93 9a 00 	sts	0x009A, r24
			UCSR1C = (1 << UCSZ11) | (1 << UCSZ10); // | (1 << USBS1);
    2766:	86 e0       	ldi	r24, 0x06	; 6
    2768:	80 93 9d 00 	sts	0x009D, r24
			UBRR1H = 0x00;
    276c:	10 92 98 00 	sts	0x0098, r1
			UBRR1L = calc_baud_div (baud_rate);
    2770:	9b 01       	movw	r18, r22
    2772:	40 e0       	ldi	r20, 0x00	; 0
    2774:	50 e0       	ldi	r21, 0x00	; 0
    2776:	22 0f       	add	r18, r18
    2778:	33 1f       	adc	r19, r19
    277a:	44 1f       	adc	r20, r20
    277c:	55 1f       	adc	r21, r21
    277e:	22 0f       	add	r18, r18
    2780:	33 1f       	adc	r19, r19
    2782:	44 1f       	adc	r20, r20
    2784:	55 1f       	adc	r21, r21
    2786:	22 0f       	add	r18, r18
    2788:	33 1f       	adc	r19, r19
    278a:	44 1f       	adc	r20, r20
    278c:	55 1f       	adc	r21, r21
    278e:	22 0f       	add	r18, r18
    2790:	33 1f       	adc	r19, r19
    2792:	44 1f       	adc	r20, r20
    2794:	55 1f       	adc	r21, r21
    2796:	60 e0       	ldi	r22, 0x00	; 0
    2798:	74 e2       	ldi	r23, 0x24	; 36
    279a:	84 ef       	ldi	r24, 0xF4	; 244
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	0e 94 aa 16 	call	0x2d54	; 0x2d54 <__udivmodsi4>
    27a2:	20 93 99 00 	sts	0x0099, r18
			#ifdef UART_DOUBLE_SPEED		// If double-speed macro has been defined,
				UCSR1A |= U2X1;				// turn on double-speed operation
    27a6:	80 91 9b 00 	lds	r24, 0x009B
    27aa:	81 60       	ori	r24, 0x01	; 1
    27ac:	80 93 9b 00 	sts	0x009B, r24
			#endif
			mask_UDRE = (1 << UDRE1);
    27b0:	80 e2       	ldi	r24, 0x20	; 32
    27b2:	8e 83       	std	Y+6, r24	; 0x06
			mask_RXC = (1 << RXC1);
    27b4:	80 e8       	ldi	r24, 0x80	; 128
    27b6:	8f 83       	std	Y+7, r24	; 0x07
			mask_TXC = (1 << TXC1);
    27b8:	80 e4       	ldi	r24, 0x40	; 64
    27ba:	88 87       	std	Y+8, r24	; 0x08
			mask_TXC = (1 << TXC);
		#endif // UCSRA
	#endif // UCSR0A

	// Read the data register to ensure that it's empty
	port_number = *p_UDR;
    27bc:	e8 81       	ld	r30, Y
    27be:	f9 81       	ldd	r31, Y+1	; 0x01
    27c0:	80 81       	ld	r24, Z
	port_number = *p_UDR;
    27c2:	80 81       	ld	r24, Z
}
    27c4:	df 91       	pop	r29
    27c6:	cf 91       	pop	r28
    27c8:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
		{
			p_UDR = &UDR0;
    27ca:	8c e2       	ldi	r24, 0x2C	; 44
    27cc:	90 e0       	ldi	r25, 0x00	; 0
    27ce:	99 83       	std	Y+1, r25	; 0x01
    27d0:	88 83       	st	Y, r24
			p_USR = &UCSR0A;
    27d2:	8b e2       	ldi	r24, 0x2B	; 43
    27d4:	90 e0       	ldi	r25, 0x00	; 0
    27d6:	9b 83       	std	Y+3, r25	; 0x03
    27d8:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR0B;
    27da:	8a e2       	ldi	r24, 0x2A	; 42
    27dc:	90 e0       	ldi	r25, 0x00	; 0
    27de:	9d 83       	std	Y+5, r25	; 0x05
    27e0:	8c 83       	std	Y+4, r24	; 0x04
			UCSR0B = (1 << RXEN0) | (1 << TXEN0);
    27e2:	88 e1       	ldi	r24, 0x18	; 24
    27e4:	8a b9       	out	0x0a, r24	; 10
			UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // | (1 << USBS0);
    27e6:	86 e0       	ldi	r24, 0x06	; 6
    27e8:	80 93 95 00 	sts	0x0095, r24
			UBRR0H = 0x00;
    27ec:	10 92 90 00 	sts	0x0090, r1
			UBRR0L = calc_baud_div (baud_rate);
    27f0:	9b 01       	movw	r18, r22
    27f2:	40 e0       	ldi	r20, 0x00	; 0
    27f4:	50 e0       	ldi	r21, 0x00	; 0
    27f6:	22 0f       	add	r18, r18
    27f8:	33 1f       	adc	r19, r19
    27fa:	44 1f       	adc	r20, r20
    27fc:	55 1f       	adc	r21, r21
    27fe:	22 0f       	add	r18, r18
    2800:	33 1f       	adc	r19, r19
    2802:	44 1f       	adc	r20, r20
    2804:	55 1f       	adc	r21, r21
    2806:	22 0f       	add	r18, r18
    2808:	33 1f       	adc	r19, r19
    280a:	44 1f       	adc	r20, r20
    280c:	55 1f       	adc	r21, r21
    280e:	22 0f       	add	r18, r18
    2810:	33 1f       	adc	r19, r19
    2812:	44 1f       	adc	r20, r20
    2814:	55 1f       	adc	r21, r21
    2816:	60 e0       	ldi	r22, 0x00	; 0
    2818:	74 e2       	ldi	r23, 0x24	; 36
    281a:	84 ef       	ldi	r24, 0xF4	; 244
    281c:	90 e0       	ldi	r25, 0x00	; 0
    281e:	0e 94 aa 16 	call	0x2d54	; 0x2d54 <__udivmodsi4>
    2822:	29 b9       	out	0x09, r18	; 9
			#ifdef UART_DOUBLE_SPEED					// Activate double speed mode
				UCSR0A |= U2X0;							// if required
    2824:	58 9a       	sbi	0x0b, 0	; 11
    2826:	c4 cf       	rjmp	.-120    	; 0x27b0 <_ZN7base232C1Ejh+0x74>

00002828 <_ZN7base23213ready_to_sendEv>:

bool base232::ready_to_send (void)
{
#ifdef __AVR
	// If transmitter buffer is full, we're not ready to send
	if (*p_USR & mask_UDRE)
    2828:	dc 01       	movw	r26, r24
    282a:	12 96       	adiw	r26, 0x02	; 2
    282c:	ed 91       	ld	r30, X+
    282e:	fc 91       	ld	r31, X
    2830:	13 97       	sbiw	r26, 0x03	; 3
    2832:	20 81       	ld	r18, Z
    2834:	16 96       	adiw	r26, 0x06	; 6
    2836:	8c 91       	ld	r24, X
    2838:	28 23       	and	r18, r24
    283a:	81 e0       	ldi	r24, 0x01	; 1
    283c:	09 f4       	brne	.+2      	; 0x2840 <_ZN7base23213ready_to_sendEv+0x18>
    283e:	80 e0       	ldi	r24, 0x00	; 0
	return (false);
#else
	// The non-AVR (that is, PC) serial port buffer should always be ready
	return (true);
#endif
}
    2840:	08 95       	ret

00002842 <_ZN7base23210is_sendingEv>:
 */

bool base232::is_sending (void)
{
#ifdef __AVR
	if (*p_USR & mask_TXC)
    2842:	dc 01       	movw	r26, r24
    2844:	12 96       	adiw	r26, 0x02	; 2
    2846:	ed 91       	ld	r30, X+
    2848:	fc 91       	ld	r31, X
    284a:	13 97       	sbiw	r26, 0x03	; 3
    284c:	20 81       	ld	r18, Z
    284e:	18 96       	adiw	r26, 0x08	; 8
    2850:	8c 91       	ld	r24, X
    2852:	28 23       	and	r18, r24
    2854:	81 e0       	ldi	r24, 0x01	; 1
    2856:	09 f0       	breq	.+2      	; 0x285a <_ZN7base23210is_sendingEv+0x18>
    2858:	80 e0       	ldi	r24, 0x00	; 0
		return (true);
#else
	// We don't really care if a PC is sending, as it has a buffer anyway
	return (false);
#endif
}
    285a:	08 95       	ret

0000285c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    285c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    285e:	03 96       	adiw	r24, 0x03	; 3
    2860:	92 83       	std	Z+2, r25	; 0x02
    2862:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2864:	4f ef       	ldi	r20, 0xFF	; 255
    2866:	5f ef       	ldi	r21, 0xFF	; 255
    2868:	ba 01       	movw	r22, r20
    286a:	43 83       	std	Z+3, r20	; 0x03
    286c:	54 83       	std	Z+4, r21	; 0x04
    286e:	65 83       	std	Z+5, r22	; 0x05
    2870:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2872:	90 87       	std	Z+8, r25	; 0x08
    2874:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2876:	92 87       	std	Z+10, r25	; 0x0a
    2878:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    287a:	10 82       	st	Z, r1
    287c:	08 95       	ret

0000287e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    287e:	fc 01       	movw	r30, r24
    2880:	13 86       	std	Z+11, r1	; 0x0b
    2882:	12 86       	std	Z+10, r1	; 0x0a
    2884:	08 95       	ret

00002886 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2886:	cf 93       	push	r28
    2888:	df 93       	push	r29
    288a:	dc 01       	movw	r26, r24
    288c:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    288e:	11 96       	adiw	r26, 0x01	; 1
    2890:	2d 91       	ld	r18, X+
    2892:	3c 91       	ld	r19, X
    2894:	12 97       	sbiw	r26, 0x02	; 2

	pxNewListItem->pxNext = pxIndex->pxNext;
    2896:	e9 01       	movw	r28, r18
    2898:	8c 81       	ldd	r24, Y+4	; 0x04
    289a:	9d 81       	ldd	r25, Y+5	; 0x05
    289c:	95 83       	std	Z+5, r25	; 0x05
    289e:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxList->pxIndex;
    28a0:	37 83       	std	Z+7, r19	; 0x07
    28a2:	26 83       	std	Z+6, r18	; 0x06
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    28a4:	8c 81       	ldd	r24, Y+4	; 0x04
    28a6:	9d 81       	ldd	r25, Y+5	; 0x05
    28a8:	ec 01       	movw	r28, r24
    28aa:	7f 83       	std	Y+7, r23	; 0x07
    28ac:	6e 83       	std	Y+6, r22	; 0x06
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    28ae:	e9 01       	movw	r28, r18
    28b0:	7d 83       	std	Y+5, r23	; 0x05
    28b2:	6c 83       	std	Y+4, r22	; 0x04
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    28b4:	12 96       	adiw	r26, 0x02	; 2
    28b6:	7c 93       	st	X, r23
    28b8:	6e 93       	st	-X, r22
    28ba:	11 97       	sbiw	r26, 0x01	; 1

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    28bc:	b3 87       	std	Z+11, r27	; 0x0b
    28be:	a2 87       	std	Z+10, r26	; 0x0a

	( pxList->uxNumberOfItems )++;
    28c0:	8c 91       	ld	r24, X
    28c2:	8f 5f       	subi	r24, 0xFF	; 255
    28c4:	8c 93       	st	X, r24
}
    28c6:	df 91       	pop	r29
    28c8:	cf 91       	pop	r28
    28ca:	08 95       	ret

000028cc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    28cc:	ef 92       	push	r14
    28ce:	ff 92       	push	r15
    28d0:	0f 93       	push	r16
    28d2:	1f 93       	push	r17
    28d4:	cf 93       	push	r28
    28d6:	df 93       	push	r29
    28d8:	7c 01       	movw	r14, r24
    28da:	db 01       	movw	r26, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    28dc:	0d 91       	ld	r16, X+
    28de:	1d 91       	ld	r17, X+
    28e0:	2d 91       	ld	r18, X+
    28e2:	3c 91       	ld	r19, X
    28e4:	13 97       	sbiw	r26, 0x03	; 3
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    28e6:	0f 3f       	cpi	r16, 0xFF	; 255
    28e8:	8f ef       	ldi	r24, 0xFF	; 255
    28ea:	18 07       	cpc	r17, r24
    28ec:	28 07       	cpc	r18, r24
    28ee:	38 07       	cpc	r19, r24
    28f0:	e1 f1       	breq	.+120    	; 0x296a <vListInsert+0x9e>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    28f2:	f7 01       	movw	r30, r14
    28f4:	33 96       	adiw	r30, 0x03	; 3
    28f6:	e7 01       	movw	r28, r14
    28f8:	8f 81       	ldd	r24, Y+7	; 0x07
    28fa:	98 85       	ldd	r25, Y+8	; 0x08
    28fc:	ec 01       	movw	r28, r24
    28fe:	48 81       	ld	r20, Y
    2900:	59 81       	ldd	r21, Y+1	; 0x01
    2902:	6a 81       	ldd	r22, Y+2	; 0x02
    2904:	7b 81       	ldd	r23, Y+3	; 0x03
    2906:	04 17       	cp	r16, r20
    2908:	15 07       	cpc	r17, r21
    290a:	26 07       	cpc	r18, r22
    290c:	37 07       	cpc	r19, r23
    290e:	78 f0       	brcs	.+30     	; 0x292e <vListInsert+0x62>
    2910:	04 80       	ldd	r0, Z+4	; 0x04
    2912:	f5 81       	ldd	r31, Z+5	; 0x05
    2914:	e0 2d       	mov	r30, r0
    2916:	84 81       	ldd	r24, Z+4	; 0x04
    2918:	95 81       	ldd	r25, Z+5	; 0x05
    291a:	ec 01       	movw	r28, r24
    291c:	48 81       	ld	r20, Y
    291e:	59 81       	ldd	r21, Y+1	; 0x01
    2920:	6a 81       	ldd	r22, Y+2	; 0x02
    2922:	7b 81       	ldd	r23, Y+3	; 0x03
    2924:	04 17       	cp	r16, r20
    2926:	15 07       	cpc	r17, r21
    2928:	26 07       	cpc	r18, r22
    292a:	37 07       	cpc	r19, r23
    292c:	88 f7       	brcc	.-30     	; 0x2910 <vListInsert+0x44>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    292e:	84 81       	ldd	r24, Z+4	; 0x04
    2930:	95 81       	ldd	r25, Z+5	; 0x05
    2932:	15 96       	adiw	r26, 0x05	; 5
    2934:	9c 93       	st	X, r25
    2936:	8e 93       	st	-X, r24
    2938:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    293a:	ec 01       	movw	r28, r24
    293c:	bf 83       	std	Y+7, r27	; 0x07
    293e:	ae 83       	std	Y+6, r26	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
    2940:	17 96       	adiw	r26, 0x07	; 7
    2942:	fc 93       	st	X, r31
    2944:	ee 93       	st	-X, r30
    2946:	16 97       	sbiw	r26, 0x06	; 6
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2948:	b5 83       	std	Z+5, r27	; 0x05
    294a:	a4 83       	std	Z+4, r26	; 0x04

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    294c:	1b 96       	adiw	r26, 0x0b	; 11
    294e:	fc 92       	st	X, r15
    2950:	ee 92       	st	-X, r14
    2952:	1a 97       	sbiw	r26, 0x0a	; 10

	( pxList->uxNumberOfItems )++;
    2954:	f7 01       	movw	r30, r14
    2956:	80 81       	ld	r24, Z
    2958:	8f 5f       	subi	r24, 0xFF	; 255
    295a:	80 83       	st	Z, r24
}
    295c:	df 91       	pop	r29
    295e:	cf 91       	pop	r28
    2960:	1f 91       	pop	r17
    2962:	0f 91       	pop	r16
    2964:	ff 90       	pop	r15
    2966:	ef 90       	pop	r14
    2968:	08 95       	ret
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    296a:	e7 01       	movw	r28, r14
    296c:	e9 85       	ldd	r30, Y+9	; 0x09
    296e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2970:	de cf       	rjmp	.-68     	; 0x292e <vListInsert+0x62>

00002972 <vListRemove>:
    2972:	cf 93       	push	r28
    2974:	df 93       	push	r29
    2976:	fc 01       	movw	r30, r24
    2978:	a4 81       	ldd	r26, Z+4	; 0x04
    297a:	b5 81       	ldd	r27, Z+5	; 0x05
    297c:	86 81       	ldd	r24, Z+6	; 0x06
    297e:	97 81       	ldd	r25, Z+7	; 0x07
    2980:	17 96       	adiw	r26, 0x07	; 7
    2982:	9c 93       	st	X, r25
    2984:	8e 93       	st	-X, r24
    2986:	16 97       	sbiw	r26, 0x06	; 6
    2988:	c6 81       	ldd	r28, Z+6	; 0x06
    298a:	d7 81       	ldd	r29, Z+7	; 0x07
    298c:	bd 83       	std	Y+5, r27	; 0x05
    298e:	ac 83       	std	Y+4, r26	; 0x04
    2990:	a2 85       	ldd	r26, Z+10	; 0x0a
    2992:	b3 85       	ldd	r27, Z+11	; 0x0b
    2994:	11 96       	adiw	r26, 0x01	; 1
    2996:	8d 91       	ld	r24, X+
    2998:	9c 91       	ld	r25, X
    299a:	12 97       	sbiw	r26, 0x02	; 2
    299c:	8e 17       	cp	r24, r30
    299e:	9f 07       	cpc	r25, r31
    29a0:	41 f0       	breq	.+16     	; 0x29b2 <vListRemove+0x40>
    29a2:	13 86       	std	Z+11, r1	; 0x0b
    29a4:	12 86       	std	Z+10, r1	; 0x0a
    29a6:	8c 91       	ld	r24, X
    29a8:	81 50       	subi	r24, 0x01	; 1
    29aa:	8c 93       	st	X, r24
    29ac:	df 91       	pop	r29
    29ae:	cf 91       	pop	r28
    29b0:	08 95       	ret
    29b2:	12 96       	adiw	r26, 0x02	; 2
    29b4:	dc 93       	st	X, r29
    29b6:	ce 93       	st	-X, r28
    29b8:	11 97       	sbiw	r26, 0x01	; 1
    29ba:	13 86       	std	Z+11, r1	; 0x0b
    29bc:	12 86       	std	Z+10, r1	; 0x0a
    29be:	8c 91       	ld	r24, X
    29c0:	81 50       	subi	r24, 0x01	; 1
    29c2:	8c 93       	st	X, r24
    29c4:	df 91       	pop	r29
    29c6:	cf 91       	pop	r28
    29c8:	08 95       	ret

000029ca <_ZN14frt_base_queueImE7butt_inERKm>:
    29ca:	80 e0       	ldi	r24, 0x00	; 0
    29cc:	08 95       	ret

000029ce <_ZN14frt_base_queueImE11ISR_butt_inERKm>:
		 */
		virtual bool ISR_butt_in (const data_type& item)
		{
			(void) item;                    // This just shuts up a compiler warning
			return (false);
		}
    29ce:	80 e0       	ldi	r24, 0x00	; 0
    29d0:	08 95       	ret

000029d2 <_ZN9frt_queueImE3putERKm>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    29d2:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    29d4:	fc 01       	movw	r30, r24
    29d6:	26 81       	ldd	r18, Z+6	; 0x06
    29d8:	37 81       	ldd	r19, Z+7	; 0x07
    29da:	40 85       	ldd	r20, Z+8	; 0x08
    29dc:	51 85       	ldd	r21, Z+9	; 0x09
    29de:	00 e0       	ldi	r16, 0x00	; 0
    29e0:	84 81       	ldd	r24, Z+4	; 0x04
    29e2:	95 81       	ldd	r25, Z+5	; 0x05
    29e4:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xQueueGenericSend>
    29e8:	91 e0       	ldi	r25, 0x01	; 1
    29ea:	81 11       	cpse	r24, r1
    29ec:	01 c0       	rjmp	.+2      	; 0x29f0 <_ZN9frt_queueImE3putERKm+0x1e>
    29ee:	90 e0       	ldi	r25, 0x00	; 0
		}
    29f0:	89 2f       	mov	r24, r25
    29f2:	0f 91       	pop	r16
    29f4:	08 95       	ret

000029f6 <_ZN9frt_queueImE7butt_inERKm>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    29f6:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    29f8:	fc 01       	movw	r30, r24
    29fa:	26 81       	ldd	r18, Z+6	; 0x06
    29fc:	37 81       	ldd	r19, Z+7	; 0x07
    29fe:	40 85       	ldd	r20, Z+8	; 0x08
    2a00:	51 85       	ldd	r21, Z+9	; 0x09
    2a02:	01 e0       	ldi	r16, 0x01	; 1
    2a04:	84 81       	ldd	r24, Z+4	; 0x04
    2a06:	95 81       	ldd	r25, Z+5	; 0x05
    2a08:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xQueueGenericSend>
    2a0c:	91 e0       	ldi	r25, 0x01	; 1
    2a0e:	81 11       	cpse	r24, r1
    2a10:	01 c0       	rjmp	.+2      	; 0x2a14 <_ZN9frt_queueImE7butt_inERKm+0x1e>
    2a12:	90 e0       	ldi	r25, 0x00	; 0
		}
    2a14:	89 2f       	mov	r24, r25
    2a16:	0f 91       	pop	r16
    2a18:	08 95       	ret

00002a1a <_ZN9frt_queueImE7ISR_putERKm>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    2a1a:	cf 93       	push	r28
    2a1c:	df 93       	push	r29
    2a1e:	1f 92       	push	r1
    2a20:	cd b7       	in	r28, 0x3d	; 61
    2a22:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    2a24:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    2a26:	20 e0       	ldi	r18, 0x00	; 0
    2a28:	ae 01       	movw	r20, r28
    2a2a:	4f 5f       	subi	r20, 0xFF	; 255
    2a2c:	5f 4f       	sbci	r21, 0xFF	; 255
    2a2e:	fc 01       	movw	r30, r24
    2a30:	84 81       	ldd	r24, Z+4	; 0x04
    2a32:	95 81       	ldd	r25, Z+5	; 0x05
    2a34:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <xQueueGenericSendFromISR>
    2a38:	91 e0       	ldi	r25, 0x01	; 1
    2a3a:	81 11       	cpse	r24, r1
    2a3c:	01 c0       	rjmp	.+2      	; 0x2a40 <_ZN9frt_queueImE7ISR_putERKm+0x26>
    2a3e:	90 e0       	ldi	r25, 0x00	; 0
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
}
    2a40:	89 2f       	mov	r24, r25
    2a42:	0f 90       	pop	r0
    2a44:	df 91       	pop	r29
    2a46:	cf 91       	pop	r28
    2a48:	08 95       	ret

00002a4a <_ZN9frt_queueImE11ISR_butt_inERKm>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    2a4a:	cf 93       	push	r28
    2a4c:	df 93       	push	r29
    2a4e:	1f 92       	push	r1
    2a50:	cd b7       	in	r28, 0x3d	; 61
    2a52:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    2a54:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    2a56:	21 e0       	ldi	r18, 0x01	; 1
    2a58:	ae 01       	movw	r20, r28
    2a5a:	4f 5f       	subi	r20, 0xFF	; 255
    2a5c:	5f 4f       	sbci	r21, 0xFF	; 255
    2a5e:	fc 01       	movw	r30, r24
    2a60:	84 81       	ldd	r24, Z+4	; 0x04
    2a62:	95 81       	ldd	r25, Z+5	; 0x05
    2a64:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <xQueueGenericSendFromISR>
    2a68:	91 e0       	ldi	r25, 0x01	; 1
    2a6a:	81 11       	cpse	r24, r1
    2a6c:	01 c0       	rjmp	.+2      	; 0x2a70 <_ZN9frt_queueImE11ISR_butt_inERKm+0x26>
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
}
    2a70:	89 2f       	mov	r24, r25
    2a72:	0f 90       	pop	r0
    2a74:	df 91       	pop	r29
    2a76:	cf 91       	pop	r28
    2a78:	08 95       	ret

00002a7a <_ZN9frt_queueImE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    2a7a:	0f 93       	push	r16
    2a7c:	cf 93       	push	r28
    2a7e:	df 93       	push	r29
    2a80:	00 d0       	rcall	.+0      	; 0x2a82 <_ZN9frt_queueImE3getEv+0x8>
    2a82:	00 d0       	rcall	.+0      	; 0x2a84 <_ZN9frt_queueImE3getEv+0xa>
    2a84:	cd b7       	in	r28, 0x3d	; 61
    2a86:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    2a88:	00 e0       	ldi	r16, 0x00	; 0
    2a8a:	2f ef       	ldi	r18, 0xFF	; 255
    2a8c:	3f ef       	ldi	r19, 0xFF	; 255
    2a8e:	a9 01       	movw	r20, r18
    2a90:	be 01       	movw	r22, r28
    2a92:	6f 5f       	subi	r22, 0xFF	; 255
    2a94:	7f 4f       	sbci	r23, 0xFF	; 255
    2a96:	fc 01       	movw	r30, r24
    2a98:	84 81       	ldd	r24, Z+4	; 0x04
    2a9a:	95 81       	ldd	r25, Z+5	; 0x05
    2a9c:	0e 94 18 0c 	call	0x1830	; 0x1830 <xQueueGenericReceive>
	return (recv_item);
    2aa0:	69 81       	ldd	r22, Y+1	; 0x01
    2aa2:	7a 81       	ldd	r23, Y+2	; 0x02
    2aa4:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa6:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2aa8:	0f 90       	pop	r0
    2aaa:	0f 90       	pop	r0
    2aac:	0f 90       	pop	r0
    2aae:	0f 90       	pop	r0
    2ab0:	df 91       	pop	r29
    2ab2:	cf 91       	pop	r28
    2ab4:	0f 91       	pop	r16
    2ab6:	08 95       	ret

00002ab8 <_ZN9frt_queueImE3getEPm>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    2ab8:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    2aba:	00 e0       	ldi	r16, 0x00	; 0
    2abc:	2f ef       	ldi	r18, 0xFF	; 255
    2abe:	3f ef       	ldi	r19, 0xFF	; 255
    2ac0:	a9 01       	movw	r20, r18
    2ac2:	fc 01       	movw	r30, r24
    2ac4:	84 81       	ldd	r24, Z+4	; 0x04
    2ac6:	95 81       	ldd	r25, Z+5	; 0x05
    2ac8:	0e 94 18 0c 	call	0x1830	; 0x1830 <xQueueGenericReceive>
}
    2acc:	0f 91       	pop	r16
    2ace:	08 95       	ret

00002ad0 <_ZN9frt_queueImE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    2ad0:	0f 93       	push	r16
    2ad2:	cf 93       	push	r28
    2ad4:	df 93       	push	r29
    2ad6:	00 d0       	rcall	.+0      	; 0x2ad8 <_ZN9frt_queueImE10get_a_copyEv+0x8>
    2ad8:	00 d0       	rcall	.+0      	; 0x2ada <_ZN9frt_queueImE10get_a_copyEv+0xa>
    2ada:	cd b7       	in	r28, 0x3d	; 61
    2adc:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    2ade:	01 e0       	ldi	r16, 0x01	; 1
    2ae0:	2f ef       	ldi	r18, 0xFF	; 255
    2ae2:	3f ef       	ldi	r19, 0xFF	; 255
    2ae4:	a9 01       	movw	r20, r18
    2ae6:	be 01       	movw	r22, r28
    2ae8:	6f 5f       	subi	r22, 0xFF	; 255
    2aea:	7f 4f       	sbci	r23, 0xFF	; 255
    2aec:	fc 01       	movw	r30, r24
    2aee:	84 81       	ldd	r24, Z+4	; 0x04
    2af0:	95 81       	ldd	r25, Z+5	; 0x05
    2af2:	0e 94 18 0c 	call	0x1830	; 0x1830 <xQueueGenericReceive>
	return (recv_item);
    2af6:	69 81       	ldd	r22, Y+1	; 0x01
    2af8:	7a 81       	ldd	r23, Y+2	; 0x02
    2afa:	8b 81       	ldd	r24, Y+3	; 0x03
    2afc:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2afe:	0f 90       	pop	r0
    2b00:	0f 90       	pop	r0
    2b02:	0f 90       	pop	r0
    2b04:	0f 90       	pop	r0
    2b06:	df 91       	pop	r29
    2b08:	cf 91       	pop	r28
    2b0a:	0f 91       	pop	r16
    2b0c:	08 95       	ret

00002b0e <_ZN9frt_queueImE10get_a_copyERm>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    2b0e:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    2b10:	01 e0       	ldi	r16, 0x01	; 1
    2b12:	2f ef       	ldi	r18, 0xFF	; 255
    2b14:	3f ef       	ldi	r19, 0xFF	; 255
    2b16:	a9 01       	movw	r20, r18
    2b18:	fc 01       	movw	r30, r24
    2b1a:	84 81       	ldd	r24, Z+4	; 0x04
    2b1c:	95 81       	ldd	r25, Z+5	; 0x05
    2b1e:	0e 94 18 0c 	call	0x1830	; 0x1830 <xQueueGenericReceive>
}
    2b22:	0f 91       	pop	r16
    2b24:	08 95       	ret

00002b26 <_ZN9frt_queueImE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    2b26:	cf 93       	push	r28
    2b28:	df 93       	push	r29
    2b2a:	00 d0       	rcall	.+0      	; 0x2b2c <_ZN9frt_queueImE7ISR_getEv+0x6>
    2b2c:	00 d0       	rcall	.+0      	; 0x2b2e <_ZN9frt_queueImE7ISR_getEv+0x8>
    2b2e:	1f 92       	push	r1
    2b30:	cd b7       	in	r28, 0x3d	; 61
    2b32:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    2b34:	ae 01       	movw	r20, r28
    2b36:	4b 5f       	subi	r20, 0xFB	; 251
    2b38:	5f 4f       	sbci	r21, 0xFF	; 255
    2b3a:	be 01       	movw	r22, r28
    2b3c:	6f 5f       	subi	r22, 0xFF	; 255
    2b3e:	7f 4f       	sbci	r23, 0xFF	; 255
    2b40:	fc 01       	movw	r30, r24
    2b42:	84 81       	ldd	r24, Z+4	; 0x04
    2b44:	95 81       	ldd	r25, Z+5	; 0x05
    2b46:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <xQueueReceiveFromISR>
	return (recv_item);
    2b4a:	69 81       	ldd	r22, Y+1	; 0x01
    2b4c:	7a 81       	ldd	r23, Y+2	; 0x02
    2b4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b50:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2b52:	0f 90       	pop	r0
    2b54:	0f 90       	pop	r0
    2b56:	0f 90       	pop	r0
    2b58:	0f 90       	pop	r0
    2b5a:	0f 90       	pop	r0
    2b5c:	df 91       	pop	r29
    2b5e:	cf 91       	pop	r28
    2b60:	08 95       	ret

00002b62 <_ZN9frt_queueImE7ISR_getEPm>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    2b62:	cf 93       	push	r28
    2b64:	df 93       	push	r29
    2b66:	1f 92       	push	r1
    2b68:	cd b7       	in	r28, 0x3d	; 61
    2b6a:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    2b6c:	ae 01       	movw	r20, r28
    2b6e:	4f 5f       	subi	r20, 0xFF	; 255
    2b70:	5f 4f       	sbci	r21, 0xFF	; 255
    2b72:	fc 01       	movw	r30, r24
    2b74:	84 81       	ldd	r24, Z+4	; 0x04
    2b76:	95 81       	ldd	r25, Z+5	; 0x05
    2b78:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <xQueueReceiveFromISR>
}
    2b7c:	0f 90       	pop	r0
    2b7e:	df 91       	pop	r29
    2b80:	cf 91       	pop	r28
    2b82:	08 95       	ret

00002b84 <_ZN9frt_queueImE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    2b84:	fc 01       	movw	r30, r24
    2b86:	84 81       	ldd	r24, Z+4	; 0x04
    2b88:	95 81       	ldd	r25, Z+5	; 0x05
    2b8a:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <uxQueueMessagesWaiting>
    2b8e:	91 e0       	ldi	r25, 0x01	; 1
    2b90:	81 11       	cpse	r24, r1
    2b92:	90 e0       	ldi	r25, 0x00	; 0
		}
    2b94:	89 2f       	mov	r24, r25
    2b96:	08 95       	ret

00002b98 <_ZN9frt_queueImE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    2b98:	fc 01       	movw	r30, r24
    2b9a:	84 81       	ldd	r24, Z+4	; 0x04
    2b9c:	95 81       	ldd	r25, Z+5	; 0x05
    2b9e:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <uxQueueMessagesWaiting>
    2ba2:	91 e0       	ldi	r25, 0x01	; 1
    2ba4:	81 11       	cpse	r24, r1
    2ba6:	01 c0       	rjmp	.+2      	; 0x2baa <_ZN9frt_queueImE9not_emptyEv+0x12>
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
		}
    2baa:	89 2f       	mov	r24, r25
    2bac:	08 95       	ret

00002bae <_ZN9frt_queueImE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    2bae:	fc 01       	movw	r30, r24
    2bb0:	84 81       	ldd	r24, Z+4	; 0x04
    2bb2:	95 81       	ldd	r25, Z+5	; 0x05
    2bb4:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <uxQueueMessagesWaiting>
		}
    2bb8:	90 e0       	ldi	r25, 0x00	; 0
    2bba:	08 95       	ret

00002bbc <_ZN9frt_queueImE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    2bbc:	fc 01       	movw	r30, r24
    2bbe:	84 81       	ldd	r24, Z+4	; 0x04
    2bc0:	95 81       	ldd	r25, Z+5	; 0x05
    2bc2:	0e 94 37 0d 	call	0x1a6e	; 0x1a6e <uxQueueMessagesWaitingFromISR>
    2bc6:	91 e0       	ldi	r25, 0x01	; 1
    2bc8:	81 11       	cpse	r24, r1
    2bca:	90 e0       	ldi	r25, 0x00	; 0
		}
    2bcc:	89 2f       	mov	r24, r25
    2bce:	08 95       	ret

00002bd0 <_ZN9frt_queueImE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    2bd0:	fc 01       	movw	r30, r24
    2bd2:	84 81       	ldd	r24, Z+4	; 0x04
    2bd4:	95 81       	ldd	r25, Z+5	; 0x05
    2bd6:	0e 94 37 0d 	call	0x1a6e	; 0x1a6e <uxQueueMessagesWaitingFromISR>
    2bda:	91 e0       	ldi	r25, 0x01	; 1
    2bdc:	81 11       	cpse	r24, r1
    2bde:	01 c0       	rjmp	.+2      	; 0x2be2 <_ZN9frt_queueImE13ISR_not_emptyEv+0x12>
    2be0:	90 e0       	ldi	r25, 0x00	; 0
		}
    2be2:	89 2f       	mov	r24, r25
    2be4:	08 95       	ret

00002be6 <_ZN9frt_queueImE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    2be6:	fc 01       	movw	r30, r24
    2be8:	84 81       	ldd	r24, Z+4	; 0x04
    2bea:	95 81       	ldd	r25, Z+5	; 0x05
    2bec:	0e 94 37 0d 	call	0x1a6e	; 0x1a6e <uxQueueMessagesWaitingFromISR>
		}
    2bf0:	90 e0       	ldi	r25, 0x00	; 0
    2bf2:	08 95       	ret

00002bf4 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    2bf4:	0f 93       	push	r16
    2bf6:	1f 93       	push	r17
    2bf8:	cf 93       	push	r28
    2bfa:	df 93       	push	r29
    2bfc:	cd b7       	in	r28, 0x3d	; 61
    2bfe:	de b7       	in	r29, 0x3e	; 62
    2c00:	62 97       	sbiw	r28, 0x12	; 18
    2c02:	0f b6       	in	r0, 0x3f	; 63
    2c04:	f8 94       	cli
    2c06:	de bf       	out	0x3e, r29	; 62
    2c08:	0f be       	out	0x3f, r0	; 63
    2c0a:	cd bf       	out	0x3d, r28	; 61
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on
	//MCUSR = 0;
	wdt_disable ();
    2c0c:	88 e1       	ldi	r24, 0x18	; 24
    2c0e:	0f b6       	in	r0, 0x3f	; 63
    2c10:	f8 94       	cli
    2c12:	81 bd       	out	0x21, r24	; 33
    2c14:	11 bc       	out	0x21, r1	; 33
    2c16:	0f be       	out	0x3f, r0	; 63
	
	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_port (9600, 1);
    2c18:	41 e0       	ldi	r20, 0x01	; 1
    2c1a:	60 e8       	ldi	r22, 0x80	; 128
    2c1c:	75 e2       	ldi	r23, 0x25	; 37
    2c1e:	ce 01       	movw	r24, r28
    2c20:	01 96       	adiw	r24, 0x01	; 1
    2c22:	0e 94 1a 07 	call	0xe34	; 0xe34 <_ZN5rs232C1Ejh>

	// task that controls motors
	new motor_task ("MotorTask", task_priority (1), 280, &ser_port);
    2c26:	82 e1       	ldi	r24, 0x12	; 18
    2c28:	90 e0       	ldi	r25, 0x00	; 0
    2c2a:	0e 94 cc 04 	call	0x998	; 0x998 <_Znwj>
    2c2e:	8e 01       	movw	r16, r28
    2c30:	0f 5f       	subi	r16, 0xFF	; 255
    2c32:	1f 4f       	sbci	r17, 0xFF	; 255
    2c34:	28 e1       	ldi	r18, 0x18	; 24
    2c36:	31 e0       	ldi	r19, 0x01	; 1
    2c38:	41 e0       	ldi	r20, 0x01	; 1
    2c3a:	65 e0       	ldi	r22, 0x05	; 5
    2c3c:	71 e0       	ldi	r23, 0x01	; 1
    2c3e:	0e 94 30 01 	call	0x260	; 0x260 <_ZN10motor_taskC1EPKchjP8emstream>


	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    2c42:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <vTaskStartScheduler>
}
    2c46:	80 e0       	ldi	r24, 0x00	; 0
    2c48:	90 e0       	ldi	r25, 0x00	; 0
    2c4a:	62 96       	adiw	r28, 0x12	; 18
    2c4c:	0f b6       	in	r0, 0x3f	; 63
    2c4e:	f8 94       	cli
    2c50:	de bf       	out	0x3e, r29	; 62
    2c52:	0f be       	out	0x3f, r0	; 63
    2c54:	cd bf       	out	0x3d, r28	; 61
    2c56:	df 91       	pop	r29
    2c58:	cf 91       	pop	r28
    2c5a:	1f 91       	pop	r17
    2c5c:	0f 91       	pop	r16
    2c5e:	08 95       	ret

00002c60 <_GLOBAL__sub_I_print_ser_queue>:
    2c60:	0f 93       	push	r16
    2c62:	1f 93       	push	r17
 *  into the queue using the "<<" operator and they'll come out the other end as a 
 *  stream of characters. It's used by tasks that send things to the user interface 
 *  task to be printed. 
 */

frt_text_queue print_ser_queue (32, NULL, 10);
    2c64:	0a e0       	ldi	r16, 0x0A	; 10
    2c66:	10 e0       	ldi	r17, 0x00	; 0
    2c68:	20 e0       	ldi	r18, 0x00	; 0
    2c6a:	30 e0       	ldi	r19, 0x00	; 0
    2c6c:	40 e0       	ldi	r20, 0x00	; 0
    2c6e:	50 e0       	ldi	r21, 0x00	; 0
    2c70:	60 e2       	ldi	r22, 0x20	; 32
    2c72:	70 e0       	ldi	r23, 0x00	; 0
    2c74:	82 e8       	ldi	r24, 0x82	; 130
    2c76:	91 e0       	ldi	r25, 0x01	; 1
    2c78:	0e 94 9d 04 	call	0x93a	; 0x93a <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    2c7c:	10 92 7b 01 	sts	0x017B, r1
    2c80:	10 92 7a 01 	sts	0x017A, r1
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    2c84:	83 e1       	ldi	r24, 0x13	; 19
    2c86:	91 e0       	ldi	r25, 0x01	; 1
    2c88:	90 93 79 01 	sts	0x0179, r25
    2c8c:	80 93 78 01 	sts	0x0178, r24
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    2c90:	40 e0       	ldi	r20, 0x00	; 0
    2c92:	64 e0       	ldi	r22, 0x04	; 4
    2c94:	84 e1       	ldi	r24, 0x14	; 20
    2c96:	0e 94 c9 0a 	call	0x1592	; 0x1592 <xQueueGenericCreate>
    2c9a:	90 93 7d 01 	sts	0x017D, r25
    2c9e:	80 93 7c 01 	sts	0x017C, r24

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    2ca2:	8f ef       	ldi	r24, 0xFF	; 255
    2ca4:	9f ef       	ldi	r25, 0xFF	; 255
    2ca6:	dc 01       	movw	r26, r24
    2ca8:	80 93 7e 01 	sts	0x017E, r24
    2cac:	90 93 7f 01 	sts	0x017F, r25
    2cb0:	a0 93 80 01 	sts	0x0180, r26
    2cb4:	b0 93 81 01 	sts	0x0181, r27


	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    2cb8:	1f 91       	pop	r17
    2cba:	0f 91       	pop	r16
    2cbc:	08 95       	ret

00002cbe <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
    2cbe:	0e 94 42 02 	call	0x484	; 0x484 <_ZN8frt_task22_call_users_run_methodEPS_>

00002cc2 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2cc2:	0f 93       	push	r16
    2cc4:	cf 93       	push	r28
    2cc6:	df 93       	push	r29
    2cc8:	1f 92       	push	r1
    2cca:	cd b7       	in	r28, 0x3d	; 61
    2ccc:	de b7       	in	r29, 0x3e	; 62
    2cce:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2cd0:	fc 01       	movw	r30, r24
    2cd2:	22 85       	ldd	r18, Z+10	; 0x0a
    2cd4:	33 85       	ldd	r19, Z+11	; 0x0b
    2cd6:	44 85       	ldd	r20, Z+12	; 0x0c
    2cd8:	55 85       	ldd	r21, Z+13	; 0x0d
    2cda:	00 e0       	ldi	r16, 0x00	; 0
    2cdc:	be 01       	movw	r22, r28
    2cde:	6f 5f       	subi	r22, 0xFF	; 255
    2ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ce2:	80 85       	ldd	r24, Z+8	; 0x08
    2ce4:	91 85       	ldd	r25, Z+9	; 0x09
    2ce6:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xQueueGenericSend>
    2cea:	91 e0       	ldi	r25, 0x01	; 1
    2cec:	81 11       	cpse	r24, r1
    2cee:	01 c0       	rjmp	.+2      	; 0x2cf2 <_ZN14frt_text_queue7putcharEc+0x30>
    2cf0:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2cf2:	89 2f       	mov	r24, r25
    2cf4:	0f 90       	pop	r0
    2cf6:	df 91       	pop	r29
    2cf8:	cf 91       	pop	r28
    2cfa:	0f 91       	pop	r16
    2cfc:	08 95       	ret

00002cfe <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2cfe:	fc 01       	movw	r30, r24
    2d00:	80 85       	ldd	r24, Z+8	; 0x08
    2d02:	91 85       	ldd	r25, Z+9	; 0x09
    2d04:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <uxQueueMessagesWaiting>
    2d08:	91 e0       	ldi	r25, 0x01	; 1
    2d0a:	81 11       	cpse	r24, r1
    2d0c:	01 c0       	rjmp	.+2      	; 0x2d10 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2d0e:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2d10:	89 2f       	mov	r24, r25
    2d12:	08 95       	ret

00002d14 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2d14:	0f 93       	push	r16
    2d16:	cf 93       	push	r28
    2d18:	df 93       	push	r29
    2d1a:	1f 92       	push	r1
    2d1c:	cd b7       	in	r28, 0x3d	; 61
    2d1e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2d20:	00 e0       	ldi	r16, 0x00	; 0
    2d22:	2f ef       	ldi	r18, 0xFF	; 255
    2d24:	3f ef       	ldi	r19, 0xFF	; 255
    2d26:	a9 01       	movw	r20, r18
    2d28:	be 01       	movw	r22, r28
    2d2a:	6f 5f       	subi	r22, 0xFF	; 255
    2d2c:	7f 4f       	sbci	r23, 0xFF	; 255
    2d2e:	fc 01       	movw	r30, r24
    2d30:	80 85       	ldd	r24, Z+8	; 0x08
    2d32:	91 85       	ldd	r25, Z+9	; 0x09
    2d34:	0e 94 18 0c 	call	0x1830	; 0x1830 <xQueueGenericReceive>
    2d38:	81 30       	cpi	r24, 0x01	; 1
    2d3a:	49 f4       	brne	.+18     	; 0x2d4e <_ZN14frt_text_queue7getcharEv+0x3a>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2d3c:	89 81       	ldd	r24, Y+1	; 0x01
    2d3e:	99 27       	eor	r25, r25
    2d40:	87 fd       	sbrc	r24, 7
    2d42:	90 95       	com	r25
}
    2d44:	0f 90       	pop	r0
    2d46:	df 91       	pop	r29
    2d48:	cf 91       	pop	r28
    2d4a:	0f 91       	pop	r16
    2d4c:	08 95       	ret
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2d4e:	8f ef       	ldi	r24, 0xFF	; 255
    2d50:	9f ef       	ldi	r25, 0xFF	; 255
    2d52:	f8 cf       	rjmp	.-16     	; 0x2d44 <_ZN14frt_text_queue7getcharEv+0x30>

00002d54 <__udivmodsi4>:
    2d54:	a1 e2       	ldi	r26, 0x21	; 33
    2d56:	1a 2e       	mov	r1, r26
    2d58:	aa 1b       	sub	r26, r26
    2d5a:	bb 1b       	sub	r27, r27
    2d5c:	fd 01       	movw	r30, r26
    2d5e:	0d c0       	rjmp	.+26     	; 0x2d7a <__udivmodsi4_ep>

00002d60 <__udivmodsi4_loop>:
    2d60:	aa 1f       	adc	r26, r26
    2d62:	bb 1f       	adc	r27, r27
    2d64:	ee 1f       	adc	r30, r30
    2d66:	ff 1f       	adc	r31, r31
    2d68:	a2 17       	cp	r26, r18
    2d6a:	b3 07       	cpc	r27, r19
    2d6c:	e4 07       	cpc	r30, r20
    2d6e:	f5 07       	cpc	r31, r21
    2d70:	20 f0       	brcs	.+8      	; 0x2d7a <__udivmodsi4_ep>
    2d72:	a2 1b       	sub	r26, r18
    2d74:	b3 0b       	sbc	r27, r19
    2d76:	e4 0b       	sbc	r30, r20
    2d78:	f5 0b       	sbc	r31, r21

00002d7a <__udivmodsi4_ep>:
    2d7a:	66 1f       	adc	r22, r22
    2d7c:	77 1f       	adc	r23, r23
    2d7e:	88 1f       	adc	r24, r24
    2d80:	99 1f       	adc	r25, r25
    2d82:	1a 94       	dec	r1
    2d84:	69 f7       	brne	.-38     	; 0x2d60 <__udivmodsi4_loop>
    2d86:	60 95       	com	r22
    2d88:	70 95       	com	r23
    2d8a:	80 95       	com	r24
    2d8c:	90 95       	com	r25
    2d8e:	9b 01       	movw	r18, r22
    2d90:	ac 01       	movw	r20, r24
    2d92:	bd 01       	movw	r22, r26
    2d94:	cf 01       	movw	r24, r30
    2d96:	08 95       	ret

00002d98 <__tablejump2__>:
    2d98:	ee 0f       	add	r30, r30
    2d9a:	ff 1f       	adc	r31, r31

00002d9c <__tablejump__>:
    2d9c:	05 90       	lpm	r0, Z+
    2d9e:	f4 91       	lpm	r31, Z
    2da0:	e0 2d       	mov	r30, r0
    2da2:	09 94       	ijmp

00002da4 <__tablejump_elpm__>:
    2da4:	07 90       	elpm	r0, Z+
    2da6:	f6 91       	elpm	r31, Z
    2da8:	e0 2d       	mov	r30, r0
    2daa:	09 94       	ijmp

00002dac <memcpy>:
    2dac:	fb 01       	movw	r30, r22
    2dae:	dc 01       	movw	r26, r24
    2db0:	02 c0       	rjmp	.+4      	; 0x2db6 <memcpy+0xa>
    2db2:	01 90       	ld	r0, Z+
    2db4:	0d 92       	st	X+, r0
    2db6:	41 50       	subi	r20, 0x01	; 1
    2db8:	50 40       	sbci	r21, 0x00	; 0
    2dba:	d8 f7       	brcc	.-10     	; 0x2db2 <memcpy+0x6>
    2dbc:	08 95       	ret

00002dbe <memset>:
    2dbe:	dc 01       	movw	r26, r24
    2dc0:	01 c0       	rjmp	.+2      	; 0x2dc4 <memset+0x6>
    2dc2:	6d 93       	st	X+, r22
    2dc4:	41 50       	subi	r20, 0x01	; 1
    2dc6:	50 40       	sbci	r21, 0x00	; 0
    2dc8:	e0 f7       	brcc	.-8      	; 0x2dc2 <memset+0x4>
    2dca:	08 95       	ret

00002dcc <strncpy>:
    2dcc:	fb 01       	movw	r30, r22
    2dce:	dc 01       	movw	r26, r24
    2dd0:	41 50       	subi	r20, 0x01	; 1
    2dd2:	50 40       	sbci	r21, 0x00	; 0
    2dd4:	48 f0       	brcs	.+18     	; 0x2de8 <strncpy+0x1c>
    2dd6:	01 90       	ld	r0, Z+
    2dd8:	0d 92       	st	X+, r0
    2dda:	00 20       	and	r0, r0
    2ddc:	c9 f7       	brne	.-14     	; 0x2dd0 <strncpy+0x4>
    2dde:	01 c0       	rjmp	.+2      	; 0x2de2 <strncpy+0x16>
    2de0:	1d 92       	st	X+, r1
    2de2:	41 50       	subi	r20, 0x01	; 1
    2de4:	50 40       	sbci	r21, 0x00	; 0
    2de6:	e0 f7       	brcc	.-8      	; 0x2de0 <strncpy+0x14>
    2de8:	08 95       	ret

00002dea <ultoa>:
    2dea:	fa 01       	movw	r30, r20
    2dec:	cf 93       	push	r28
    2dee:	ff 93       	push	r31
    2df0:	ef 93       	push	r30
    2df2:	22 30       	cpi	r18, 0x02	; 2
    2df4:	cc f0       	brlt	.+50     	; 0x2e28 <ultoa+0x3e>
    2df6:	25 32       	cpi	r18, 0x25	; 37
    2df8:	bc f4       	brge	.+46     	; 0x2e28 <ultoa+0x3e>
    2dfa:	c2 2f       	mov	r28, r18
    2dfc:	2c 2f       	mov	r18, r28
    2dfe:	33 27       	eor	r19, r19
    2e00:	44 27       	eor	r20, r20
    2e02:	55 27       	eor	r21, r21
    2e04:	ff 93       	push	r31
    2e06:	ef 93       	push	r30
    2e08:	0e 94 aa 16 	call	0x2d54	; 0x2d54 <__udivmodsi4>
    2e0c:	ef 91       	pop	r30
    2e0e:	ff 91       	pop	r31
    2e10:	60 5d       	subi	r22, 0xD0	; 208
    2e12:	6a 33       	cpi	r22, 0x3A	; 58
    2e14:	0c f0       	brlt	.+2      	; 0x2e18 <ultoa+0x2e>
    2e16:	69 5d       	subi	r22, 0xD9	; 217
    2e18:	61 93       	st	Z+, r22
    2e1a:	b9 01       	movw	r22, r18
    2e1c:	ca 01       	movw	r24, r20
    2e1e:	60 50       	subi	r22, 0x00	; 0
    2e20:	70 40       	sbci	r23, 0x00	; 0
    2e22:	80 40       	sbci	r24, 0x00	; 0
    2e24:	90 40       	sbci	r25, 0x00	; 0
    2e26:	51 f7       	brne	.-44     	; 0x2dfc <ultoa+0x12>
    2e28:	10 82       	st	Z, r1
    2e2a:	8f 91       	pop	r24
    2e2c:	9f 91       	pop	r25
    2e2e:	cf 91       	pop	r28
    2e30:	0c 94 30 17 	jmp	0x2e60	; 0x2e60 <strrev>

00002e34 <utoa>:
    2e34:	fb 01       	movw	r30, r22
    2e36:	9f 01       	movw	r18, r30
    2e38:	42 30       	cpi	r20, 0x02	; 2
    2e3a:	74 f0       	brlt	.+28     	; 0x2e58 <utoa+0x24>
    2e3c:	45 32       	cpi	r20, 0x25	; 37
    2e3e:	64 f4       	brge	.+24     	; 0x2e58 <utoa+0x24>
    2e40:	64 2f       	mov	r22, r20
    2e42:	77 27       	eor	r23, r23
    2e44:	0e 94 40 17 	call	0x2e80	; 0x2e80 <__udivmodhi4>
    2e48:	80 5d       	subi	r24, 0xD0	; 208
    2e4a:	8a 33       	cpi	r24, 0x3A	; 58
    2e4c:	0c f0       	brlt	.+2      	; 0x2e50 <utoa+0x1c>
    2e4e:	89 5d       	subi	r24, 0xD9	; 217
    2e50:	81 93       	st	Z+, r24
    2e52:	cb 01       	movw	r24, r22
    2e54:	00 97       	sbiw	r24, 0x00	; 0
    2e56:	a1 f7       	brne	.-24     	; 0x2e40 <utoa+0xc>
    2e58:	10 82       	st	Z, r1
    2e5a:	c9 01       	movw	r24, r18
    2e5c:	0c 94 30 17 	jmp	0x2e60	; 0x2e60 <strrev>

00002e60 <strrev>:
    2e60:	dc 01       	movw	r26, r24
    2e62:	fc 01       	movw	r30, r24
    2e64:	67 2f       	mov	r22, r23
    2e66:	71 91       	ld	r23, Z+
    2e68:	77 23       	and	r23, r23
    2e6a:	e1 f7       	brne	.-8      	; 0x2e64 <strrev+0x4>
    2e6c:	32 97       	sbiw	r30, 0x02	; 2
    2e6e:	04 c0       	rjmp	.+8      	; 0x2e78 <strrev+0x18>
    2e70:	7c 91       	ld	r23, X
    2e72:	6d 93       	st	X+, r22
    2e74:	70 83       	st	Z, r23
    2e76:	62 91       	ld	r22, -Z
    2e78:	ae 17       	cp	r26, r30
    2e7a:	bf 07       	cpc	r27, r31
    2e7c:	c8 f3       	brcs	.-14     	; 0x2e70 <strrev+0x10>
    2e7e:	08 95       	ret

00002e80 <__udivmodhi4>:
    2e80:	aa 1b       	sub	r26, r26
    2e82:	bb 1b       	sub	r27, r27
    2e84:	51 e1       	ldi	r21, 0x11	; 17
    2e86:	07 c0       	rjmp	.+14     	; 0x2e96 <__udivmodhi4_ep>

00002e88 <__udivmodhi4_loop>:
    2e88:	aa 1f       	adc	r26, r26
    2e8a:	bb 1f       	adc	r27, r27
    2e8c:	a6 17       	cp	r26, r22
    2e8e:	b7 07       	cpc	r27, r23
    2e90:	10 f0       	brcs	.+4      	; 0x2e96 <__udivmodhi4_ep>
    2e92:	a6 1b       	sub	r26, r22
    2e94:	b7 0b       	sbc	r27, r23

00002e96 <__udivmodhi4_ep>:
    2e96:	88 1f       	adc	r24, r24
    2e98:	99 1f       	adc	r25, r25
    2e9a:	5a 95       	dec	r21
    2e9c:	a9 f7       	brne	.-22     	; 0x2e88 <__udivmodhi4_loop>
    2e9e:	80 95       	com	r24
    2ea0:	90 95       	com	r25
    2ea2:	bc 01       	movw	r22, r24
    2ea4:	cd 01       	movw	r24, r26
    2ea6:	08 95       	ret

00002ea8 <_exit>:
    2ea8:	f8 94       	cli

00002eaa <__stop_program>:
    2eaa:	ff cf       	rjmp	.-2      	; 0x2eaa <__stop_program>
